<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content=" 程序员创业极客学伟的技术博客iOS大牛百度">
<meta name="description" content="一名程序员创业过程中的内心独白">
<meta name="theme-color" content="#000">
<title>Java - 基础语法一 | 极客学伟个人主页</title>
<link rel="shortcut icon" href="/favicon.ico?v=1719370751035">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/atom-one-dark.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



  <meta name="description" content="Java - 基础语法一" />
  <meta name="keywords" content="Java" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>极客学伟个人主页</span>
            </a>  
          
        </div>
        
          <p class="subtitle">Stay Hungry, Stay Foolish</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="https://blog.csdn.net/qxuewei/" target="_blank">
                  <i class="fa fa-globe"></i> CSDN
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">极客学伟</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>👨🏻‍💻全职独立开发者👨🏻‍💻 </p>
      
        <p>独立开发作品：学伟扫描，加一... </p>
      
        <p>前百度高级iOS研发工程师~ </p>
      
        <p>旅行、篮球、阅读、电影、摄影爱好者~</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">53</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://qxuewei.github.io//atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/qxuewei">
              <i class="fa fa-github-alt" title="GitHub"></i>
            </a>
          
            <a href="https://twitter.com/qxuewei">
              <i class="fa fa-twitter" title="Twitter"></i>
            </a>
          
            <a href="https://weibo.com/qxuewei">
              <i class="fa fa-weibo" title="微博"></i>
            </a>
          
            <a href="https://www.zhihu.com/people/qxuewei/">
              <i class="fa fa-globe" title="知乎"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="/media/images/custom-array-imgSocials-1672900287491-socialImg.JPG" />
              <i class="fa fa-wechat" title="微信" ></i>
            </a>
          
        
      </div>
    </div>
  

  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80">Java - 基础语法一</a>
<ul>
<li><a href="#1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">① 基础语法</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%E4%B8%80%E6%A0%B7%E4%BD%86%E6%98%AF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%B8%8D%E4%B8%80%E6%A0%B7">方法重载：多个方法的名称一样，但是参数列表不一样</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BB%A5%E4%B8%8B%E5%9B%A0%E7%B4%A0%E6%9C%89%E5%85%B3">方法重载与以下因素有关：</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BB%A5%E4%B8%8B%E5%9B%A0%E7%B4%A0%E6%97%A0%E5%85%B3">方法重载与以下因素无关：</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%80%E7%A7%8D%E5%AE%B9%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%AD%98%E6%94%BE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90">数组：一种容器，可以同时存放多个数据源</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E7%89%B9%E7%82%B9">数组特点：</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84%E5%BD%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">动态初始化：在创建数组的时候，直接指定数组当中的数据元素个数</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%E5%A4%9A%E5%B0%91%E8%80%8C%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%B0%86%E5%85%B7%E4%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%8C%87%E5%AE%9A">静态初始化：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
<li><a href="#java-%E7%9A%84%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%81%E5%88%92%E5%88%86%E6%88%90%E4%B8%BA-5-%E4%B8%AA%E9%83%A8%E5%88%86">Java 的内存需要划分成为 5 个部分：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">② 面向对象</a>
<ul>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">局部变量和成员变量</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81">面向对象三大特性：封装、继承、多态</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a>
<ul>
<li><a href="#%E6%A0%BC%E5%BC%8F">格式：</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">构造方法使用注意事项：</a></li>
<li><a href="#%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB">标准的类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E5%B8%B8%E7%94%A8-api">③ 常用 API</a>
<ul>
<li><a href="#random">Random</a></li>
<li><a href="#arraylist">ArrayList</a></li>
<li><a href="#string">String</a>
<ul>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
</ul>
</li>
<li><a href="#static-%E5%85%B3%E9%94%AE%E5%AD%97">Static 关键字</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#math">Math</a></li>
</ul>
</li>
<li><a href="#4-%E7%BB%A7%E6%89%BF">④ 继承</a>
<ul>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">抽象方法</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-2">抽象类</a></li>
</ul>
</li>
<li><a href="#5-%E6%8E%A5%E5%8F%A3">⑤ 接口</a>
<ul>
<li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%BB%98%E8%AE%A4%E6%98%AF%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">接口中的方法默认是抽象方法</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95">接口中的默认方法</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">接口中静态方法</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">接口中的私有方法</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%8D%B3-%E5%B8%B8%E9%87%8F">接口中的“成员变量” 即 “常量”</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF">接口中的多继承</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7">接口其他特性</a></li>
</ul>
</li>
<li><a href="#6-%E5%A4%9A%E6%80%81">⑥ 多态</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">对象的向上转型</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">对象的向下转型</a></li>
<li><a href="#instanceof-%E5%85%B3%E9%94%AE%E5%AD%97"><code>instanceof</code> 关键字</a></li>
</ul>
</li>
<li><a href="#7-%E5%85%B6%E4%BB%96">⑦ 其他</a>
<ul>
<li><a href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><code>final</code> 关键字</a>
<ul>
<li><a href="#final-%E7%94%A8%E6%B3%95"><code>final</code> 用法</a></li>
</ul>
</li>
<li><a href="#java-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6">Java 中的四种权限修饰符</a></li>
<li><a href="#%E5%86%85%E9%83%A8%E7%B1%BB">内部类</a>
<ul>
<li><a href="#%E5%88%86%E7%B1%BB">分类：</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB">成员内部类</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB">如何使用成员内部类</a></li>
<li><a href="#%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">内部类使用外部类的成员变量</a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">局部内部类</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6">定义类的权限修饰符</a></li>
<li><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">匿名内部类</a></li>
</ul>
</li>
<li><a href="#interface-%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><code>interface</code> 作为成员变量</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://qxuewei.github.io/post/java-ji-chu-yu-fa-yi/">
      Java - 基础语法一
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-03-28</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://qxuewei.github.io/tag/9H4f1SDbS/">
        <span>Java</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>19分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>5362<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="java-基础语法一">Java - 基础语法一</h1>
<h2 id="1-基础语法">① 基础语法</h2>
<ul>
<li>JVM（Java Virtual Machine）: Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 程序，都运行在 JVM 之上。</li>
<li>JRE（Java Runtime Environment）：Java 程序的运行环境，包含 JVM 和运行时所需要的核心类库。</li>
<li>JDK（Java Development Environment）：Java 程序开发工具包，包含 JRE 和开发人员使用的工具。</li>
</ul>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="http://blog.image.jkxuewei.com/mweb/2020.03.28.15854041867234.15827280446149.jpg" alt="" loading="lazy"></figure>
<h3 id="方法">方法</h3>
<p>格式：</p>
<pre><code class="language-java">修饰符 返回值类型 方法名（参数列表）
{
    // 代码
    return 结果;// 如果返回值类型不为 void
}
</code></pre>
<h3 id="方法重载多个方法的名称一样但是参数列表不一样">方法重载：多个方法的名称一样，但是参数列表不一样</h3>
<h4 id="方法重载与以下因素有关">方法重载与以下因素有关：</h4>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数的多类型顺序不同</li>
</ul>
<h4 id="方法重载与以下因素无关">方法重载与以下因素无关：</h4>
<ul>
<li>与参数的名称无关</li>
<li>与方法的返回值类型无关</li>
</ul>
<h3 id="数组一种容器可以同时存放多个数据源">数组：一种容器，可以同时存放多个数据源</h3>
<h4 id="数组特点">数组特点：</h4>
<ol>
<li>数组是一种引用数据类型</li>
<li>数组当中的多个数据，类型必须统一</li>
<li>数组的长度在程序运行期间不可改变</li>
</ol>
<h4 id="动态初始化在创建数组的时候直接指定数组当中的数据元素个数">动态初始化：在创建数组的时候，直接指定数组当中的数据元素个数</h4>
<p>格式：<code>数据类型[] 数组名称 = new 数据类型[数组长度]</code></p>
<h4 id="静态初始化在创建数组的时候不直接指定数据个数多少而是直接将具体的数据内容进行指定">静态初始化：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定</h4>
<p>标准格式：<code>数据类型[] 数组名称 = new 数据类型[] {元素 1、元素 2、...}</code><br>
省略格式：<code>数据类型[] 数组名称 = {元素 1、元素 2、...}</code></p>
<h4 id="注意事项">注意事项</h4>
<ol>
<li>静态初始化没有直接指定长度，但是仍然会自动推算得到长度 <code>int[] arrayA = {10, 20, 30};</code></li>
<li>静态初始化标准格式可以拆分成两个步骤  <code>int[] arrayB; arrayB = new int[5];</code></li>
<li>动态初始化也可以拆分成两个步骤 <code>int arrayC; arrayC = new int [] {1, 2, 3 };</code></li>
<li>静态初始化一旦使用省略格式，就不能拆分成为两个步骤了</li>
</ol>
<h4 id="java-的内存需要划分成为-5-个部分">Java 的内存需要划分成为 5 个部分：</h4>
<ol>
<li>栈（Srack）：存放的都是方法中的局部变量，<strong>方法的运行一定在栈中</strong>
<ol>
<li>局部变量：方法的参数，或者是方法{} 内部的变量。</li>
<li>作用域：一旦超出作用域，立刻从栈内存当中消失。</li>
</ol>
</li>
<li><strong>堆（Heap）：凡是 new 出来的东西，都在堆当中</strong>
<ol>
<li>堆内存里面的东西都有一个地址值：16 进制</li>
<li>堆内存里面的数据，都有默认值</li>
</ol>
</li>
<li>方法区（Method Area）：存储 .class 相关信息，包含方法的信息。</li>
<li>本地方法栈（Native Method Stack）：与操作系统相关</li>
<li>寄存器（pc Register）：与 CPU 相关</li>
</ol>
<h2 id="2-面向对象">② 面向对象</h2>
<h3 id="局部变量和成员变量">局部变量和成员变量</h3>
<ul>
<li>定义的位置不同
<ul>
<li>局部变量：在方法内部</li>
<li>成员变量：在方法外部，直接写在类中</li>
</ul>
</li>
<li>作用范围不同
<ul>
<li>局部变量：只有在方法中才可以使用，出了方法就不能用</li>
<li>成员变量：整个类全都可以通用</li>
</ul>
</li>
<li>默认值不同
<ul>
<li>局部变量：没有默认值，如果想使用，必须手动进行赋值</li>
<li>成员变量：如果没有赋值，会有默认值，规则和数组一样</li>
</ul>
</li>
<li>内存位置不一样
<ul>
<li>局部变量：位于栈内存</li>
<li>成员变量：位于堆内存</li>
</ul>
</li>
<li>生命周期不一样
<ul>
<li>局部变量：随方法进栈而诞生，随着方法出栈而消失</li>
<li>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</li>
</ul>
</li>
</ul>
<h3 id="面向对象三大特性封装-继承-多态">面向对象三大特性：封装、继承、多态</h3>
<p>封装性在 Java 体现：</p>
<ul>
<li>方法就是封装</li>
<li>Private 关键字也是封装</li>
</ul>
<p><strong>对于基本数据类型当中的 boolean 值，Getter 方法一定要写成 isXxx 的形式，而 setXxx 规则不变</strong></p>
<h3 id="构造方法">构造方法</h3>
<p>构造方法是专门用来创建对象的方法，当我们通过关键字 new 来创建对象时，其实就是在调用构造方法</p>
<h4 id="格式">格式：</h4>
<pre><code>public 类名称(参数类型 参数名称) 
{
    方法体
}
</code></pre>
<h4 id="构造方法使用注意事项">构造方法使用注意事项：</h4>
<ul>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连 Void 都不写</li>
<li>构造方法不能 return 一个具体返回值</li>
<li>如果没有编写任何构造方法，编译器会默认生成一个构造方法，无参数、无方法体</li>
<li>一旦编写了至少一个构造方法，编译器便不再自动生成</li>
</ul>
<h4 id="标准的类">标准的类</h4>
<ol>
<li>所有的成员变量都要用 private 关键字修饰</li>
<li>为每一个成员变量编写一对儿 Getter/Setter 方法</li>
<li>编写一个无参数的构造方法</li>
<li>编写一个全参数的构造方法</li>
</ol>
<h2 id="3-常用-api">③ 常用 API</h2>
<h3 id="random">Random</h3>
<p>用于生成随机数<br>
<code>public int nextInt(int n)</code> 返回一个 [0,n) 之间的随机数。</p>
<h3 id="arraylist">ArrayList</h3>
<p>数组的长度不可以发生变化，ArrayList 集合的长度是可以随意变化的。<br>
如果希望向 ArrayList 当中存储基本类型数据，必须使用基本类型对应的“包装类”</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类（引用类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<h3 id="string">String</h3>
<p>程序中所有双引号字符串，都是 String 类的对象</p>
<h4 id="特点">特点</h4>
<ul>
<li>字符串的内容永不改变</li>
<li>正是因为字符串不可改变，所以字符串是可以共享使用的</li>
<li>字符串效果上相当于是 char[] 字符数组，底层原理是 byte[] 字节数组</li>
</ul>
<p>字符串常量池，在堆中开辟的一块空间。 使用 &quot;&quot; 直接创建的字符串都存放在字符串常量池中。</p>
<ol>
<li>对于引用类型来说，“==” 进行的是地址值的比较，基本数据类型是对值的比较；</li>
<li>双引号直接创建的字符串在常量池中，new 的不在池中。</li>
</ol>
<p>如果需要对字符串的内容进行比较，可以使用如下方法：</p>
<pre><code>public boolean equals(Object obj); // 严格区分大小写
public boolean equalsIgnoreCase(Object obj); // 忽略大小写
</code></pre>
<p><code>split</code> 方法的参数其实是一个正则表达式，如果要按照英文 . 进行切分，必须写 &quot;\\.&quot; (两个反斜杠)</p>
<h3 id="static-关键字">Static 关键字</h3>
<p>用来修饰成员变量和成员方法，被修饰的成员属于类的，而不是单单是属于某个对象的。</p>
<ul>
<li>当 <code>static</code> 修饰成员变量，该变量称为类变量，该类的每个对象都共享同一个类变量的值。<br>
格式：</li>
</ul>
<pre><code class="language-Java">static 数据类型 变量名;
</code></pre>
<ul>
<li>当 <code>static</code> 修饰成员方法时，该方法称为类方法。</li>
</ul>
<p>静态代码块：定义在成员位置，使用 <code>static</code> 修饰的代码块 {}</p>
<ul>
<li>位置：类中方法之外</li>
<li>执行：随着类的加载而执行且只执行一次，优先于 main 方法和构造方法的执行。</li>
<li>作用：类类变量进行初始化赋值。</li>
</ul>
<p>格式：</p>
<pre><code class="language-Java">public class className 
{
    static {
        /// 执行语句    
    }
}
</code></pre>
<h3 id="arrays">Arrays</h3>
<p><code>java.util.Arrays</code> 是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组常见操作。<br>
<code>toString(数组)</code> 将参数数组变成字符串<br>
<code>sort(数组)</code> 按照默认升序对数组的元素进行排序：注意 如果数组内是自定义类型，那么这个自定义类需要有 <code>Comparable</code> 或者 <code>Comparator</code> 接口的支持。</p>
<h3 id="math">Math</h3>
<p><code>abs(double num)</code> 绝对值<br>
<code>ceil(double num)</code> 向上取整<br>
<code>floor(double num)</code> 向下取整<br>
<code>round(double num)</code> 四舍五入<br>
<code>Math.PI</code> 圆周率</p>
<h2 id="4-继承">④ 继承</h2>
<h3 id="继承">继承</h3>
<p>子类继承父类的属性和行为，使得子类对象具有父类相同的属性、相同的行为，子类可以直接访问父类中的非私有的属性和行为。<br>
优点：<br>
1、提高代码的复用性<br>
2、类与类之间产生了关系，是多态的前提。</p>
<p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有变量时，需要使用 <code>super</code> 关键字修饰父类成员变量。</p>
<p>如果子父类中出现了同名的成员方法，这是的访问是一种特殊情况-称之为<strong>方法重写</strong></p>
<p>Java 中指支持单继承，不支持多继承。</p>
<h3 id="抽象类">抽象类</h3>
<p>父类中的方法，被他的子类们重写，子类各自的实现都不尽相同，那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了，我们把没有方法主体的方法称为抽象方法。包含抽象方法的类就是抽象类。</p>
<h3 id="抽象方法">抽象方法</h3>
<p>抽象方法，方法前加 <code>abstract</code> 关键字,去掉关键字，直接分号结束。<br>
定义格式：</p>
<pre><code class="language-Java">修饰符 abstract 返回值类型 方法名(参数列表);
</code></pre>
<h3 id="抽象类-2">抽象类</h3>
<p>抽象类：抽象方法所在的类，必须是抽象类才行，在 class 之前写上 <code>abstract</code> 即可。抽象类可以定义正常方法。<br>
定义格式：</p>
<pre><code class="language-Java">abstract class 类名字
{
    ///xxx
}
</code></pre>
<p>注意：</p>
<ul>
<li>抽象类不能实例化，必须用子类继承抽象父类，子类必须覆盖重写抽象类的所有抽象方法。</li>
<li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错，除非子类也是抽象类。</li>
</ul>
<h2 id="5-接口">⑤ 接口</h2>
<p>接口是 Java 中的一种引用类型，是方法的集合，如果类的内部封装了成员变量，构造方法和成员方法，那么接口的内部主要就是封装了方法。接口不是类，是一种引用数据类型，其他的引用数据类型还包括：数组、类。<br>
接口可包含五部分：常量、抽象方法、默认方法、静态方法、私有方法<br>
定义格式：</p>
<pre><code class="language-Java">public interface 接口名称
{
    // 抽象方法,继承类必须全部实现
    // 默认方法,default 修饰符修饰，可以继承可以重写，必须通过实现类来调用
    // 静态方法,只能通过接口名调用，不可通过实现类名或者实现类对象调用
    // 私有方法,私有成员方法只有默认方法可以调用、私有静态方法只有默认方法和静态方法可以调用
}
</code></pre>
<p>接口使用步骤：</p>
<ol>
<li>接口不能直接使用，必须有一个“实现类”来“实现”该接口；格式：<code>public class 实现类名称 implement 接口名称</code></li>
<li>接口的实现类必须覆盖重写接口中所有的抽象方法。</li>
<li>创建实现类的对象，进行使用</li>
</ol>
<p>注意事项：</p>
<ol>
<li>如果实现类并没有覆盖重写接口的所有抽象方法，那么这个实现类自己就必须是抽象类。</li>
<li>接口没有静态代码块或者构造方法</li>
<li>一个类的直接父类是唯一的，但是一个类可以用时实现多个接口。格式：<code>public class 类名称 implements 接口 A, 接口 B {}</code></li>
<li>多个接口存在相同名称抽象方法，实现类只需覆盖重写一次即可。</li>
<li>如果实现类没有覆盖重写所有接口中定义的所有抽象方法，那么实现类就必须是一个抽象类。</li>
<li>如果多个接口中存在相同名称的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li>
<li>一个类如果直接父类中的方法和接口当中的默认方法产生了冲突，优先用父类中的方法。（Java 继承优先级高于接口）</li>
</ol>
<h3 id="接口中的方法默认是抽象方法">接口中的方法默认是抽象方法</h3>
<p>格式： <code>public abstract 返回值类型 方法名称(参数列表);</code><br>
实现类必须覆盖重写接口所有抽象方法，除非实现类是抽象类。</p>
<h3 id="接口中的默认方法">接口中的默认方法</h3>
<p>接口中的默认方法可以解决接口升级的问题。<br>
格式：<code>public default 返回值类型 方法名称(参数列表);</code></p>
<h3 id="接口中静态方法">接口中静态方法</h3>
<p>不能用接口实现类的对象来调用接口中的静态方法，应该直接使用接口名称直接调用静态方法。<br>
格式：<code>public static 返回值类型 方法名称(参数列表);</code></p>
<h3 id="接口中的私有方法">接口中的私有方法</h3>
<p>抽取公共方法用来解决多个默认方法之间重复代码的问题，但这个共有方法不应该让实现类使用，应该是私有化的。<br>
格式：<code>private default  返回值类型 方法名称(参数列表);</code>、<code>private static  返回值类型 方法名称(参数列表);</code></p>
<h3 id="接口中的成员变量-即-常量">接口中的“成员变量” 即 “常量”</h3>
<p>接口中可以定义“成员变量”，但必须使用 <code>public static final</code> 三个关键字进行修饰（可省略）。从效果上看，这其实就是接口的“常量”。一旦使用 <code>final</code> 关键字，说明不可变<br>
格式：<code>public static final 数据类型 名称 = 数据值;</code><br>
注意事项：</p>
<ol>
<li>接口中的常量，可以省略 <code>public static final</code> 关键字。含义不变。</li>
<li>接口中的常量，必须进行赋值，不能不赋值。</li>
<li>建议常量名称大写。多个单词用 _ 分割。</li>
</ol>
<h3 id="接口中的多继承">接口中的多继承</h3>
<ul>
<li>类与类之间是单继承的，直接父类只有一个</li>
<li>类与接口之间是多继承的，一个类可以实现多个接口</li>
<li>接口与接口之间是多继承的
<ul>
<li>多个父接口中的抽象方法可以重复</li>
<li>多个父接口中的默认方法如果重复，必须在子接口进行覆盖重写，并带 <code>default</code> 关键字。</li>
</ul>
</li>
</ul>
<h3 id="接口其他特性">接口其他特性</h3>
<ul>
<li>接口中，无法定义成员变量，但可以定义常量，其值不可改变，默认使用 <code>public static final</code> 修饰，可以省略、</li>
<li>接口中，没有构造方法，不能创建对象</li>
<li>接口中，没有静态代码块</li>
</ul>
<h2 id="6-多态">⑥ 多态</h2>
<p>对象具有多个形态<br>
代码中体现多态性，父类引用指向子类对象。格式：<code>父类名称 对象名 = new 子类名称();</code> 或 <code>接口名称 对象名 = new 实现类名称();</code></p>
<p>多态访问成员变量的两种方式：</p>
<ol>
<li>直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。（成员变量无法进行覆盖重写）</li>
<li>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</li>
</ol>
<p>多态访问成员方法：<br>
看 new 的是谁，就优先用谁，没有则向上找。</p>
<p>口诀：<br>
多态访问成员变量：编译看左边，运行也看左边<br>
多态访问成员方法：编译看左边，运行看右边。</p>
<p>多态的好处：无论右边 new 的是哪个子类对象，左边声明的类和调用的方法可以保持一致。</p>
<h3 id="对象的向上转型">对象的向上转型</h3>
<p>其实就是多态的写法：<code>父类名称 对象名 = new 子类名称();</code><br>
含义：右侧创建一个子类对象，把它当做父类看待使用。<br>
注意事项：向上转型一定是安全的。类似于基本数据类型的类型转换 （float -&gt; double）<br>
弊端：一旦向上转型为父类，那么就无法调用子类原本特有的内容。（解决方案-使用向下转型）</p>
<h3 id="对象的向下转型">对象的向下转型</h3>
<p>其实是一个还原的动作。格式：<code>子类名称 对象名 = (子类名称)父类对象;</code><br>
含义：将父类对象，<strong>还原</strong>为本来的子类对象<br>
注意事项：<br>
必须保证对象创建的时候就是向下转型的类型。</p>
<h3 id="instanceof-关键字"><code>instanceof</code> 关键字</h3>
<p>返回一个 boolean 值，判断前面的对象能不能当做后面类型的实例。<br>
格式：<code>对象名 instanceof 类名</code></p>
<h2 id="7-其他">⑦ 其他</h2>
<h3 id="final-关键字"><code>final</code> 关键字</h3>
<p>用于修饰<strong>不可改变</strong>的内容</p>
<h4 id="final-用法"><code>final</code> 用法</h4>
<ol>
<li>修饰类：不能有任何子类，而且一个类如果是 <code>final</code> 的，那么其中所有的成员方法都无法对其进行覆盖重写</li>
<li>修饰方法：这个方法不能被覆盖重写，对于类和方法而言，<code>abstract</code> 关键字和 <code>final</code> 关键字不能同时使用，因为矛盾。</li>
<li>修饰局部变量：这个变量只能被赋值一次，不能再次被修改。“一次赋值，终生不变”。对于基本数据类型，不可变值得是变量中的数据不可变；对于引用类型，不可变指的是变量中的地址值不可变。</li>
<li>修饰成员变量：这个变量只能而且必须被赋值一次，不能再次被修改。而且不再有默认值。
<ol>
<li>由于成员变量具有默认值，所以用了 <code>final</code> 之后必须手动赋值，不会再有默认值。</li>
<li>对于 <code>final</code> 的成员变量，要么使用直接赋值，要么使用构造方法赋值，两者取其一。</li>
<li>如果使用构造方法对 <code>final</code> 修饰的成员变量赋值，必须保证类中所有重载的构造方法，都最终会对 <code>final</code> 的成员变量进行赋值。</li>
</ol>
</li>
<li>被 <code>final</code> 修饰的常量名称，一般有书写规范，所有字母均大写。</li>
</ol>
<h3 id="java-中的四种权限修饰符">Java 中的四种权限修饰符</h3>
<p><code>public &gt; protected (专门给不同包子类用的) &gt; (default) &gt; private</code></p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>（default）</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类（我自己）</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>用一个包（我邻居）</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>不同包子类（我儿子）</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>不同包非子类（陌生人）</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<h3 id="内部类">内部类</h3>
<h4 id="分类">分类：</h4>
<ol>
<li>成员内部类</li>
<li>局部内部类（包含匿名内部类）</li>
</ol>
<h4 id="成员内部类">成员内部类</h4>
<p>格式:</p>
<pre><code>修饰符 class 外部类名称 
{
    修饰符 class 内部类名称
    {
        xxx
    }
}
</code></pre>
<p>内部类可以直接访问外部类的成员，包括私有成员。<br>
外部类要访问内部类的成员，必须建立内部类的对象。<br>
即 : 内用外，随意访问。外用内需要借助内部类对象。</p>
<h4 id="如何使用成员内部类">如何使用成员内部类</h4>
<ol>
<li>间接方式：在外部类的方法中，使用内部类；然后 main 只是调用外部类的方法。</li>
<li>直接方式：定义格式：<code>外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</code></li>
</ol>
<h4 id="内部类使用外部类的成员变量">内部类使用外部类的成员变量</h4>
<p>如果出现重名现象，使用格式：<code>外部类名称.this.外部类成员变量名</code><br>
实例：</p>
<pre><code class="language-java">public class Outer
{
    int num = 10;
     public class Inner
     {
        int num = 20;
        public void methodInner()
        {
           int num = 30;
           System.out.println(num); // 局部变量，就近原则
           System.out.println(this.num); // 内部类的成员变量
           System.out.println(Outer.this.num); // 外部类的成员变量
        }
     }
}
</code></pre>
<h4 id="局部内部类">局部内部类</h4>
<p>如果一个类定义在一个方法内部，那么就是局部内部类。<br>
“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。</p>
<p>局部内部类如果要访问所在方法的局部变量，那么这个局部变量必须是【有效 final 的】即 用 final 声明的变量或者事实上只赋值一次的变量。<br>
原因：new 出来的对象在堆内存中，局部变量跟着方法走，在栈内存中。方法运行结束立刻出栈，局部变量立即消失。但是 new 出来的对象会在堆中持续存在，直到垃圾回收消失。</p>
<h4 id="定义类的权限修饰符">定义类的权限修饰符</h4>
<ul>
<li>外部类：<code>public 或 (default)</code></li>
<li>成员内部类：都可以</li>
<li>局部内部类：什么都不能写</li>
</ul>
<h4 id="匿名内部类">匿名内部类</h4>
<p>如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用<strong>匿名内部类</strong></p>
<p>定义格式：</p>
<pre><code>接口名称 对象名 = new 接口名称()
{
    /// 覆盖重写接口中所有的抽象方法。
}
</code></pre>
<p>对格式 &quot;new 接口名称(){...}&quot; 进行解析：</p>
<ol>
<li>new 代表创建对象的动作</li>
<li>接口名称就是匿名内部类需要实现哪个接口</li>
<li>{...} 这才是匿名内部类的内容</li>
</ol>
<p>注意事项：</p>
<ol>
<li>匿名内部类，在【创建对象】的时候只能使用唯一一次，如果希望多次创建对象，那么就必须使用单独定义的实现类。</li>
<li>匿名对象，在【调用方法】的时候只能调用唯一一次，如果希望同一个对象调用多次方法，那么必须给对象起个名字。</li>
<li>匿名内部类是省略了【实现类/子类名称】，但是匿名对象时省略了【对象名称】，匿名内部类和匿名对象不是一回事！！</li>
</ol>
<h3 id="interface-作为成员变量"><code>interface</code> 作为成员变量</h3>
<p>使用接口作为成员变量以便随时更换实现方式，这种设计更为灵活，增强了程序的扩展性。<br>
接口作为成员变量时，对他进行复制的操作，实际上是赋给他接口的一个子类实现对象。</p>
<p>接口作为参数数，传递它的子类对象；<br>
接口作为返回值类型是，也是返回它的子类对象。</p>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      极客学伟
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://qxuewei.github.io/post/java-ji-chu-yu-fa-yi/" title="Java - 基础语法一">https://qxuewei.github.io/post/java-ji-chu-yu-fa-yi/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://qxuewei.github.io/tag/9H4f1SDbS/"># Java</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Java - 基础语法二" href="https://qxuewei.github.io/post/java-ji-chu-yu-fa-er/">Java - 基础语法二</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Java - 基础语法二" href="https://qxuewei.github.io/post/java-ji-chu-yu-fa-er/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="iOS - 类与对象" href="https://qxuewei.github.io/post/ios-lei-yu-dui-xiang/">iOS - 类与对象</a>
        <a class="nav-mobile-next" title="iOS - 类与对象" href="https://qxuewei.github.io/post/ios-lei-yu-dui-xiang/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '9b5a81cc33693e3ea874',
    clientSecret: '7bb94672c847c4aa5723a9419fc5b3db33ca0dd6',
    repo: 'Gittalk',
    owner: 'qxuewei',
    admin: ['qxuewei'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      <div style="text-align: center; margin-top: 20px; font-size: 14px; color: #888;">
        <p>京ICP备19006991号</p>
        <p> <a href="http://beian.miit.gov.cn" target="_blank" rel="nofollow">工信部备案查询</a></p>
    </div>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-36gap-year/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记36gap-year&#34;&gt;程序员自由创业周记#36：Gap Year&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/307008/pexels-photo-307008.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;一整年&#34;&gt;一整年&lt;/h3&gt;
&lt;p&gt;刚过去的一周，度过了我31周岁的生日，距离结束上一份工作，刚好一年。一年过得好快，犹记得刚失业那会的迷茫，第一个月的纠结，是继续打工还是自己当“老板”。好在只纠结了一个月，就坚定的开始创业了，如果再既想又想，可能什么都做不好。起初就是把这次旅程当做Gap Year 看待的，西方的Gap Year是毕业后上班之前休整一年，用这一年去做自己喜欢的事，明确自己的人生方向。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;国内盛行的卷文化很少遇到Gap的，大多数是从没毕业就开始工作，一直到退休，也正如30岁之前的我。但我知道那不是我想要的生活。在之前工作的时候，架构师非常敬业，经常是组里走得最晚的那一个，遇到问题也是优先解决，极其敬业，有时凌晨也会在工作群里发消息，似乎把自己全部贡献了给了工作。后来我想，按照职场的晋升之路，若干年以后我也可能会走到那一步，但那肯定不是我想要的。就那么一瞬间，我发现职场不适合我。&lt;/p&gt;
&lt;p&gt;后来有机会体验一次Gap Year，去做我真正喜欢，想做的事。&lt;/p&gt;
&lt;h3 id=&#34;有意思的一年&#34;&gt;有意思的一年&lt;/h3&gt;
&lt;p&gt;起初的焦虑几乎每天都萦绕在我周边，没收入那段时间，去篮球场打球都提不起兴致。偶尔会看着天空发呆，好在执行力比较强，一直在工作，为自己的产品工作。&lt;/p&gt;
&lt;p&gt;有时在公园工作，有时在图书馆，有时在咖啡馆，有时在小孩补习课的家长休息区，有时在游乐场边上，在老家，在亲戚家，最多的是在我租住的那个客厅窗户没有阳光还要每个月交4500的出租房里工作。因为在家，我可以用三台显示器。也不需要通勤的哪怕5分钟的时间。&lt;/p&gt;
&lt;p&gt;后来，去年底的时候楼下开始装修，每天工作的时候耳边萦绕着各种电钻的声音，持续了两个多月，终于声音没那么刺耳后年初又迎来了隔壁邻居的装修，又是熟悉的电钻声，因为是隔壁，还经常听到工友们谈天说地的声音，我戴着耳机对此不以为意，不会动摇我做软件的决心。直到最近几天，我听到了楼上拆墙的声音...&lt;/p&gt;
&lt;p&gt;这三家肯定不是约好的，他们肯定不知道他们有一位邻居在他们装修的时候一直在家只工作，不上班。&lt;/p&gt;
&lt;h3 id=&#34;本周工作&#34;&gt;本周工作&lt;/h3&gt;
&lt;p&gt;继续做AI画图的软件，完善灵动岛小组件 &lt;a href=&#34;https://apps.apple.com/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我美丽的媳妇给我设计了特别棒的Logo。&lt;/p&gt;
&lt;p&gt;也在小红书请了独立设计师按照我的原型设计了UI，还可以。用AI辅助作图，很多有意思的功能可以做，文字生成图片、AI头像、老照片修复...&lt;/p&gt;
&lt;p&gt;值得一提的是我的第一个独立软件“&lt;a href=&#34;https://apps.apple.com/app/id1468603429&#34;&gt;学伟扫描 - OCR&amp;amp;PDF扫描打印&lt;/a&gt;”是图片转文字。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.06.14.17183266424370.17183258615765.jpg&#34; alt=&#34;AI画图王&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5月收支&#34;&gt;5月收支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支出：14464.96&lt;/li&gt;
&lt;li&gt;收入：$789.98&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;已经达到一年以前为自己设定的目标，会坚定的一直走下去，不动摇。我也会持续告诉跟我一样的程序员，除了上班，还有其他的路可以走，不用非得是送外卖和跑滴滴。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#36：Gap Year</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-35wai-bao-ji-zhu-xuan-xing-he-mai-fang/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记35外包-技术选型和卖房&#34;&gt;程序员自由创业周记#35：外包、技术选型和卖房&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/8430048/pexels-photo-8430048.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;对待外包的态度&#34;&gt;对待外包的态度&lt;/h3&gt;
&lt;p&gt;外包是来钱最快的方式，通过出售自己的时间和技能换取报酬，一定程度上与上班类似。创业后一直在做自己的产品，从习惯打卡软件：&lt;a href=&#34;https://apps.apple.com/app/id1477743089&#34;&gt;加一&lt;/a&gt;，到灵动岛软件：&lt;a href=&#34;https://apps.apple.com/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt;，然后Mac休息提醒软件：&lt;a href=&#34;https://apps.apple.com/app/id6471501135&#34;&gt;Nap&lt;/a&gt;，到现在正在开发AI作图软件：AI画图王。做自己的产品最开心的就是自由，设计、交互、功能都是自己定，不需要看任何人的脸色，没有deadline。如果有外包的机会来到面前，该怎么对待呢，说下我的态度。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;上周好朋友有一个不错的iOS私活，横跨半个北京，见了对方的老板，互相了解了下对方，相谈甚欢。后来与对方技术经理聊了下需求细节，最后我给了报价后就一直没下文了。我猜是双方的需求并没有匹配上。作为外包公司，希望能用就行，没有UI按照原型图开发一个App自然预算不会太高。而我写代码又不会将就，即便是外包代码也要写得漂亮，按照上班时期的日薪报的价显然不会让人满意。通过这个小插曲，也坚定了自己不合适做外包，可能以后也不会有类似的机会，即便有，也不准备再为此投入时间。&lt;/p&gt;
&lt;h3 id=&#34;技术选型&#34;&gt;技术选型&lt;/h3&gt;
&lt;p&gt;准备给AI画图王写代码的时候采用什么语言和使用什么框架费了一点功夫，目前会的技术栈有老古董Objective-C，Swift，Flutter和SwiftUI。OC这门上个世纪的语言是第一需要排除的，在Flutter和SwiftUI之间犹豫了一番，Flutter看起来是最适合的，跨平台，性能也不错。但是，我不擅长，而且性能和开发速度也不如原生，最后选择了继续深耕在Apple原生平台，不同的是这次用的SwiftUI这个Apple近年来强推的新框架。计划下个月上架iOS版本，下下个月上架Mac版本。&lt;/p&gt;
&lt;h3 id=&#34;卖房&#34;&gt;卖房&lt;/h3&gt;
&lt;p&gt;为了降低每月开销，第一步去掉房贷，而且烟台基本也不会回去了，17年中烟台买的那个距离海边2km的房子没有必要再留了，挂的价格是那个小区三居室单价最便宜的（69W 单价5800），值得一提的是，假如卖出去还完贷款，就没剩了。首付蒸发了，过去有几年的努力付之一炬。有时候，选择比努力更重要。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.31.17171208727546.IMG_0374.PNG&#34; alt=&#34;IMG_0374&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;p&gt;摸鱼的一周，学习新技术，开发新产品，打球，看比赛...&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#35：外包、技术选型和卖房</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-34zhi-bo-qiao-dai-ma/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记34直播敲代码&#34;&gt;程序员自由创业周记#34：直播敲代码&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/1181675/pexels-photo-1181675.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=600&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;勇于尝试&#34;&gt;勇于尝试&lt;/h3&gt;
&lt;p&gt;过去一段时候经常很在意其他人的眼光，会提醒自己要做那个让所有人都满意的好人，随着时间的推移，想法渐渐有所转变，让所有人都满意是不可能的，即便优秀如孔子，也有很多人觉得他不好，被封建统治阶级利用。何况平凡如我这种资质平平的凡人，后来就不再那么在意别人的眼光。&lt;/p&gt;
&lt;p&gt;“别人怎么看我，关我什么事” - 佚名。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;写创业周记是尝试的一部分，你创业这些破事谁爱看啊，你一个月赔4块钱也有必要写篇周记(#6：劝退)记录一下，“这不是活该吗”，“老老实实找个班上不好吗”... 很多人投来鄙夷的眼光。&lt;/p&gt;
&lt;p&gt;后来，我又继续写了29篇，包括这篇。&lt;/p&gt;
&lt;p&gt;除了周记，我甚至开启了直播敲代码，直播画面就是我在家的工位，敲代码、画原型、学新技术、甚至读蹩脚的英语...&lt;/p&gt;
&lt;p&gt;把 Build In Public 维度又增加了一分。想看一看楼主背影的读者可以移步抖音搜索【极客学伟】这个用户。&lt;/p&gt;
&lt;h3 id=&#34;拥抱aigc&#34;&gt;拥抱AIGC&lt;/h3&gt;
&lt;p&gt;新产品原本计划做一款个人OKR目标管理的软件，后来因为美丽的媳妇让我给她用AI做一张图的时候，发现没有特别好用的手机App产品，有些网页产品生成的效果也不那么尽如人意。灵机一动，要不要做一款AI软件，AI作图。去年AI火爆，各种ChatGPT套壳软件如雨后春笋般涌现，当时我没有加入，一是觉得有灵动岛这个我更想做的产品，另外就是竞争太过激烈。&lt;/p&gt;
&lt;p&gt;近期简单调研发现，AI生成图片的软件还没那么多，竞争相对小一点。如果做一款Apple全平台的原生文生图软件，降低人使用AI的门槛...&lt;/p&gt;
&lt;p&gt;说干就干。&lt;/p&gt;
&lt;p&gt;AI画图王原型图应运而生。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.17.17159119900769.17159108384181.jpg&#34; alt=&#34;AI画图王原型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;aiphoto&#34;&gt;AIPhoto&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.17.17159119900795.17159114803318.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;创建代码仓库发现这个名字已经存在了三年，回想起来是当初流行老照片修复的时候也打算做一款同类型的软件，后来因为上班忙和自己懒最终搁浅了。进一步联想，被我搁浅的项目还有好多，有些代码都写了很多了。比如17年抖音刚火的时候打算做一款文字生成抖音视频的软件，那种只播放文字的抖音视频，后来选择做了OCR。然后就是Mac端的截图软件，代码也已经写了好多。基本流程已经跑通，目前依然没有上线。&lt;/p&gt;
&lt;p&gt;然后就是平时记录的一堆产品想法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.17.17159119900808.17159116554299.jpg&#34; alt=&#34;项目灵感&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这么看我自己写软件创业并不是心血来潮，是很久很久就在心里埋下的种子。&lt;/p&gt;
&lt;p&gt;只是现在发了个芽。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#34：直播敲代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-33chuang-ye-zhe-de-yi-tian/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记33创业者的一天&#34;&gt;程序员自由创业周记#33：创业者的一天&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/1226398/pexels-photo-1226398.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;一天的安排&#34;&gt;一天的安排&lt;/h3&gt;
&lt;p&gt;只工作不上班的日子是非常考验一个人自律能力的，如果顶不住各种诱惑，一天的时间转瞬即逝。尤其对我这种兴趣极其广泛的人。如果不自律，上午一场NBA比赛就过去了；如果不自律，下午一场球就过去了；如果不自律，晚上一场电影又过去了。尤其手机上又有抖音、虎扑、B站这种时间黑洞类型的App，不自律，一天静悄悄的就过去了。&lt;/p&gt;
&lt;p&gt;怎么才能让自己战胜惰性，即便没人监督也能保持效率呢，我给自己的一些技巧就是：计划、番茄钟；&lt;/p&gt;
&lt;p&gt;比如我一天的安排：&lt;/p&gt;
&lt;h4 id=&#34;在改进之前&#34;&gt;在改进之前：&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026221.17153061347575.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这其中有几个问题就是，学完英语让自己进入工作状态后时间太晚，另外下午3点开始做饭又结束太早，晚上8点以后的工作时间很难得到保证。每天大概只有5小时真实工作时间，大概8个40分钟番茄钟，而这显然是不够的。&lt;/p&gt;
&lt;h4 id=&#34;后来进行了改进&#34;&gt;后来进行了改进&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026234.17153060115394.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;把英语学习时间提前到起床后，并且在早上做好一天的饭，一般炒两个菜。送完孩子之后就可以进入工作状态，一直到下午接孩子中间不吃饭，即便同样晚上的工作时间不能保证，也能有大概8小时专注时间。对于敲代码来说，持续的心流状态很难得，中间需要尽量少被打断。&lt;/p&gt;
&lt;p&gt;这是理想的状态，实践下来之后发现，我并没那么自律😄&lt;/p&gt;
&lt;p&gt;不过好在5点起床的习惯基本已经养成了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;p&gt;本周 &lt;a href=&#34;https://apps.apple.com/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 上线了台湾省用户许愿的灵动秒针功能，给他上线了这个功能，在灵动岛显示秒数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026240.17153075006160.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;效果&#34;&gt;效果&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026245.65DF21A6-AEBB-4C18-B5FB-9C7D6033E31B_1_105_c.jpeg&#34; alt=&#34;65DF21A6-AEBB-4C18-B5FB-9C7D6033E31B_1_105_c&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4月收支&#34;&gt;4月收支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支出：24509.56&lt;/li&gt;
&lt;li&gt;收入：$584.15&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026250.62281632-7D75-468A-B834-D5395A0E1F16_4_5005_c.jpeg&#34; alt=&#34;62281632-7D75-468A-B834-D5395A0E1F16_4_5005_c&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果不是连续摔坏两部手机，数码的支出原本不该有这么多。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#33：创业者的一天</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-32xin-chan-pin-gou-si/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记32新产品构思&#34;&gt;程序员自由创业周记#32：新产品构思&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/3340976/pexels-photo-3340976.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;新作品&#34;&gt;新作品&lt;/h3&gt;
&lt;p&gt;我时常把自己看做一位木匠，有点手艺，能做一些作品养活自己。而 加一、Island Widgets、Nap 就是我的作品。&lt;/p&gt;
&lt;p&gt;接下来在持续维护迭代的同时，要开启下一个作品的创造了。&lt;/p&gt;
&lt;p&gt;其实早在2022的10月份就已经开始搭建项目的基本框架并做了一些开发了。不过鉴于没有一套完善的UI和原型，进度一拖再拖。&lt;/p&gt;
&lt;p&gt;创业后发现，如果有一套完善的UI图、在编码和迭代速度方面都很快，然而边开发边自己设计既慢又丑。XWOKR 就是一个典型的例子，项目启动了一年多，依然是个Demo。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;创业这大半年，效率最高的还是拿到加一设计图，两耳不闻窗外事，一个月完成一个完整App的时期。&lt;/p&gt;
&lt;p&gt;最近也开始了Figma的学习，补足设计的短板。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.04.19.17134909020829.17134875991846.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;okr-的构思&#34;&gt;OKR 的构思&lt;/h3&gt;
&lt;p&gt;对于这个产品，脑海中时常会构思他的功能，大概是这样的：&lt;/p&gt;
&lt;p&gt;这是一个OKR产品，专注于个人目标管理的个人OKR，分不同时间阶段设定不同的目标，每个目标分成不同的可量化指标，每个可量化指标通过待办事项完成进度。（Objective -&amp;gt; KR -&amp;gt; TODO）&lt;/p&gt;
&lt;p&gt;最终的结果是随着各种待办的完成，所有的可量化指标进而达标，每一项指标的完成进而实现目标。（TODO -&amp;gt; KR -&amp;gt; Objective）。&lt;/p&gt;
&lt;p&gt;比如：设定目标：提高身体素质，分为指标1：每周至少跑步4次；指标2：每天至少睡8小时；指标3：每天至少步行5000步。&lt;/p&gt;
&lt;p&gt;每天的待办中完成相应的指标，自动记录进度。&lt;/p&gt;
&lt;p&gt;其他的特点就是周期性，每年、每个季度、每个月 制定不同的目标。&lt;/p&gt;
&lt;p&gt;复盘，对于完成有什么奖励、完不成有什么惩罚，在制定目标的时候就设置好。&lt;/p&gt;
&lt;p&gt;有时候每到年底复盘和年终总结，会觉得自己好像有些碌碌无为，其中很大一部分原因是不知道自己在干什么，为了什么，也没有直观能看到自己目标和理想的一个工具，新产品就是提供这个工具。即是给自己开发，也是为了其他有目标管理的用户。&lt;/p&gt;
&lt;p&gt;名字还没想好。&lt;/p&gt;
&lt;h3 id=&#34;本周进度&#34;&gt;本周进度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 新增日历组件，在灵动岛和锁屏显示iPhone自带的日历，提醒您不再忘记各种日程安排&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/app/id6471501135&#34;&gt;Nap - Break Reminder&lt;/a&gt; 优化内存占用&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#32：新产品构思</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-31wo-ceng-zou-zai-beng-kui-de-bian-yuan/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记31我曾走在崩溃的边缘&#34;&gt;程序员自由创业周记#31：我曾走在崩溃的边缘&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/18376941/pexels-photo-18376941.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;给大家推荐一本书&#34;&gt;给大家推荐一本书&lt;/h3&gt;
&lt;p&gt;《我曾走在崩溃的边缘》讲的是俞敏洪讲述新东方从0到1、从1到N的创业历程。很久以前就看过，虽然书中的内容已经忘得基本差不多了，但是书名仍记忆犹新。因为刚过去的这周，我也走在崩溃的边缘。&lt;/p&gt;
&lt;p&gt;原因是因为我的大意，导致过去两个月创业的收入付之一炬。本来今天没心情写周记的，但是这种心路历程还是值的记录一下。&lt;/p&gt;
&lt;p&gt;说是我的原因吧，我又觉得不全是。周二的下午，骑着我的小电动，迎着落日的晚霞在北京三环的辅路机动车道上一路疾驶，耳机里播放着 《一个创业“失败者”的自白》的播客（我还是那么喜欢骑行的时候听播客，就像过去5年骑自行车通勤时那样），突然耳机不响了，我似乎意识到了什么，下意识摸了下口袋，手机没了。随即调转车头回来时的路上找，值得庆幸的是在身后200米的地方找到了手机，不幸的是-碎了。一旁的行人告诉我说是刚才被车碾过去了。我拿着正在掉渣的手机，矗立在北京短暂春天傍晚的冷风中。电动车是用手机启动的，然而电动车锁了，手机无法启动。跟行人借手机打电话求助家人用她的手机给我电动车远程解锁，别人看我一年富力强的小伙手里拿着一个碎手机，纷纷避而远之，即便我坐公交车的时候每次都会给老人让座，但是此时依然没人借给我。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.04.12.17128929537491.17128929322605.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;祸不单行&#34;&gt;祸不单行&lt;/h3&gt;
&lt;p&gt;碎的手机是去年4月9号花7359买的iPhone 14 Pro Max，我灵动岛软件 Island Widgets唯一能真机测试灵动岛的主力机。而周二，也是4月9号。当晚拿着这台无法开机去手机店，店员看了直摇头，屏幕碎了、电池弯了、主板断了，三大件，一样没有好的。已经失去了维修的价值，回收的话可以换个脸盆。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;周记2：前期准备中提到我创业伊始买过一台iPhone12的测试机，幸亏有它，我还不至于失联，但是就是在第二天，我刚把手机卡放进去没多会，吃饭的时候从同一个口袋里掉在了地上，也坏了，开不了机了。&lt;/p&gt;
&lt;p&gt;要知道，现在已经不是上班巅峰的时候了，有工资心里有底，遇事不慌。这两天内失去9k，说走在崩溃的边缘也不为过吧，甚至当天晚上我下载了Boss直聘。奉劝想创业的程序员，在副业超过主业之前，尽量不要冒险全职做。&lt;/p&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;p&gt;上线了在灵动岛显示和处理系统待办的功能，解决的痛点是把Apple提醒事项的各种待办在锁屏或灵动岛显示和处理，无需打开App。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.04.12.17128928849122.17128925815463.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3月收支&#34;&gt;3月收支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支出：14520.05&lt;/li&gt;
&lt;li&gt;收入：$597&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#31：我曾走在崩溃的边缘</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-30liang-zhou-fa-bu-5-ge-ban-ben/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记30两周发布5个版本&#34;&gt;程序员自由创业周记#30：两周发布5个版本&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/6633920/pexels-photo-6633920.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;两周发布5个版本&#34;&gt;两周发布5个版本&lt;/h3&gt;
&lt;p&gt;过去两周，Island Widgets 发了5个版本，在灵动岛小组件这个极其细分的领域，我想做到极致，以致于在提到灵动岛上可以使用小组件，第一个想起的就是 Island Widgets。如果做到这个程度，还有很长的路要走，这也迫使我不求多，但求精。所以创业这半年来，主要精力还是在这个产品。五个版本分别上线了5个不同的新功能，有意思的新功能。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;新功能几乎都源于用户反馈，在自己斟酌后开发、测试、上线，这其中的标准就是有用和有趣。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555644.E66C08EB-7343-455B-8C84-0CAD82DE8FCC_1_101_o.jpeg&#34; alt=&#34;版本记录&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;灵动岛软件新功能喝水提醒&#34;&gt;灵动岛软件新功能：喝水提醒&lt;/h3&gt;
&lt;p&gt;喝水提醒这个领域之前就有耳闻，小众且细分的赛道。毕竟现代人的工作节奏之快，往往会不注重健康，等到渴了再去喝水的时候其实就是身体在抗议了。把每天喝水的数量放在灵动岛，每喝一次在灵动岛做个记录，每隔一段时间提醒，这全程不需要打开App。比起市面上的喝水提醒软件，操作便捷的同时满足了需求。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555664.BB2BB4A8-C539-48B2-991A-64DBBB27AA63_1_105_c.jpeg&#34; alt=&#34;喝水提醒&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;灵动岛软件新功能时速&#34;&gt;灵动岛软件新功能：时速&lt;/h3&gt;
&lt;p&gt;比如在骑车或者开车的时候，想看到自己当前的速度，也不想下载其他软件，那就可以使用 Island Widgets，把当前时速放在灵动岛上。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555677.BE544817-E7E3-4091-8933-3CA951DA3549_1_105_c.jpeg&#34; alt=&#34;灵动时速&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;灵动岛软件新功能一言&#34;&gt;灵动岛软件新功能：一言&lt;/h3&gt;
&lt;p&gt;如果每次拿起手机，手机上第一眼看到的是一句名言，会不经意中给自己加油打气。有些话，也能让自己有一些共鸣，&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555688.FED34EFD-8453-40F1-9371-0157FD230041_1_105_c.jpeg&#34; alt=&#34;灵动鸡汤&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;灵动岛软件新功能快递进度&#34;&gt;灵动岛软件新功能：快递进度&lt;/h3&gt;
&lt;p&gt;这个功能也是在之前发起投票中用户反馈最希望上线的功能，比如买了一个iPhone，不用再打开购物软件，把快递进度放在灵动岛，快递到哪了一目了然。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555699.17116836833244.jpg&#34; alt=&#34;软件共建&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;番外&#34;&gt;番外&lt;/h3&gt;
&lt;p&gt;分享一次有趣的经历，因为我不上班，所以几乎每个工作日的下午，我都会出现在体育公园的篮球场，那天一个白发苍苍的老爷爷走近我，语重心长的告诫我，年轻的时间是有限的，现在应该干什么，不要等以后老了后悔。我听后若有所思...&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#30：两周发布5个版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-29ru-guo-yu-dao-cai-yuan/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记29如果遇到裁员&#34;&gt;程序员自由创业周记#29：如果遇到裁员&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/1029141/pexels-photo-1029141.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;希望&#34;&gt;希望&lt;/h3&gt;
&lt;p&gt;希望你们的职业生涯永远不会遇到裁员，希望你们所在的部门善待员工，也希望你们的公司遵纪守法。但是，如果你们不幸遇上这种事，我也希望你们知道该如何对应。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;劳动法&#34;&gt;&lt;a href=&#34;https://www.gov.cn/flfg/2007-06/29/content_669394.htm&#34;&gt;劳动法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是劳动法的网址：https://www.gov.cn/flfg/2007-06/29/content_669394.htm 。&lt;/p&gt;
&lt;p&gt;我觉得这是每位劳动者都需要了解的法律。&lt;/p&gt;
&lt;p&gt;当企业想裁员可能会无所不用其极，很多人会受不了公司的PUA或各种威逼利诱接受了0赔偿或者N或者N+1的条件离开，在协议解除的离职合同上签了字，当你签了字，法律也不会保护你。&lt;/p&gt;
&lt;p&gt;当然，如果自己能接受，也未尝不可。&lt;/p&gt;
&lt;p&gt;但是我想告诉你的是，只要你没有犯特别大的错，法律规定的赔偿标准是2N。一般来说，拿到2N需要走法律途径。而且年终奖，如果走法律途径，大概率也能争取得到。&lt;/p&gt;
&lt;p&gt;所以你自己计算下省心拿走 N+1 离开 和 走法律途径拿 2N+年终 两者数额的差距，就能知道自己该采取哪种应对措施。所有低于 N+1 方案都是耍流氓。&lt;/p&gt;
&lt;h3 id=&#34;什么是犯特别大的错&#34;&gt;什么是“犯特别大的错”&lt;/h3&gt;
&lt;p&gt;看劳动法的第39条和第40条。其中容易中圈套的在 &amp;quot;严重违反用人单位的规章制度的&amp;quot; 和 &amp;quot;劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些公司会因为员工没按时提交周报说员工“严重违反”了规章制度，那就去找公司的规章制度里哪一条规定了。以此类推。&lt;/li&gt;
&lt;li&gt;“不胜任工作“，找公司的规章制度，什么标准是不胜任，而不是你的领导说你不胜任。即便真的不胜任了，需要给你培训，再次指定&lt;strong&gt;合理&lt;/strong&gt;标准进行考核。即便二次考核也不幸没达到标准，也是N+1走人。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如果想走法律途径维权&#34;&gt;如果想走法律途径维权&lt;/h3&gt;
&lt;p&gt;下面是我之前在一些律师群里收集到的应对方法，分享给你们。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.15.17104798993901.17104789339698.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;word文件完整版见：https://github.com/qxuewei/Laodongfa&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;当被告知被裁员&#34;&gt;当被告知被裁员&lt;/h3&gt;
&lt;p&gt;你在这家公司的生涯已经结束了，不要在抱有任何幻想。专心准备后续的路，记得挺起腰来。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.15.17104798993916.2B6E3095-6519-4719-905A-D3AAAA613BAD_1_105_c.jpeg&#34; alt=&#34;精神辞职&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;如果不给离职证明&#34;&gt;如果不给离职证明&lt;/h3&gt;
&lt;p&gt;把这段话发给你们的HR。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.15.17104798993928.7480b0436869cc2456773ef3a5335406.jpg&#34; alt=&#34;不给离职证明应对&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#29：如果遇到裁员</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-28xiao-qi/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记28小憩&#34;&gt;程序员自由创业周记#28：小憩&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/1804035/pexels-photo-1804035.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;专注&#34;&gt;专注&lt;/h3&gt;
&lt;p&gt;不知道你会不会有类似的经历：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;周末在家学习，有点累，玩会手机吧，2个小时过去了。。&lt;/li&gt;
&lt;li&gt;工作或学习效率太低，计划好的任务一改再改。。&lt;/li&gt;
&lt;li&gt;长时间工作不能自拔，由于一直盯着屏幕，视力一天不如一天。。&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;p&gt;之前的我经常会遇到类似的问题，经过几年的摸索，提高效率达成目标同时能保持健康的方式就是：计划+番茄钟。&lt;br&gt;
计划不必多说，一步步达成目标必不可少的步骤，我从18年开始列每天计划，这个习惯已经保持了6年。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592675.17092492400553.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;我的今日计划&#34;&gt;我的今日计划&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592699.17092490674948.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这其中的 F 就是 Fanqie 的 F。每一次番茄专注时间是 40分钟，每完成一次番茄专注，休息2分钟，看看远方、喝杯水、走动一下、活动活动脖子... 不至于一直盯着屏幕视力变差。&lt;/p&gt;
&lt;h3 id=&#34;番茄计时工具&#34;&gt;番茄计时工具&lt;/h3&gt;
&lt;p&gt;之前用的手机上的App，使用久了有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次番茄计时需要自己手动开启。&lt;/li&gt;
&lt;li&gt;需要拿起手机。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;众所周知，只要我们拿起手机，时间就会变得不可控。&lt;/p&gt;
&lt;p&gt;有没有能不需要我操作的番茄计时器呢、专注时长我能自己配置、休息时长我也能自己配置、每完成几次休息的时间长一点、休息的时候只能休息。&lt;/p&gt;
&lt;p&gt;没有，那就自己做一个。 &lt;a href=&#34;https://apps.apple.com/app/id6471501135&#34;&gt;Nap - Break Reminder&lt;/a&gt; 应运而生。一款在Mac端提醒休息的番茄钟产品。&lt;/p&gt;
&lt;p&gt;每次开启自动启动，我习惯把状态栏的图标隐藏掉，让他默默地在后台运行。每工作40分钟屏幕即无法使用，强制自己休息几分钟。休息结束会有提示音告诉我，需要开启新一次专注了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592715.96043B6A-0026-4BAF-B59C-B161D1432686_1_105_c.jpeg&#34; alt=&#34;休息效果&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592729.17085227772565.jpg&#34; alt=&#34;核心功能&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;尤其自己创业以后，时间完成自己掌控，更需要这个番茄钟给我提升工作效率，同时缓解疲劳,定时提醒喝水,避免久坐，更好的进行时间管理。&lt;/p&gt;
&lt;h2 id=&#34;怎么体验&#34;&gt;怎么体验&lt;/h2&gt;
&lt;p&gt;Mac 用户在 AppStore 搜索：&lt;a href=&#34;https://apps.apple.com/app/id6471501135&#34;&gt;Nap&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;或者浏览器直接输入：https://apps.apple.com/app/id6471501135&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#28：小憩</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-27xin-nian-kuai-le/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记27新年快乐&#34;&gt;程序员自由创业周记#27：新年快乐&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://dogefs.s3.ladydaily.com/~/source/unsplash/photo-1486078695445-0497c2f58cfe?q=80&amp;amp;w=3348&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;ixlib=rb-4.0.3&amp;amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%253D%253D&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;新年快乐&#34;&gt;新年快乐&lt;/h3&gt;
&lt;p&gt;给我的读者说一句迟来的新年快乐，希望我们在今年都能得偿所愿~&lt;/p&gt;
&lt;p&gt;回到老家，谈得最多的也是我目前的现状和想法，我自己何尝不是千万次的问自己呢，我创业的做法在很多人看来都是另类和不务正业的。为什么不去踏踏实实找个班上呢，即使是最亲最近的媳妇也想让我去找个班上，一个程序员，一年的Gap，或是更多年的Gap，无异于断送自己的职业生涯，尤其在我们国人的思想观念里。&lt;/p&gt;
&lt;p&gt;之前计划的13个月的梦已然过半，积蓄越来越少，仲裁的结果也犹如晴天霹雳，为什么还要坚持创业，坚持自己做软件卖呢，在坚持什么呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;我是这么想的&#34;&gt;我是这么想的：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;少挣的钱就当买了我的自由，而自由于我而言是无价的。&lt;/li&gt;
&lt;li&gt;人不能一辈子打工，需要有自己的事业，一份完全属于自己的事业。&lt;/li&gt;
&lt;li&gt;职场里的我就像温水里的青蛙，一年又一年，一年又一年... 毫无波澜。&lt;/li&gt;
&lt;li&gt;生命的意义于我而言就是体验，体验不同的经历。&lt;/li&gt;
&lt;li&gt;目前创业的收入已经超出我之前的预期。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;节点&#34;&gt;节点&lt;/h3&gt;
&lt;p&gt;过年期间跟媳妇定了一个节点，如果月收入达不到5k，今年8月份就去找工作。我也欣然答应，毕竟不是单身，还有家庭的责任要负，家里的顶梁柱一个月如果不能给家里带回5K，我也觉得是不称职的。而8月份就是这场13个月梦的最后一个月。按照目前的收入水平，还需多多努力才行。之前计划的是满第一年月收入3K就继续自己干，现在计划有变，不过依然志在必得。&lt;/p&gt;
&lt;h3 id=&#34;仲裁判决&#34;&gt;仲裁判决&lt;/h3&gt;
&lt;p&gt;之前聊过我开始创业的其中一个原因是被之前公司单方解除劳动合同，而且是无赔偿。仲裁在昨天出了判决书，因为在单方解除合同通知书上我签了字，而通知书上有一行“对通知内容没有异议” 的话，我当时只看到了 “签收页”。就像取快递签字一样签上了自己的名字，而这，是我败诉的原因。而我准备的十几个G的努力工作，解决工作问题，每天写日报汇报工作成果等等的证据，只字未提。希望我的读者不要遇到这种公司、这种部门，如果像我一样运气差，记得不要签字，任何字。&lt;/p&gt;
&lt;h3 id=&#34;新产品&#34;&gt;新产品&lt;/h3&gt;
&lt;p&gt;继创业后开发了 &lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一 - 自律打卡&lt;/a&gt; 和 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 两款产品后，这周发布了创业的第三个产品，下篇周记带来给大家认识。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#27：新年快乐</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-26shi-xi-sheng/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记26实习生&#34;&gt;程序员自由创业周记#26：实习生&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/6153354/pexels-photo-6153354.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;不发工资的实习生&#34;&gt;不发工资的实习生&lt;/h3&gt;
&lt;p&gt;一个人的力量是有限的，尤其是创业。因为要兼顾很多，需要的做的事也很多，而且时间有限，所以有一个帮手至关重要。不过鉴于创业的启动资金有限，雇人在现阶段是不现实的，所以只能通过其他的办法分担我的压力了，这个实习生就是 - AI。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;一个不用发工资的实习生。&lt;/p&gt;
&lt;h3 id=&#34;chatgpt&#34;&gt;ChatGPT&lt;/h3&gt;
&lt;p&gt;是ChatGPT但也不全是。&lt;/p&gt;
&lt;h4 id=&#34;xcode&#34;&gt;Xcode&lt;/h4&gt;
&lt;p&gt;Xcode集成了 &lt;a href=&#34;https://github.com/intitni/CopilotForXcode&#34;&gt;CopilotForXcode&lt;/a&gt;，敲代码的时候有一些简单的不太需要费脑的逻辑只要输入注释，基本会生成大致能用的代码，比如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.02.01.17067991103824.17067965788658.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;目前 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 有大概10% 的代码是 CopilotForXcode 替我写的，以前代码写的漂亮是我的核心竞争力，不过现在不是了，现在核心竞争力是创造和执行力。&lt;/p&gt;
&lt;h4 id=&#34;搜索&#34;&gt;搜索&lt;/h4&gt;
&lt;p&gt;以前搜索问题只有一个选项，Google。现在是 &lt;a href=&#34;https://chat.openai.com/&#34;&gt;chat.openai.com&lt;/a&gt; 。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.02.01.17067991103836.17067970619600.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;除了经常性的宕机不能访问，基本70%的问题都能解决，宕机的时候我会用 &lt;a href=&#34;https://poe.com/ChatGPT&#34;&gt;Poe&lt;/a&gt;，他本质上跟上面的网站是一样的，只不过Poe使用的 API 接口。在代码层面的问题，我个人觉得Poe比官方的网站更精确。回答的更令我满意一点。其他代码相关的AI服务也有尝试，不敢恭维。&lt;/p&gt;
&lt;h4 id=&#34;其他&#34;&gt;其他&lt;/h4&gt;
&lt;p&gt;AI在过去的一年已经渗透到生活的方方面面，列举我曾用过的服务除了敲代码以外，还有写演讲稿、做PPT、App的UI设计、应用商店的描述... 未来还会接触更多场景。毕竟这个“实习生”任劳任怨，除了解决问题别无他求。在各种平台经常有兜售AI教学的课程，给人一种现阶段你如果不马上学就要跟不上时代的错觉，我从来不会为之焦虑。底层还是自己的认知，AI只是个工具。&lt;/p&gt;
&lt;p&gt;至于未来程序员会不会被AI取代，我觉得大概率是不会的。因为它不会创造。&lt;/p&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;p&gt;依然是在开发 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt;。为每个功能提供悬浮窗功能，除了灵动岛、锁屏再增加一个展现场景。在“做最好的灵动岛应用”的路上砥砺前行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.02.01.17067991103844.17067990556390.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#26：实习生</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-25yi-ge-gong-neng-de-dan-sheng/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记25一个功能的诞生&#34;&gt;程序员自由创业周记#25：一个功能的诞生&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/4491918/pexels-photo-4491918.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1200&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;快捷启动&#34;&gt;快捷启动&lt;/h3&gt;
&lt;p&gt;记录在创业项目 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt;  中新增一个功能的诞生过程。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;功能名称：快捷启动。&lt;/p&gt;
&lt;p&gt;具体点：不用回到桌面在锁屏界面或者灵动岛就能打开其他App、网页或快捷指令。&lt;/p&gt;
&lt;h4 id=&#34;使用场景1&#34;&gt;使用场景1：&lt;/h4&gt;
&lt;p&gt;手机揣兜里从超市里买了一些东西，收银台付款。正常流程：&lt;br&gt;
点亮屏幕 -&amp;gt; 解锁 -&amp;gt; 上滑屏幕 -&amp;gt; 进入桌面 -&amp;gt; 左滑右滑找到微信所在的屏幕 -&amp;gt; 点击微信 -&amp;gt; 点击右上角加号 -&amp;gt; 找到扫一扫 -&amp;gt; 付款。&lt;/p&gt;
&lt;p&gt;开启 【快捷启动】 后付款流程：&lt;br&gt;
点亮屏幕 -&amp;gt; 点击微信扫一扫图标 -&amp;gt; 付款。&lt;/p&gt;
&lt;h4 id=&#34;使用场景2&#34;&gt;使用场景2：&lt;/h4&gt;
&lt;p&gt;刷微博遇到一个不懂的单词想查一下。正常流程：&lt;br&gt;
上滑屏幕 -&amp;gt; 进入桌面 -&amp;gt; 左滑右滑找到翻译App所在的屏幕 -&amp;gt; 点击翻译App -&amp;gt; 查&lt;/p&gt;
&lt;p&gt;开启 【快捷启动】 后查单词流程：&lt;br&gt;
长按灵动岛 -&amp;gt; 点击翻译App图标 -&amp;gt; 查&lt;/p&gt;
&lt;h4 id=&#34;使用场景3&#34;&gt;使用场景3：&lt;/h4&gt;
&lt;p&gt;做一道菜想问问ChatGPT怎么做。正常流程：&lt;br&gt;
点亮屏幕 -&amp;gt; 解锁 -&amp;gt; 上滑屏幕 -&amp;gt; 进入桌面 -&amp;gt; 左滑右滑找到Safari所在的屏幕 -&amp;gt; 点击Safari -&amp;gt; 点击网页输入框 -&amp;gt; 输入 chat.openai.com -&amp;gt; 问&lt;/p&gt;
&lt;p&gt;开启 【快捷启动】 后打开网页流程：&lt;br&gt;
点亮屏幕 -&amp;gt; 点击ChatGPT网页图标 -&amp;gt; 问。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;把一些常用的App、功能、网页或者快捷指令放在锁屏或是灵动岛上，想用的时候直接点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.01.26.17062304448149.CE3FE67D-EF24-4CE7-A13C-9032B2375A5E_1_102_o.jpeg&#34; alt=&#34;锁屏上的效果&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;功能已发布&#34;&gt;功能已发布&lt;/h3&gt;
&lt;p&gt;上周没写周记，一直在做这个让人兴奋以致于沉迷代码不能自拔的功能。从构思、设计、开发、测试、上线、推广所有的流程都自己做：&lt;/p&gt;
&lt;p&gt;比如可以自定义多个分组，上班时间、下班时间、周末分别使用不同的分组，每个分组用不同的启动项；&lt;/p&gt;
&lt;p&gt;比如长按灵动岛的时候显示快捷启动的图标，平常的时候灵动岛就可以显示步数和网速、或者帧率，天气等等现有的25个功能中的任何一个；&lt;/p&gt;
&lt;p&gt;再比如可以配置多行显示最多4行，每行显示最多9个，最多配置36个不同启动项；&lt;/p&gt;
&lt;p&gt;还有搜索，内置App清单，自定义任意启动项，自定义图标，同样的功能不同的开启形式用什么区分，复制，移动，调整顺序...&lt;/p&gt;
&lt;p&gt;所有的功能都是边做边想，边开发边设计，对于一个开发App的程序员，这是最大的乐趣，朋友有时问我最近怎么样，我一般都会回复他 “穷并快乐着”。&lt;/p&gt;
&lt;h2 id=&#34;怎么体验&#34;&gt;怎么体验&lt;/h2&gt;
&lt;p&gt;iPhone 用户在AppStore 搜索：&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;或者浏览器直接输入：https://apps.apple.com/cn/app/id6464542768&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#25：一个功能的诞生</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-24tao-chi-bei-shang-guang/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记24逃离北上广&#34;&gt;程序员自由创业周记#24：逃离北上广&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/8950929/pexels-photo-8950929.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;有没有这种城市&#34;&gt;有没有这种城市&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;房价：市区房价均价1W以内&lt;/li&gt;
&lt;li&gt;工资：每月工资能买一平米及以上的房子&lt;/li&gt;
&lt;li&gt;交通：路宽不堵车，高铁、高速发达，坐飞机方便&lt;/li&gt;
&lt;li&gt;快递：方便，包邮，3天内能到&lt;/li&gt;
&lt;li&gt;气候：四季分明，不潮湿，晴天多，有暖气&lt;/li&gt;
&lt;li&gt;人口：市区人口低于500万，宁静不嘈杂&lt;/li&gt;
&lt;li&gt;生活：肉蛋奶菜便宜，购物方便，有大医院&lt;/li&gt;
&lt;li&gt;教育：教育资源丰富，基础教育好&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;北漂8年&#34;&gt;北漂8年&lt;/h3&gt;
&lt;p&gt;我是15年11月份开始北漂，背井离乡每年回家一两次，父亲从四十多岁的小伙子变成了五十多岁的小老头子。这几年换了4份工作，搬了8次家。&lt;br&gt;
蒲黄榆 -&amp;gt; 花梨坎 -&amp;gt; 花家地 -&amp;gt; 霍营 -&amp;gt; 六里桥 -&amp;gt; 新村 -&amp;gt; 沙河 -&amp;gt; 洋桥。&lt;br&gt;
绕着北京转了一圈，现在又转回了最初的起点。&lt;br&gt;
犹记刚来北京那会还是个没毕业的学生，人生地不熟来这找活。下了火车打车去郑王坟人出租车司机不知道那地，但是那时我手里只有这个地址，其他的都不知道。&lt;br&gt;
也无奈，学的计算机，老家没相关的就业岗位，只能来这个陌生的城市碰碰运气，那也是第一次出省，好在运气还不错，这一路还算顺利。&lt;/p&gt;
&lt;p&gt;是时候考虑回去了。&lt;/p&gt;
&lt;h3 id=&#34;回哪呢&#34;&gt;回哪呢？&lt;/h3&gt;
&lt;p&gt;我家距离青岛火车站和潍坊火车站都是1h30min，17年在烟台买了一个小区自带篮球场游泳馆能看海的房子。所以除了长大的那个村，回就是在这三个城市里选。鉴于我之后的职业规划大概率是继续自由创业，自谋生路。下一站的考虑的条件就主要开篇提到的几点，放眼全国，其实能同时满足上面条件的城市也不多。&lt;/p&gt;
&lt;h4 id=&#34;三城数据对比&#34;&gt;三城数据对比&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;青岛&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;烟台&lt;/th&gt;
&lt;th&gt;潍坊&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;房价&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.5w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0.75w&lt;/td&gt;
&lt;td&gt;0.63w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;工资&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;13w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10w&lt;/td&gt;
&lt;td&gt;9w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;交通&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;地铁+高铁+机场&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;高铁+机场&lt;/td&gt;
&lt;td&gt;高铁+机场&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快递&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3天&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3天&lt;/td&gt;
&lt;td&gt;3天&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;气候平均气温+空气优良比例&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;12.7℃ - 83.3%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;12.6℃ (冬季多雪) - 87.8%&lt;/td&gt;
&lt;td&gt;12.6℃ - 71.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;市区人口&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;601w&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;252w&lt;/td&gt;
&lt;td&gt;251w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;生活-三甲医院&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;18个&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10个&lt;/td&gt;
&lt;td&gt;8个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;教育-本科率&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;52%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;52%&lt;/td&gt;
&lt;td&gt;55%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上数据来自搜索引擎，不保真。&lt;/p&gt;
&lt;p&gt;三座城市各有各的好，青岛最发达但房价最高、烟台房子在那但离家远归属感差、目前倾向于是回潍坊，上面的8条，都能满足。&lt;br&gt;
除了山东的地狱级别难度的高考，但是他爸能考上烟大，他妈中考全A还能考上北师大，而且都是在村里上的学，我相信他也行。&lt;br&gt;
即便不行也没事，开心不作恶就行。&lt;/p&gt;
&lt;p&gt;媳妇的研究生还得再上一年，目前初步计划是过完龙年回。&lt;/p&gt;
&lt;h3 id=&#34;12月收支&#34;&gt;12月收支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;家庭支出：14045&lt;/li&gt;
&lt;li&gt;创业收入：$430&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.01.11.17049273472393.F29309AC-7F40-4F71-8BB9-31F5659F21B5_1_105_c.jpeg&#34; alt=&#34;小里程碑-排名进前400&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 的创业项目正逐步走向正规，收入目前已经能覆盖我自己的日常开销，相信随着功能的完善，推广的继续，后续新产品的持续问世... 谁知道呢。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#24：逃离北上广</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-23nian-zhong-zong-jie/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记23年终总结&#34;&gt;程序员自由创业周记#23：年终总结&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/6149084/pexels-photo-6149084.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=600&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;身份转变&#34;&gt;身份转变&lt;/h3&gt;
&lt;p&gt;2023年最大的转变是从一名职场打工人变成一名创业者，或者称之为个体户，从月入xxxxx变成月入xxx，从卖自己的时间转变为卖自己做的软件，从每天上班如上坟变成每天活力满满精力充沛，从披星戴月到每天看夕阳。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;一些数字&#34;&gt;一些数字&lt;/h3&gt;
&lt;h4 id=&#34;微信读书-136-小时&#34;&gt;微信读书 - 136 小时&lt;/h4&gt;
&lt;p&gt;书读的还远远不够，书架上的书还有99%没读完。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031665.042479AA-2F72-4664-9D1B-0FBA4A50D538_4_5005_c.jpeg&#34; alt=&#34;微信读书&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;英语-98-天&#34;&gt;英语 - 98 天&lt;/h4&gt;
&lt;p&gt;每天学习30分钟满足打卡条件，蹩脚的英语水平一直困扰着我，记得有一次老外问路地铁站咋走，我想了半天就蹦出俩单词：Follow me！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031691.ED0FD5CE-AB20-4F25-9B58-1464AE30BAD4_1_105_c.jpeg&#34; alt=&#34;英语打卡&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;csdn-14275-万访问&#34;&gt;CSDN - 142.75 万访问&lt;/h4&gt;
&lt;p&gt;今年大概多了二十几万，写博客分享技术的第11年。&lt;br&gt;
庆幸自己有这么个博客，有个空间能记录一些代码技巧、学习笔记、读书笔记啥的，简历上写个博客地址面试机会也能稍微多点，记得有一次找活，招聘软件公开了一天简历约了一星期的面试，也不知道是不是因为有个人技术博客的缘故。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031707.17036443813205.jpg&#34; alt=&#34;CSDN&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;掘金-679-万阅读&#34;&gt;掘金 - 6.79 万阅读&lt;/h4&gt;
&lt;p&gt;技术分享的少了，流水账多了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031721.17038038507370.jpg&#34; alt=&#34;掘金&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;公众号-666-订阅&#34;&gt;公众号 - 666 订阅&lt;/h4&gt;
&lt;p&gt;其中 90% 是7月公开创业后围观周记的小伙伴。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031733.17038037141505.jpg&#34; alt=&#34;公众号&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;twitter-339-粉丝&#34;&gt;Twitter - 339 粉丝&lt;/h4&gt;
&lt;p&gt;我的一个观点：粉丝 != 认同；&lt;br&gt;
无需为别人的认同改变自己；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031744.C3D82FEC-8257-4E81-BE3F-060B93BB0179_4_5005_c.jpeg&#34; alt=&#34;X&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;软件作品-2-个&#34;&gt;软件作品 - 2 个&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;：灵动岛/锁屏小组件，包含骑行距离/步数/心率/运动热量/跑步距离/运动时间/体温/下班倒计时/照片/待办/天气/热搜/倒计时/手机使用次数/实时网速/CPU/RAM/屏幕帧率等 (iOS)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一 - 自律打卡&lt;/a&gt;：习惯养成打卡，追踪生活小事，记录日常情绪，计数、统计 (iOS)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么说也是一名有自己作品的程序员，此处叉腰 👯‍♂️。&lt;/p&gt;
&lt;h3 id=&#34;展望&#34;&gt;展望&lt;/h3&gt;
&lt;p&gt;当然这一年的丰富多彩得程度是这些冰冷数字远远无法代表的。&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0&amp;amp;scene=178&amp;amp;cur_album_id=3044710252514050050#rd&#34;&gt;周记#1&lt;/a&gt; 里说过的做一场13个月的梦，转眼已经过半了，幸好我还没有放弃，感谢屏幕对面素未谋面的你在百忙之中看我写的流水账。我不轻易许诺，明年能不能坚持写创业周记我也不确定，可以确定的是我还会继续去做我认为正确的事儿。&lt;/p&gt;
&lt;p&gt;人这一生有多久呢，如果按活到80岁算，也不过&lt;strong&gt;四千周&lt;/strong&gt;而已，马上放假了，祝各位新年快乐~&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#23：年终总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-22chu-hai-qu/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记22出海去&#34;&gt;程序员自由创业周记#22：出海去&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/240561/pexels-photo-240561.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;出海初体验&#34;&gt;出海初体验&lt;/h3&gt;
&lt;p&gt;工具类软件的特性是不用局限于某一个行业、也不用局限于某一个国家，所以出海是必须的选项，对于程序员而言，没有什么比做的软件有更多人用更令人兴奋；不熟悉互联网行业的人可能不了解什么是出海，不是出海打渔，是把软件推向海外市场，简称出海。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;虽然做的产品 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt; 上架第一天就已经在所有国家的应用市场发布，但并没有实际意义上的推广，我不去推广不会有人从数以百万的供过于求的软件市场里找到我做的这个的，如何对海外市场做推广: 第一站：&lt;a href=&#34;www.producthunt.com/&#34;&gt;Product Hunt&lt;/a&gt;。这是一个在海外流量比较大的专门用于推荐软件的网站，产品在 &lt;a href=&#34;www.producthunt.com/&#34;&gt;Product Hunt&lt;/a&gt; 上发布几乎这是出海必须要做的事。&lt;/p&gt;
&lt;h3 id=&#34;island-widgets-在-product-hunt&#34;&gt;&lt;a href=&#34;https://www.producthunt.com/products/island-widgets-screen-widgets&#34;&gt;Island Widgets 在 Product Hunt&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;听 &lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/64c729f0b3f6c440a87691ad&#34;&gt;出海去的播客 - Zeabur创始人聊Product Hunt榜一冲榜经验&lt;/a&gt; 和之前了解的，Product Hunt 需要提前准备，还要预热，我比较随性，没准备，直接就发布了，用的应用市场的截图。发布后在3个程序员的微信群里推荐了下，不能干巴巴拉票，我把上个月的收入都用来发了红包。程序员圈子还是比较友好的，很多陌生的朋友都投票表示了支持，甚至有很多几千粉丝的大V都帮我在 Twitter 上转发帮我拉票，感动...&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574709.17032119628852.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574733.17032120304887.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574749.17032120746956.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;出海成绩&#34;&gt;出海成绩&lt;/h3&gt;
&lt;p&gt;尽人事，听天命。虽说没有被 Featured (即Product Hunt官方推荐，首页没有我的产品)，但是也收获了 63 个 Upvoted （投票），比我预期的多了六十来个吧。如果想做的更好，需要提前成为 Product Hunt 的用户，勤评论、多给别人投票，像我，一个新用户，权重就很低。&lt;/p&gt;
&lt;h3 id=&#34;除此之外&#34;&gt;除此之外&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&#34;https://www.reddit.com/&#34;&gt;reddit&lt;/a&gt; 开始用英文版介绍软件的使用场景，虽说被删帖了，但是还是要勇于尝试。创业维艰，砥砺前行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574763.17032131511178.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#22：出海去</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-21da-v-de-yu-ce/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记21大v的预测&#34;&gt;程序员自由创业周记#21：大V的预测&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/18355088/pexels-photo-18355088.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;社媒&#34;&gt;社媒&lt;/h3&gt;
&lt;p&gt;不得不说，程序员圈子真小，尤其是独立开发相关标签的，周天打开X，推荐的第一条贴子讲的是博主看了一个人的周记，对他的未来很悲观，仔细看了看内容，裁员、北京、小孩上幼儿园、媳妇上研究生、月支出15k，这不说的就是我嘛~ 确实，流水账般的周记不知不觉写了20篇了，等以后再回首这段经历，看这些文字应该就够了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;看评论，有些人看到过我写的东西，大多数人是不看好的，有说赌博的、有说自不量力的、有说九死一生的... 居然还有说家里有矿的。哭笑不得。我不会去解释什么，他们说的都对，除了家里有矿，家里有三亩地倒是真的。为什么去创业而不去做风险更低的打工，主要原因是我不想打一辈子工，那可以边上班边搞啊，确实，我中间也有好多次想去投简历，但一想公众号里还有几百人等着看我更新，Island Widgets 还有那么多有意思的功能等着我去做，上班以后就没有这么多精力扑在产品上，现在这个行情还能找到工作吗，背那无聊的八股文时间打磨产品不好吗，然后我就把招聘软件关了。等明年再打开吧~&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.15.17026041104888.17025650708310.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我不是特别擅长经营社交平台，Twitter 从16年注册也就才发了十几篇贴子，最近也是为了让别人知道Island Widgets开始发的多了起来，所以在推上看到有人讨论我确实很意外。另外对创业遇到的困难我之前就有很充分的预期，也已经做好了一年没有收入的准备，在下一次踏入职场之前，我必须得有一份自己的事业，即便他很小。&lt;/p&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;p&gt;这几天北京一直下雪，儿子学校停课，时间大多都在陪孩子，看电视、做饭、读单词、哄睡觉、玩车、捉迷藏、摆积木、收拾玩具、玩雪、打雪仗啥的。还有就是给App - Island Widgets 加组合功能，在一个岛上可以集成四个功能，比如灵动岛左侧显示照片，右侧显示网速，长按显示待办，锁屏显示步数。算是待办清单里一项比较实用的功能。&lt;/p&gt;
&lt;h3 id=&#34;启动页&#34;&gt;启动页&lt;/h3&gt;
&lt;p&gt;App迭代了8个版本，刚发现启动页还没有内容，打开直接进首页。因为软件启动太快，以至于很难发现启动页的存在。不过为了表明态度，我还是打算在启动页加一句产品slogan，目前在“做最好的灵动岛应用” 和 “让灵动岛更灵动”之间犹豫。前者是目标，后者是使命。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#21：大V的预测</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-20xu-qiu-cong-he-er-lai/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记20需求从何而来&#34;&gt;程序员自由创业周记#20：需求从何而来&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/461064/pexels-photo-461064.jpeg&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;之前看过我周记的朋友应该了解我从7月份开始独立创业以来，主要做了两个产品，一个是加一，一个是&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt; ，上班的时候工作内容是上级主管分配，自己只管完成工作；那创业的工作内容谁来安排呢，我又是什么契机做了这两款产品，产品的需求从何而来，在这篇周记里聊一下；&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;加一&#34;&gt;加一&lt;/h4&gt;
&lt;p&gt;在今年6月份刚结束上份工作时纠结了很久是不是继续打工找个班上，最终经过2个星期的思想斗争决定听从内心为自己活一次，就决定创业了。创业内容也是我喜欢而且擅长的：做软件给自己也给别人用；&lt;/p&gt;
&lt;p&gt;一个偶然的契机，在一个微信群里看到一条消息：一个独立开发小团队招合作伙伴；本着向人学习的态度发了自荐邮件希望加入，经过简短的面谈也达成了合作意向；至此，创业第一个项目就诞生了，需求也就是合作伙伴中的产品经理兼设计师出，我只需要负责开发；上线后的收益按比例分成。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这是一种程序员独立创业比较常见的方式，也就是与其他人合作。各司其职，发挥自己的优势；&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;island-widgets-灵动岛锁屏小组件&#34;&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;经过一个多月的夜以继日的开发，加一如期上线，短暂调整后开启了第二个项目：灵动岛小组件，她的来源是我自身的需求，把我儿子或者媳妇的照片放在灵动岛，因为灵动岛特性，无论在使用任何app，都能看到；其次，最近一年开始逐渐注重work life balance (工作生活平衡)，工作并非生活的全部，所以我想做一个把下班倒计时放在灵动岛的功能，这样能提醒下我的朋友，该下班了，回家陪陪家人吧。后来，我喜欢打球，经常在下班后去球场打两小时篮球再回家，如果那天有风或者下雨，球就不能打了，那如果我把天气预报放在灵动岛上，不需要我一次次打开天气预报软件就知道现在的天气了，然后就有了天气预报功能；&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这是另外一种程序员独立创业比较常见需求来源，自己需要。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;迭代&#34;&gt;迭代&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  最初的需求主要从我自身而来，然后无限延展；在把产品推向市场之后，很多用户表示了对这个产品的喜爱，然后也提了一些他们的需求；我在自己斟酌和调研之后，加到了产品中，比如：&lt;/p&gt;
&lt;h5 id=&#34;实时网速&#34;&gt;实时网速&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542952.17010709125127.jpg&#34; alt=&#34;网速&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后我在产品里加了实时网速&lt;br&gt;
&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669229.17020049156145.jpg&#34; alt=&#34;Island Widgets 的网速&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;运行内存-cpu-帧率&#34;&gt;运行内存、CPU、帧率&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882616.17013392031306.jpg&#34; alt=&#34;用户需求&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后我在产品里加了运行内存、CPU、帧率&lt;br&gt;
&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669249.17020049918698.jpg&#34; alt=&#34;Island Widgets 的运行内存、CPU、帧率 &#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;多语言配置&#34;&gt;多语言配置&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669261.17020050753328.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后我在App里语言可配置，另外适配了31种语言；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669273.412F28AB-F343-4C94-8609-F2070346FC61_4_5005_c.jpeg&#34; alt=&#34;Island Widgets的语言配置&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;standby-和-iwatch适配&#34;&gt;StandBy 和 iWatch适配&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669284.17020053306701.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;也加到了待办清单中，除此之外还有很多来自用户的需求：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669296.17020054166233.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;这是另外一种程序员独立创业需求来源，用户需求。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;11月收支&#34;&gt;11月收支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支出：13345&lt;/li&gt;
&lt;li&gt;收入：上班月收入的1.5%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加一的新需求已经有了，&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt; 用户的需求也会慢慢满足，每天半小时的英语得学，天气好的时候篮球也得打，有勒布朗的比赛也要看，周记也要写，宣传Island Widgets的抖音也得发...&lt;/p&gt;
&lt;p&gt;每天都很忙碌😄&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#20：需求从何而来</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-19ding-jie-de-xue-wen/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记19定价的学问&#34;&gt;程序员自由创业周记#19：定价的学问&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/1888026/pexels-photo-1888026.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;封面&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;定价&#34;&gt;定价&lt;/h3&gt;
&lt;p&gt;在之前的周记里讲过，目前 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  的定价参照的是国外一款优秀的灵动岛软件价格的 1/10。而这个应用只有健康类目步数、热量、心率的6个组件，它的价格是148/每年，不能买断；&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882572.F976AF5B-E972-4D5B-A249-8D4298D5A701_4_5005_c.jpeg&#34; alt=&#34;健康类组件软件定价&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  除了健康类目的步数、跑步距离、体温、运动时间、心律、能量、骑行距离以外还有其他二十几种不同的小组件。倘若一直保持 12/每年，18买断的价格是有点低；看了下11月的销售数据，会员卖出去几十份，送出去十几份，扣除苹果税后收入大概是上班期间月收入的1%；如果收入一直这么少创业是不能持久的，不同于有资本助力的企业，不能一直为爱发电，&lt;/p&gt;
&lt;p&gt;又下载了另外一款国内优秀的做实时网速的软件，看了下它的定价：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882591.77911E25-5B78-4038-9C58-06EE358FEB33_4_5005_c.jpeg&#34; alt=&#34;实时网速组件定价&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而这些软件都集成了广告，广告也会为开发者带来收入，我再次陷入了沉思。&lt;/p&gt;
&lt;h3 id=&#34;定价-2&#34;&gt;定价&lt;/h3&gt;
&lt;p&gt;定价是一门学问，只要软件是收费的就会有人不满意；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882604.17013332323522.jpg&#34; alt=&#34;用户抱怨不是免费软件&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;定价太高用户就会望而却步，太低开发者也会入不敷出。如何保证这中间的平衡还需慢慢摸索。不过可以确定的是，随着功能的不断增多，用户体验的逐渐完善，&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  价格会相应的越来越高。&lt;/p&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;p&gt;这周北京有点冷，没去打球，就在家里专心满足用户的产品需求：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882616.17013392031306.jpg&#34; alt=&#34;用户需求&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;除了实时网速以外，增加了 CPU负载、RAM占用、屏幕帧率的实时显示；并进一步优化了耗电；比如把定位的精度调到最低、降低数据刷新频率、数据相同不渲染界面、App锁屏后停止更新等等；因为灵动岛的数据需要定时更新，频率太低会有用户反馈不及时、太高会增加一定的耗电；如何把握这其中的平衡也需慢慢摸索，目前处于一个我比较满意的节点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882632.92F0096D-29BB-459B-8FFC-17DD92814BFE_1_201_a.jpeg&#34; alt=&#34;Island Widgets 新首页&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#19：定价的学问</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-18iphone-xian-shi-shi-shi-wang-su/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记18iphone显示实时网速&#34;&gt;程序员自由创业周记#18：iPhone显示实时网速&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/3422964/pexels-photo-3422964.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;封面&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;用户反馈&#34;&gt;用户反馈&lt;/h3&gt;
&lt;p&gt;上周在经过一系列推广之后收到了许多正反馈，从一定程度上增强了我的创业决心，坚定的去做一些对用户有用的软件，其中最受用户期待的功能是：实时网速。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542903.17010705864743.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542925.17010706069630.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542939.17010707259991.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542952.17010709125127.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不像Android系统，iOS系统本身不支持实时网速的显示，在灵动岛出现之前也没有体验更好的解决方案，如果能在灵动岛上显示当前手机的实时网速，会是个对用户比较友好也比较酷的功能，说干就干，在研究了大量资料把功能实现了出来，然后进行了一系列优化让其更省电。最后上线。最终手机显示的效果如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010552141124.7502E698-73EC-466A-A17A-09F8D8C159B7_1_201_a.jpeg&#34; alt=&#34;请忽略壁纸上的美女，截图主要演示灵动岛网速的功能&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;另外，如果手机没有灵动岛，在锁屏界面也能显示当前的实时网速，见图：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010552141132.8A284B62-8219-40EF-9271-58323ED34D2B_1_201_a.jpeg&#34; alt=&#34;请忽略图中美女&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;不止网速&#34;&gt;不止网速&lt;/h3&gt;
&lt;p&gt;目前创业项目 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 在实时网速以外，还有 下班倒计时、手机拿起次数、步数、心率、热搜、待办、天气、抢票倒计时等一系列功能，还计划实现番茄钟、快捷启动、桌面小组件等功能，直到把这个软件做到我满意为止。&lt;/p&gt;
&lt;h2 id=&#34;怎么下载&#34;&gt;怎么下载？&lt;/h2&gt;
&lt;p&gt;iPhone 用户在AppStore 搜索：&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;或者浏览器直接输入：https://apps.apple.com/cn/app/id6464542768&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#18：iPhone显示实时网速</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-17shuo-bu-wan-de-gan-xie/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/8250916/pexels-photo-8250916.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;封面&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;感谢&#34;&gt;感谢&lt;/h3&gt;
&lt;p&gt;认识我的人应该知道，现实生活中的我是一个比较有礼貌的人，即便是在今年6月从前公司HR手里接过《单方违法解除合同通知书》的时候我也是跟她说的是谢谢，并且进行了一番颇为友好的对话，感谢近三年来公司的培养。更不用说最近两天收到的很多陌生人各种对 &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛&amp;amp;锁屏小组件&lt;/a&gt; 的赞美和认可了，我也只有说不完的感谢。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;推广&#34;&gt;推广&lt;/h3&gt;
&lt;p&gt;经过两个月的开发和完善，创业以来做的第2个软件：&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛&amp;amp;锁屏小组件&lt;/a&gt; 已经基本达到了进行推广的要求，程序员创业的大忌就是做的软件不进行推广，孤芳自赏，幻想着只通过自然流量爆火，也不是没有可能，但是很难。开发只是产品生命周期的第1步，后面还有9步要走。所以，在这周三，我开始了对&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets - 灵动岛&amp;amp;锁屏小组件&lt;/a&gt;的“叫卖”，取得了&lt;br&gt;
一定的效果：&lt;br&gt;
&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491891.iShot_2023-11-17_09.53.11.png&#34; alt=&#34;11月15趋势&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;尝试了以下这些方案：&lt;/p&gt;
&lt;h4 id=&#34;1-在-v2ex-网站上抽奖送终生会员&#34;&gt;1. 在 &lt;a href=&#34;https://www.v2ex.com/t/992091&#34;&gt;V2EX&lt;/a&gt; 网站上抽奖送终生会员&lt;/h4&gt;
&lt;p&gt;不得不说，V站的用户是素质最高也是最热情的，截止目前有4447次访问，231次回复，其中绝大部分回复都对软件表示了浓厚的兴趣和赞美。截取部分用户的回复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;198plus： 支持一下，感觉不错&lt;/li&gt;
&lt;li&gt;zheermao: 看上去不错，支持&lt;/li&gt;
&lt;li&gt;pinkayo: 造福了非灵动岛设备的使用者，真是太棒了。可以好好体验一下&lt;/li&gt;
&lt;li&gt;gabkfivyfbst: 不错啊看着，比很多软件的灵动岛设计都实用&lt;/li&gt;
&lt;li&gt;ychen997: 一直在看你的博客，来支持一下&lt;/li&gt;
&lt;li&gt;lefer: 非灵动岛用户刚刚付费了终身&lt;/li&gt;
&lt;li&gt;lma8：挺有意思&lt;/li&gt;
&lt;li&gt;wuhan027：已下载安装体验，感谢作者开发这么实用的 app ！&lt;/li&gt;
&lt;li&gt;laragh：v2 的开发老哥们都这么顶么？支持一下~&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;231 回复，无一 diss。感谢是说不完的，我能做的只有坚持创业，完善软件，对得起支持的朋友。 终生会员抽奖截止到今晚上8点，还有点时间，感兴趣的可以直接来这个链接：https://www.v2ex.com/t/992091  （打开这个链接需要一点点科技）&lt;/p&gt;
&lt;h4 id=&#34;2-在-小众软件-上发布产品介绍&#34;&gt;2. 在 &lt;a href=&#34;https://meta.appinn.net/t/topic/49268&#34;&gt;小众软件&lt;/a&gt; 上发布产品介绍&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491908.17001883894040.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3-给新趣集-投稿&#34;&gt;3. 给&lt;a href=&#34;https://xinquji.com/posts/806536&#34;&gt;新趣集&lt;/a&gt; 投稿&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491917.17001884899855.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;4-在-chinese-independent-developer-新增产品&#34;&gt;4. 在 &lt;a href=&#34;https://github.com/1c7/chinese-independent-developer&#34;&gt;chinese-independent-developer&lt;/a&gt; 新增产品&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491924.17001885718786.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;5-其他一些投稿目前还在审核&#34;&gt;5. 其他一些投稿目前还在审核：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;阮一峰周报&lt;/li&gt;
&lt;li&gt;创造者日报&lt;/li&gt;
&lt;li&gt;神器集&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6-朋友圈和微信公众号发布产品介绍&#34;&gt;6. 朋友圈和微信公众号发布产品介绍&lt;/h4&gt;
&lt;h3 id=&#34;回归开发&#34;&gt;回归开发&lt;/h3&gt;
&lt;p&gt;推广固然重要，一些用户反馈的希望有的新功能比如 实时网速、自定义背景、抢票定时器浮窗等 的开发需要沉下心来慢慢做，有时候慢就是快。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#17：说不完的感谢</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/dao-yu-zhi-meng-fa-xian-ling-dong-sheng-huo-island-widgets-dai-ni-mai-xiang-quan-xin-ti-yan/"" data-c="
          &lt;h1 id=&#34;岛屿之梦发现灵动生活island-widgets-带你迈向全新体验&#34;&gt;岛屿之梦，发现灵动生活——『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』带你迈向全新体验！&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584262.B429ED3D-3C6E-4F31-97CF-3C273CB04FB5_1_201_a.jpeg&#34; alt=&#34;封面&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在繁忙的现代生活中，我们时常渴望能够拥有一份轻松自在的生活方式。现在，『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』应用隆重登场，为你的iOS设备带来一场全新的使用体验，让你置身于一个灵动的岛屿世界中。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;无需打开任何其他应用，只需一瞥你的手机屏幕，你将发现一个全新的世界。让我们一起看看『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』带给你的七项魔力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，你的手机使用习惯一目了然。每天我们拿起手机的次数不计其数，但你是否真正了解自己的使用习惯呢？『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』的小组件会记录你拿起手机的次数，帮助你更好地认识自己，从而更好地管理时间。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584271.05A0574E-1735-4CA8-BA7C-A81CF1B393E9_4_5005_c.jpeg&#34; alt=&#34;手机拿起次数-展开&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686435.C6A16C61-953A-4B29-B628-306699459446_1_201_a.jpeg&#34; alt=&#34;手机拿起次数-倒计时&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其次，健康数据一览。在健康意识的日益增强下，对自身健康的关注变得越来越重要。『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』实时监测步数、跑步距离、心率、体温等健康数据，让你时刻关注自身健康状况，更好地调整自己的生活方式。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584278.ADDB7D80-8226-4913-A8A0-606B44728C3F_4_5005_c.jpeg&#34; alt=&#34;步数心率-展开&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686447.5513EB01-C995-4C5F-8251-1D8C4BA8DBDC_1_201_a.jpeg&#34; alt=&#34;步数心率-倒计时&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;放下繁忙的工作，享受休闲时光，这是多么让人向往的事情。『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』帮你实现这个愿望，通过设置下班时间，应用会精确倒计时，帮助你规划工作日，确保你能按时离开工作岗位，享受属于自己的休闲时光。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584284.4D752933-9CBE-4727-A3CF-75428A9C397F_4_5005_c.jpeg&#34; alt=&#34;下班倒计时-展开&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686456.E8AA8B3B-A112-4BDB-B0BD-1BBB203C4865_4_5005_c.jpeg&#34; alt=&#34;下班倒计时-倒计时&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而对于那些特殊的时刻，『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』也不会让你错过。你可以轻松跟踪并倒计时到各种重要时刻，如Deadline、纪念日等。无论是工作还是生活，你都能时刻掌握时间，不再错过任何重要时刻。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584290.CEED6C59-DE3B-4768-ADF0-E8130898A709_4_5005_c.jpeg&#34; alt=&#34;自定义倒计时-展开&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686464.1E4196D8-503D-421D-B014-09FBE6F7BA10_1_201_a.jpeg&#34; alt=&#34;自定义倒计时-灵动岛&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除此之外，『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』还为你提供准确的天气预报，帮助你合理安排活动计划。无论是出门旅行还是日常出行，你都能轻松了解当地的天气情况，做出最佳决策。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584301.6F078C50-42D0-4B3B-B8FD-62F705386905_4_5005_c.jpeg&#34; alt=&#34;天气预报-展开&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686472.66F9F6C9-CF5E-4029-A23F-1472A873D88E_1_201_a.jpeg&#34; alt=&#34;天气-灵动岛&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过热搜功能，『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』让你随时浏览社交媒体上的热门话题和趋势，保持与时事新闻和社交动态的紧密联系。无论你是时事追随者还是社交达人，『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』都能让你第一时间了解到最新的动态。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584315.3DE6C703-1505-49C8-BB29-1AA6871A0BC9_4_5005_c.jpeg&#34; alt=&#34;热搜-展开&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686480.12D8375A-697F-4FDA-ABFD-C38CBC62F906_1_201_a.jpeg&#34; alt=&#34;热搜-灵动岛&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最后，别忘了待办事项。『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』将你的待办事项放在随处可见的地方，让你时刻保持清晰的工作计划，不再遗漏重要任务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584325.28062FEB-C924-4128-9DDA-897F14D7E8A7_4_5005_c.jpeg&#34; alt=&#34;待办-展开&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686488.F697C6FD-FBDE-4B33-8A31-72D1860C8449_1_201_a.jpeg&#34; alt=&#34;待办-灵动岛&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们不仅为你提供以上丰富的功能，还在不断努力开发新功能，以进一步满足你的不同需求。即将推出的更新将为你带来更多强大的工具，让你的使用体验更加丰富多彩。&lt;/p&gt;
&lt;p&gt;岛屿之梦，就在你的指尖。立即下载『&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 』，让这个精彩应用为你的iOS设备注入全新活力！从此，发现灵动生活，体验不一样的惊喜！&lt;/p&gt;
">岛屿之梦，发现灵动生活——『Island Widgets 』带你迈向全新体验！</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-16bei-an-he-shi-yue-shou-zhi/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记16备案和十月收支&#34;&gt;程序员自由创业周记#16：备案和十月收支&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/8850709/pexels-photo-8850709.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;政策&#34;&gt;政策&lt;/h3&gt;
&lt;p&gt;众所周知，从今年9月26日开始，新App必须在工信部备案获得备案号才能在Apple Store上架，之前上架的App需要在24年3月31之前完成备案。消息一出，国内独立开发者纷纷嚷着要出海，各种抵制，我觉得这是大可不必的。即便不需要备案，做的软件也要出海，而不是因为需要备案才要出海；另外我觉得国家自有他的考虑，备案之后的App如果出问题定位到发布者的成本便会大大降低，试想，明年3月以后，应用商店里披着正常软件外壳的违法应用会变多还得变少呢。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;尝试&#34;&gt;尝试&lt;/h3&gt;
&lt;p&gt;创业以后已经做了两个小而美的软件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt; ：习惯养成打卡，追踪生活小事，记录日常情绪，计数、统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; ：灵动岛/锁屏小组件，囊括下班倒计时、手机拿起次数、步数、热搜等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;准备再做第三个： 小憩 - 电脑用久了提醒你休息下眼睛的Mac工具。&lt;/p&gt;
&lt;p&gt;因为是新App，因为之前看其他人的博客讲备案需要二十多天，那我得先去备案，拿到备案号才能上架。真正去尝试了发现并没有网上说的那么繁琐，甚至我只用了半个小时就完成了备案提交，而且再第二天就备案通过拿到了备案号。并没有网上传言的那么麻烦。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.10.16995817507586.beian-2023.11.08.png&#34; alt=&#34;beian-2023.11.08&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;之所以这么快主要原因是我之前备案过域名，在原本的备案主体新增App就好了。如果之前没有备案过域名，耗时肯定会长一些。另外，备案需要的材料比如：App Logo（用的之前做的学伟扫描的Logo），备案服务码（新买了一个ECS实例），域名（用的个人技术博客 https://qiuxuewei.com/ ）都是现成的。&lt;/p&gt;
&lt;h3 id=&#34;10月收支&#34;&gt;10月收支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支出：15035.76&lt;/li&gt;
&lt;li&gt;收入：0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创业4个月过去了，还是没有收入，一直这么下去肯定是不行的， &lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; ：灵动岛/锁屏小组件，囊括下班倒计时、手机拿起次数、步数、热搜等. 已经完善的差不多了，下周开始就要尝试下推广，找到潜在愿意为之付费的用户，我会在接下来的周记里记录我所尝试的推广手段和所获得反馈。值得一提的是在前天纯自然流量的基础上，有一位用户购买了&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 的终身会员，它所给我带来的开心和认同感比上班的时候发了工资还要强得多的多。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.10.16995817507606.423DD333-8CC1-4DDF-9855-DBD2ECFFC1BF_1_201_a.jpeg&#34; alt=&#34;423DD333-8CC1-4DDF-9855-DBD2ECFFC1BF_1_201_a&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#16：备案和十月收支</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-15wei-xin-bei-feng/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记15微信被封&#34;&gt;程序员自由创业周记#15：微信被封&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/7827745/pexels-photo-7827745.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;二维码不能乱发&#34;&gt;二维码不能乱发&lt;/h3&gt;
&lt;p&gt;周日收到微信官方的一条消息：&lt;br&gt;
“该账号因被投诉组织、参与或邀请他人加入发布色情/低俗营销/虚假欺诈等违规内容的群聊，对他人造成严重骚扰。当前无法使用添加朋友。2023-11-05 10:02后可申请解除限制。”&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;上周组建了一个学英语的微信群，把进群的二维码发了出来，起初是打算营造一个争先恐后学英语的氛围，初心是美好的，现实是残酷的，这个二维码导致了我建的群以及我的微信号都被封，部分功能限制使用一个月。原因是经常有人进群发几条广告就退，而且举报这个人也没用，会有不同的人进群发广告，这极大违背了我建群的初衷，因为被封的理由太莫名其妙，申诉后我的微信也恢复了正常功能，这也提醒下各位，无限制进群的二维码谨慎使用，最好是先加自己好友，甄别后再拉。否则会被别人利用。&lt;/p&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;p&gt;这周依旧在完善我的 Island Widgets (灵动岛&amp;amp;锁屏小组件) 这款产品，增加了健康类的组件，在灵动岛和锁屏页面现在当前的步数、心率等。这对于关注健康的用户是个福音，Island Widgets 灵动岛和锁屏上的小组件意味着你无需打开任何App（或者在任何App内）即可了解这些信息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.05.16991950546455.E8D04714-02F7-4CE2-873B-39F3C93C237A_1_101_o.jpeg&#34; alt=&#34;E8D04714-02F7-4CE2-873B-39F3C93C237A_1_101_o&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;新赛季&#34;&gt;新赛季&lt;/h3&gt;
&lt;p&gt;随着NBA新赛季烈火重燃，已经许久没打球的我这周不是在看家看NBA比赛就是在球场打球，说服自己的理由是创业不能时刻紧绷，要适当放松自己。周末一般球场人满为患，现在可以挑风和日丽的时候去，一般下午2点去球场，玩到4点半出出汗去接小朋友放学。上午如果有湖人比赛的话会看一看，第一件球衣就是詹姆斯的骑士23号，也就一直看他所在球队的比赛，他的自律也在一定程度上影响着我。&lt;/p&gt;
">程序员自由创业周记#15：微信被封</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-14chi-xu-xue-xi/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/301920/pexels-photo-301920.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;持续学习的职业&#34;&gt;持续学习的职业&lt;/h3&gt;
&lt;p&gt;众所周知，软件工程师是一类需要持续学习的职业，不单单是每年层出不穷的新技术需要掌握，过去落下的计算机基础知识也需要不断精进，否则，在这个竞争日益加剧的当下，很容易被后浪拍在沙滩上。过去移动互联网辉煌的10年逐渐趋于平凡，社交媒体上越来越多的程序员转行的消息不绝于耳，上周看到一名iOS程序员转行做水电工的消息，大为震撼。还记得15年移动互联网刚起步的时候，遍地都是各种移动开发培训机构，各行各业的有志之士希望通过4个月轻松月薪过万，这也导致了后面中低端工程师的极速饱和。如今移动端开发工程师就业的难度已经变得极为艰难，尤其是原生应用开发。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;所以需要持续不断的学习，丰富自己的技术栈，成为那1%的精英。才能在激烈的买方市场中脱颖而出。&lt;/p&gt;
&lt;p&gt;所以，即便我在创业做一些软件，也需要持续的学习，除了本行iOS相关技术以外，还计划学后端Java自己搭服务器，和前端自己写网站。另外，还有英语。&lt;/p&gt;
&lt;h3 id=&#34;每天打卡30分钟&#34;&gt;每天打卡30分钟&lt;/h3&gt;
&lt;p&gt;之前上班的时候曾经也持续学过一段时间，但是囿于工作较饱和，没有大声讲英语的场地和需要3小时路上通勤的缘故和自己找借口不学的种种原因并没有坚持下去。希望借这段自由的时光把英语口语和听力能力提上一个层次。把计划写在周记里也是希望有个外界的监督，Push自己，不要在家一有空就去球场打球🏀。我建一个英语学习的打卡群，如果有想一起学英语打卡的同学可以扫码进群或者加我微信（jikexuewei）邀请你。我们一起互相监督，共同进步，成为那个更好的自己。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/important/qrcode/english-group.JPG&#34; alt=&#34;英语学习打卡&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.27.16983702664473.16983680354581.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;本周软件进展&#34;&gt;本周软件进展&lt;/h3&gt;
&lt;h4 id=&#34;island-widgets&#34;&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; (灵动岛小组件)&lt;/h4&gt;
&lt;p&gt;v1.0.2 通过了审核，加了内购的选项，国外一款仅支持健康类灵动岛主题的软件售价是148每年，我的定价策略是，第一版的价格是它的10分之一，等后续版本完善后再涨到与之类似的价格。现在提供的功能是把喜欢的照片、手机拿起次数、天气、下班倒计时、自定义倒计时和热搜这几类灵动岛组件的功能，后续会增加健康类，把跑步或者骑行过程的步数或里程呈现在灵动岛上。有希望体验或者支持博主的朋友可以AppStore搜索：&lt;a href=&#34;https://apps.apple.com/cn/app/id6464542768&#34;&gt;Island Widgets&lt;/a&gt; 或者网页直接输入：https://apps.apple.com/cn/app/id6464542768&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.27.16983702664493.16983688238176.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;加一&#34;&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;为 习惯养成打卡，追踪生活小事，记录日常情绪，计数、统计 的产品 &lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt;，增加了拖动排序和点击跳转的功能还有一些体验优化。&lt;/p&gt;
&lt;h3 id=&#34;焦虑&#34;&gt;焦虑&lt;/h3&gt;
&lt;p&gt;过去这周是创业以来焦虑情绪最严重的一段时间，一个月二百多的收入对于一个三口之家来说是远远不够的，多次想放弃创业找个班上，又多次说服自己，不能既想又想，既想有着稳定的收入又想搏一把青春无悔，哪有这种好事呢😂&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#14：持续学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-13di-yi-tong-jin/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/6289064/pexels-photo-6289064.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;国庆假期&#34;&gt;国庆假期&lt;/h3&gt;
&lt;p&gt;对于我而言是没有放假的概念的，可以说每天都是假期，但是孩子放假就不能做软件了，得陪着他，尤其他生了半个月的病，隔三差五就得去医院排两小时队看个医生，周记因此耽搁了两次。没有看到我的更新不代表我放弃了，只是没有腾出空。没想到的是居然会有网友关注我怎么停更了，实在抱歉🫡&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345322.16971660346018.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;9月收支&#34;&gt;9月收支&lt;/h3&gt;
&lt;p&gt;支出：10933.35；收入：287.51&lt;/p&gt;
&lt;h3 id=&#34;第一桶金&#34;&gt;第一桶金&lt;/h3&gt;
&lt;p&gt;距离7月7日决定开始创业已经三个月了，前两个月一直没有收入，这周刚收到了第一笔打款，金额 287.51 ，算是第一桶金吧。因为加一是与另外两位大佬合作的作品，所以是加一2.0上线两个月以来总收入的1/4。终于算是迈出了第一步，未来可期。试想，一个软件每个月收入1000，我如果做10个是不是就能覆盖支出了呢。&lt;/p&gt;
&lt;h3 id=&#34;本周进展&#34;&gt;本周进展&lt;/h3&gt;
&lt;h4 id=&#34;island-widgets&#34;&gt;Island Widgets&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;开发了自定义图片上岛功能，这样就能把我小儿子的照片一直放在灵动岛上了。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345333.16971713519140.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;开发了手机拿起次数上岛功能，每次拿起手机在灵动岛上提示你这是今天第几次拿起手机，提醒我放下手机，回到生活。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345341.16971714093498.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;开发了会员功能，有收入这个梦才能做的更久一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345348.16971714588231.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;加一&#34;&gt;加一&lt;/h4&gt;
&lt;p&gt;开发了桌面小组件，不用打开App也能记录&lt;br&gt;
&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345357.16971719454545.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;同道中人&#34;&gt;同道中人&lt;/h3&gt;
&lt;p&gt;相信每个程序员心中都有一个做自己软件的梦想，不知道是不是受我启发，隔壁村发小也开始副业搞自己的小程序：文字控壁纸&lt;br&gt;
一款壁纸类小程序，除了官方推荐外也可以自定义壁纸。&lt;/p&gt;
&lt;p&gt;希望这段旅程能结实更多同道中人，创业路上才不会孤单。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#13：第一桶金</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-12999/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/9821386/pexels-photo-9821386.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;下载量涨了999&#34;&gt;下载量涨了999%&lt;/h3&gt;
&lt;p&gt;在此之前，我的Apple开发账号上只有一个产品-学伟扫描，因为没有推广，只靠自然流量，每天的下载量寥寥无几，这种稳定无人问津的状态断断续续保持了4年。&lt;br&gt;
之前的周记里介绍了最近在做创业的第二个项目-学伟灵动大全，耗时半个月，解决了无数技术问题，因为之前没有学过 SwiftUI，连写一个图片控件也要问 ChatGPT，也因为之前没做过灵动岛相关的项目，看了大量的资料，也请教了在新浪负责微博小组件开发的好朋友小谢，他也倾囊相助帮我解决了好些技术难题，对于用SwiftUI开发一个灵动岛项目，我的起点可以说是低到尘埃里，这里也想借此鼓励下我的读者，我这么菜的都能把软件做出来，相信每个人都可以。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;本着软件开发不能闷着头做，需要边做边接受用户反馈改进产品的原则，上周上线了灵动岛项目的1.0 MVP版本，之所以称之为MVP，就是它目前的功能仅限于能用，功能也是最基本的灵动岛下班倒计时、纪念日倒计时、微博、抖音、百度热搜， 计划这个项目做半年，功能完善到我满意为止。&lt;/p&gt;
&lt;p&gt;昨天看了下Apple Connect 统计后台，自然下载量居然涨了999%。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.22.16953469623339.IMG_1020.jpeg&#34; alt=&#34;IMG_1020&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;名字&#34;&gt;名字&lt;/h3&gt;
&lt;p&gt;之前周记里朋友建议我改个名，觉得 “学伟灵动大全” 这个名不太好听，我悉心听取了建议，起了个洋气的名字：Island Widgets。中文翻译过来是：岛屿小工具 的意思，他确实是个在岛屿上的一系列小工具。这样也省去了名字的国际化，国内版本和海外版本都叫这个名字，见名知意。Logo 和 UI 是我美丽的媳妇帮我设计的，主打一个简约、漂亮。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.22.16953469623353.IMG_1024.jpeg&#34; alt=&#34;IMG_1024&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;天气预报&#34;&gt;天气预报&lt;/h3&gt;
&lt;p&gt;既然是小工具合集，一个实时的天气预报必不可少，这是我第二次做天气预报相关主题的软件，第一个还是大学刚毕业的时候做的 OneSky ，那时候还是iPhone 5 的时代。做天气预报一是提供灵动岛实时天气的功能，二是开启后台定位的权限。如果没有需要定位的功能，Apple的审核员不会允许软件随随便便开启后台定位，这也是iOS系统体验相对比Android好一点点的其中一个原因。只要App被允许用户在后台能存活，Island Widgets 就可以实时更新灵动岛，比如每半个小时在用户灵动岛上更新下热搜的内容，比如每次解锁在灵动岛上告诉下用户这是第几次拿起手机，比如每隔5分钟在灵动岛上告诉下用户跑步跑了多长距离等等。&lt;/p&gt;
&lt;h3 id=&#34;欢迎体验&#34;&gt;欢迎体验&lt;/h3&gt;
&lt;p&gt;只要是iPhone用户，就可以体验，虽说 Island Widgets 主要是为灵动岛设计的，但是没有灵动岛的iPhone设备，可以在锁屏界面和通知界面看到，目前还没加付费功能，全免无广告。&lt;br&gt;
AppStore 搜索：Island Widgets   或者浏览器输入：https://apps.apple.com/cn/app/id6464542768 。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.22.16953470221571.Group%252080.png&#34; alt=&#34;Group 80&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#12：999%</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-11shang-biao/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1553835973-dec43bfddbeb?ixlib=rb-4.0.3&amp;amp;ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGJyYW5kfGVufDB8MHwwfHx8MA%3D%3D&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=800&amp;amp;q=60&#34; alt=&#34;cover&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;商标重要吗&#34;&gt;商标重要吗&lt;/h3&gt;
&lt;p&gt;为什么我那么重视App名字里要有一个自己的商标，主要防止的是被竞争对手抄袭，甚至连名字也起同样的，如果没有商标，很难维权，只能放任自由。在上上家公司，我们的产品起了一个与别人重复的名字，刚好那个名字别的公司有商标，又恰巧他们知道了我们的产品用了他们的名字，被投诉到Apple，我们的产品直接被下架和封号。后来我们给Apple发邮件也无济于事，这也直接导致了公司收入严重受挫，以致于整个iOS团队耗时小半年上架了它的马甲包应用，此后也是一蹶不振，后来结果就是App停服，最后直接导致了公司倒闭，团队解散。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;这也是为什么我执意把我做的一系列软件起名：学伟xx 的原因，我注册了“学伟”的9、38、42类软件产品相关类目的商标，如果万一哪天我的产品被人抄袭叫了同样的名字，也可以维权。但是这个名字作为人名还可以，作为软件的名字就很奇怪了。给人一种城乡结合部的感觉，尤其这个名字还没人听说的时候。对于软件的推广可能会起到副作用，所以在一番纠结以后，还是决定给软件改名，起一个人畜无害的名字，首先这个名字别人不会注册商标，不至于无意碰瓷到别人。&lt;/p&gt;
&lt;p&gt;毕竟现在最重要的不是防竞争对手，而是增长和营收。&lt;/p&gt;
&lt;h3 id=&#34;微扫描&#34;&gt;微扫描&lt;/h3&gt;
&lt;p&gt;好的商标难注册，19年做的那个OCR软件最先的名字叫微扫描，后来注册“微扫描”的商标被驳回。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.15.16947290512794.16947027926134.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;退而求其次，干脆改名叫微扫吧，继续注册 “微扫” 的商标，又被驳回。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.15.16947290512811.16947028372601.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;名字注册不了，自己设计的logo注册下总行了吧，还是被驳回。。。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.15.16947290512822.16947028941120.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;几乎我能想到的好名字，基本已经被别人注册过了。而且我只有13个月做梦的时间，重新注册一个好听的商标显然也已经来不及了。所以在之前的周记中有很多人给我做了善意的提醒，大多数人的认知和经验都是比我强，别人的提醒肯定不无道理。&lt;/p&gt;
&lt;h3 id=&#34;改个名吧&#34;&gt;改个名吧&lt;/h3&gt;
&lt;p&gt;在“学伟” 跟“奔驰”、 “松下”、“丰田”、“希尔顿”、“腾讯”、“小鹏”、“王致和” 那些名字一样深入人心以前，我就先不用这个商标做创业期间做的一系列软件的名字了。&lt;br&gt;
商标很重要，一个好听的商标更重要。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#11：商标</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-10xiao-zhong-ruan-jian/"" data-c="
          &lt;h3 id=&#34;8月收支&#34;&gt;8月收支&lt;/h3&gt;
&lt;h4 id=&#34;支出1158532&#34;&gt;支出：115853.2&lt;/h4&gt;
&lt;h4 id=&#34;收入0&#34;&gt;收入：0&lt;/h4&gt;
&lt;p&gt;8月给研究生媳妇交了第一年学费，是真的学费。不得不说，MBA学费真贵，尤其是北师大的MBA。不过媳妇喜欢学习，作为爱人必须无条件支持。而且是在家全职看孩子挤时间考上的，非常难能可贵。记得在刚毕业那会我也在继续读研和工作纠结过一段时间，读研学历提升好找工作；工作能更快接受企业历练；再做了一番思想斗争和学了一个月发现不是那块料后果断选择了工作。服务的公司的规模也从七八个人，到二三十人，后来一两百人，最后到四万多人，四家风格迥异的互联网公司，做的事一直没变，iOS开发。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在公司上班就是这样，只需要做好自己的份内之事即可，也就是除了iOS其他的不需要我去关心，这也导致了我技术栈的单一。这也是职业规划不够明确的后果，如果当时就认定以后创业，就该除了iOS一外把Web和后端的技术学会，不至于现在没有收入的时候再重新开始学。虽然大学学的是计算机，但是那时候我并没有那个觉悟，学习也仅是在临近考试的时候抱抱佛脚。&lt;/p&gt;
&lt;p&gt;如果能重来，大学我除了教室、图书馆和篮球场肯定哪也不去。诚然，人生不会重来。&lt;/p&gt;
&lt;h3 id=&#34;小众软件&#34;&gt;小众软件&lt;/h3&gt;
&lt;p&gt;新项目切入的点极小众，现在搜索应用市场做类似主题的几乎没有，我愿称之为新蓝海，只不过比较小众。为什么其他公司不做，是因为傻吗？还是因为用户太少不值得投入；我想是因为后者，在此之前，只有iPhone14 Pro 和 iPhone14 Pro Max的用户有灵动岛，专门为灵动岛开发应用软件不值当的，但是下周二发布的iPhone15将抛弃之前的刘海屏，全系列采用灵动岛设计。以后可以使用灵动岛的用户必然会越来越多，在更多竞争对手进场之前布局我猜能有一点机会吧，即便没成，也解决了我自身的需求，就是只要在使用手机，都能看到我的宝贝儿子，都能知道几点下班。&lt;/p&gt;
&lt;h3 id=&#34;学伟灵动大全&#34;&gt;学伟灵动大全&lt;/h3&gt;
&lt;h4 id=&#34;在桌面&#34;&gt;在桌面&lt;/h4&gt;
&lt;p&gt;提示我现在是休息时间&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782556.437B46CB-5AD3-4C57-A4BA-6110CAF09E6F_4_5005_c.jpeg&#34; alt=&#34;437B46CB-5AD3-4C57-A4BA-6110CAF09E6F_4_5005_c&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;在刷抖音&#34;&gt;在刷抖音&lt;/h4&gt;
&lt;p&gt;小盆友默默地看着爸爸&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782578.island-dy-sy.jpg&#34; alt=&#34;island-dy-sy&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;在用微信&#34;&gt;在用微信&lt;/h4&gt;
&lt;p&gt;小盆友也在默默地看着爸爸&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782597.island-gzh-sy.jpg&#34; alt=&#34;island-gzh-sy&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;在锁屏&#34;&gt;在锁屏&lt;/h4&gt;
&lt;p&gt;还有多久下班甚至都不用算&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782614.IMG_0950.jpg&#34; alt=&#34;IMG_0950&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;计划下周上线&#34;&gt;计划下周上线&lt;/h3&gt;
&lt;p&gt;把想做的东西用技术实现出来，即方便自己，也有可能为别人带来一点用，并乐在其中还挺难得的。&lt;br&gt;
用我的座右铭之一-巴菲特的一段话用作第10篇周记的结尾：&lt;br&gt;
“你财富自由之后想做什么工作，现在就该做什么工作，这样的工作才是理想的工作。做这样的工作，你会很开心，能学到东西，能充满激情。每天会从床上跳起来，一天不工作都不行。”&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#10：小众软件</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-9zui-kai-xin-de-shi/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/1536428/pexels-photo-1536428.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;最开心的事&#34;&gt;最开心的事&lt;/h3&gt;
&lt;p&gt;人一天中最开心的时刻是什么时候？莫过于下班的时候；一天中最开心的事是什么？莫过于下班后干的任何事；&lt;br&gt;
这么重要的时刻，能不能有一款产品只要手机在手就能知道还有多久下班，不论是手机在锁屏界面，还是在桌面，还是在聊微信，亦或是在刷抖音。&lt;br&gt;
只要你在用手机，就能知道还有多久下班。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;最爱的人&#34;&gt;最爱的人&lt;/h3&gt;
&lt;p&gt;你最爱的人是谁？是偶尔吵架的爱人？是一年能见一两次的父母？是天天想粘着你的孩子？还是每年一有演唱会就必去的那个明星；&lt;br&gt;
能不能有一款产品，只要在用手机，不用打开相册，就能看到你所爱的人照片，不论你是在用手机上的任何软件。&lt;/p&gt;
&lt;h3 id=&#34;学伟xx大全&#34;&gt;学伟xx大全&lt;/h3&gt;
&lt;p&gt;既然没有，那我就开发一个：把你最关心的放在手机时刻能看到的地方。&lt;br&gt;
你最关心的可以有很多选择，可以是某一个时刻、某张照片、某句话、今天的天气、或者现在正在发生的事儿。&lt;br&gt;
所以这是一个集合了：下班计时、纪念日、番茄钟、天气预报、微博热搜、TODO List等各种功能于一身的软件。&lt;br&gt;
因为可以有很多选择，所以产品的名字就叫：学伟xx大全。&lt;br&gt;
因为是你最关心的，所以只要你在用手机，就能看到。&lt;/p&gt;
&lt;h3 id=&#34;骑行&#34;&gt;骑行&lt;/h3&gt;
&lt;p&gt;这周三回了趟前公司，把停在车棚俩月的自行车从北五环骑了回来，30多公里，一个来小时。这辆自行车也朝夕相处陪伴了我一年多，每天陪着我上下班，现在他也已经完成他的使命了，该给他找一个新主人了。&lt;br&gt;
现在回想，之前4年每天骑行40公里这段时间挺难能可贵的，骑行的时候戴着耳机听着书、播客或者音频课。既锻炼了身体又涨了见识。把这种百利而无一害的通勤方式推荐给所有人，只要单程20公里以内，完全可以选择骑自行车上下班。不过自行车肯定不能是共享单车，推荐公路车，我骑了两年山地，两年公路。各有千秋，挑自己喜欢的。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;往期文章&#34;&gt;往期文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#9：最开心的事</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-8zen-me-she-ji/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/1037992/pexels-photo-1037992.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;
&lt;h3 id=&#34;软件的样子&#34;&gt;软件的样子&lt;/h3&gt;
&lt;p&gt;就像建造房子，工人施工需要照着图纸，没有图纸直接上手施工倒是也可以，只是房子的质量和样子都不敢恭维。程序员在一定意义上与建筑工人很像，只不过他们码砖，我们码码。软件开发之前也需要提前设计好界面，设计好交互。有了设计稿程序员也能更专注的实现功能，但是很少有程序员懂设计。那创业做软件设计怎么办？以我现有的认知介绍几种方式。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;1-ai作图&#34;&gt;1. AI作图&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.24.16928879183132.16928847361644.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;即把想实现的界面描述给AI，它能自动为你生成设计稿，不要苛求生成的设计稿有多惊艳，我试过，现阶段仅仅停留在能用，聊胜于无。&lt;/p&gt;
&lt;h4 id=&#34;2-与专业设计师合作&#34;&gt;2. 与专业设计师合作&lt;/h4&gt;
&lt;p&gt;合作的方式有两种：1是前期用爱发电，收益按比例分成。 2是直接以外包的形式给人固定收益；这取决于双方的性格和互相了解的程度，可以在论坛上发帖找设计师。我的第二个作品加一便是以第一种形式合作的，只不过是设计师找的我。设计稿和交互都做好了，”只差一个程序员“。&lt;/p&gt;
&lt;h4 id=&#34;3-雇佣一名远程设计师&#34;&gt;3. 雇佣一名远程设计师&lt;/h4&gt;
&lt;p&gt;在诸如一些设计外包外包平台上发布一个职位，可以短期雇佣一名专业设计师，给人发月薪，可半天工作或全天工作，设计师的工资以其经验的长短有所不同，月薪5k+ 最短可雇佣1个月，这更像是正式的创业，有前期资本的支持。&lt;/p&gt;
&lt;h4 id=&#34;4-淘宝找设计外包团队&#34;&gt;4. 淘宝找设计外包团队&lt;/h4&gt;
&lt;p&gt;众所周知，万物皆可淘。淘宝相对透明，服务好坏可以通过评价判断。&lt;/p&gt;
&lt;h4 id=&#34;5-自己学&#34;&gt;5. 自己学&lt;/h4&gt;
&lt;p&gt;小破站上找一套Figma或者Sketch教程，学完自己搞几个作品，自己动手丰衣足食。适合掌控欲强的程序员，做成啥样完全自己说了算，缺点就是慢。&lt;/p&gt;
&lt;h4 id=&#34;6-找一个设计师老婆女朋友&#34;&gt;6. 找一个设计师老婆(女朋友)&lt;/h4&gt;
&lt;p&gt;嘿嘿...&lt;/p&gt;
&lt;h3 id=&#34;新作品进展&#34;&gt;新作品进展&lt;/h3&gt;
&lt;p&gt;新作品有一个核心功能是天气预报，媳妇仅用了两天的时间，给我设计好了包括天气预报在内的5个页面，而且还有点好看。&lt;br&gt;
&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.24.16928879183143.16928868265767.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;仲裁进展&#34;&gt;仲裁进展&lt;/h3&gt;
&lt;p&gt;这周二打了人生第一次官司，一个人面对公司两个律师和仲裁员书记员，没怯场。公司的裁员理由主要有几点：1.没按时交周报（实际按时交了）。2.不接领导电话（实际把电话接通的消息删了）。3.门禁时间不满9个小时（实际公司不需要打卡）。 4. 领导消息不回。（实际半夜11点我已经睡了）。理由在我看来比较苍白，而且我也有充分的证据一一驳斥。结果1-3个月后出，顺其自然。不希望这件事再占我时间，后续的流程我也会委托给专业的律师，让专业的人做专业的事。&lt;/p&gt;
&lt;h3 id=&#34;周更和往期文章&#34;&gt;周更和往期文章&lt;/h3&gt;
&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;
&lt;p&gt;往期文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=653a502b51d5cd5fb9021eb1ce0c9179&amp;amp;chksm=fd9f624dcae8eb5bb19504f493a8c33b063a767626209a903ef3802f5a3a261946bbc4614b8e#rd&#34;&gt;程序员自由创业周记#5：加一上线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484272&amp;amp;idx=1&amp;amp;sn=45134c5275f280474641fa0340ccc3f0&amp;amp;chksm=fd9f6269cae8eb7f10164bac0a4bcdedad9cd24bcca723461223d4f3cf7e36e4b58b1deb991c#rd&#34;&gt;程序员自由创业周记#6：劝退&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484306&amp;amp;idx=1&amp;amp;sn=a5e528f34e838e983c1ae59df656ce15&amp;amp;chksm=fd9f628bcae8eb9d5b93bdb468891b6dd4e53473ecc154f91a579d3c9283153c4b0dcd467e73#rd&#34;&gt;程序员自由创业周记#7：仲裁&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">程序员自由创业周记#8：怎么设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-7zhong-cai/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://images.pexels.com/photos/6077326/pexels-photo-6077326.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2&#34; alt=&#34;law&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;
&lt;h3 id=&#34;没想到&#34;&gt;没想到&lt;/h3&gt;
&lt;p&gt;没想到写的周记会有这么多人看，还能收到这么多陌生(或熟悉)朋友的真诚建议、鼓励、甚至是打赏，几乎所有的评论和私信我都认真的回复了，本想的是通过网友和朋友的监督坚定我创业的信念，有点外界压力也能迫使自己持续输出一些对别人有点用的东西，是几个有一点用的软件产品、一段程序员不一样的经历、一些创业失败(2.5%概率成功)的经验、一些不成熟的想法、一些移动端开发的踩坑经历、一些解决问题的过程、一些软件推广的实践、或是以后再回想这段经历的流水账，还有就是有关一些劳动仲裁的经验。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550431.16923211593377.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;被裁&#34;&gt;被裁&lt;/h3&gt;
&lt;p&gt;在之前的 &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt; 提到我开始全职创业的其中一个原因是：“刚从BAT其中的一家被动离职”，所谓被动离职说人话就是被公司裁员了，而且是0赔偿被单方走的，这事也让我想通了，无论在公司多么努力，多么卖命，一旦公司决定裁员，所有的努力都会付之一炬。而且留给自己的对自己的职业发展帮助并没有那么大，比如对之前维护的那个项目的熟悉度，我之前在公司做的是一个之前内部用了10年的内部产品，成立一个单独的部门把这个优秀的产品交付给其他客户，我在部门成立仅有5个同学的时候加入，从0开始熟悉这个有将近40万行代码的庞大工程，忙到一天从早上10点坐在工位到9点下班连喝水的时间都没有，做到随便一个模块出问题能第一时间定位并解决，做到组里疑难问题都让我排查，做到经理年度评估能力突出，做到任务完成数比去年多168%，做到代码提交数比同级多1/3，做到代码行数排在全部门9/26，做到Bug数排在客户端6/17，也难逃被无情裁员的现实。经理通知我被裁的时候我问原因是什么：他给我的答案是我周末不主动加班，晚上11点找不到人。我问，我工作都做完了周末去干什么呢，可能我真的不适合职场吧，至少不适合这种充满了内卷氛围的职场。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550443.16922492799979.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550450.16922494183043.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550456.16922494127658.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550463.16922510674976.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;对上家的感情&#34;&gt;对上家的感情&lt;/h3&gt;
&lt;p&gt;虽说前公司把我裁了，我并不记恨它。反而特别感谢，是它给了我前大厂员工的虚名，给了我现在不上班能有饭吃的资本，给了我时间让我充分了解了劳动法，也给了我不请律师下周自己去仲裁的勇气。&lt;br&gt;
从去年11月份领导通知我在那次的裁员名单里到真正离开，中间持续了7个月，能持续这么久也是我没想到的，记得去年6月份部门第一次裁员的时候也就一个周，很多同学就从工作群里找不到了。外包同学甚至只需要一个下午的时间，通知你明天不用来了，就没再见了。而我，让我有如此多的时间了解劳动法，收集证据，考虑未来的道路，这7个月甚至让我把赔偿金的n从2变成了3。感情很复杂，感激多于埋怨吧。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550469.16922508683040.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;本周工作&#34;&gt;本周工作&lt;/h3&gt;
&lt;p&gt;本周除了准备仲裁证据外，开发了&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt;2.1.0版本，加了首页记录项左右无限滑动的交互优化，免得用户一个个手动点切换记录项体验不好，另外加了统一展示全部记录项的功能，在一个界面记录所有记录。&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt;是一款打卡计次的工具，记录任何想记录的事儿。欢迎体验：AppStore搜&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt;，或者浏览器输入：https://apps.apple.com/cn/app/id1477743089。&lt;br&gt;
另外把起床时间改成了5点，没办法，早上梦想太吵。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550475.IMG_0751-1.png&#34; alt=&#34;IMG_0751&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550481.plusone-2.1.0-list.png&#34; alt=&#34;plusone-2.1.0-list&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;目前方向&#34;&gt;目前方向&lt;/h3&gt;
&lt;p&gt;上周的第一个月的收支明细收到了一些关注，有大佬针对我存在的问题-产品选型，输出了一篇干货满满的文章，我拜读完也是收获很多，推荐给想自己做产品的朋友。&lt;a href=&#34;https://aoxiang.me/14/08/2023/choose-product/&#34;&gt;独立开发第一步——选择一个好的IDEA&lt;/a&gt; 。另外就是，学伟扫描是19年尝试独立开发产品的时候做的一款OCR、翻译和图片转PDF工具，到如今Apple自己下场在系统层面集成OCR的今天，这类App确实不值得再投入时间，不过我自己一直在用，处于偶尔维护状态。接下来做的产品除了日常维护&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt;以外，会针对灵动岛/小组件一个细分领域，上线一系列的小工具，做完这些再尝试其他方向，反正现在有大把的时间搞，失败了积累经验、抹抹眼泪再开下一个。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550487.x-4.5-blog.png&#34; alt=&#34;x-4.5-blog&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;周更和往期文章&#34;&gt;周更和往期文章&lt;/h3&gt;
&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;
&lt;p&gt;往期文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=653a502b51d5cd5fb9021eb1ce0c9179&amp;amp;chksm=fd9f624dcae8eb5bb19504f493a8c33b063a767626209a903ef3802f5a3a261946bbc4614b8e#rd&#34;&gt;程序员自由创业周记#5：加一上线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484272&amp;amp;idx=1&amp;amp;sn=45134c5275f280474641fa0340ccc3f0&amp;amp;chksm=fd9f6269cae8eb7f10164bac0a4bcdedad9cd24bcca723461223d4f3cf7e36e4b58b1deb991c#rd&#34;&gt;程序员自由创业周记#6：劝退&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">程序员自由创业周记#7：仲裁</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-6quan-tui/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917169577176.photo-1547496614-154dee7fd157.jpeg&#34; alt=&#34;photo-1547496614-154dee7fd157&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;
&lt;h3 id=&#34;劝退&#34;&gt;劝退&lt;/h3&gt;
&lt;p&gt;如果一位程序员问我要不要进行独立开发创业，我100%会建议他不要冲动，因为这条路太苦太累，成功率太低，论性价比而言，找个工作安心打工无疑更高，有稳定的收入，能安逸的成长，如果公司不加班就更好了，可以业余时间尝试做独立软件，等收入积累到一定程度，积蓄能坚持3-5年，或者独立软件收入逐渐稳定跟主业持平时可以再全职做。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;收支明细&#34;&gt;收支明细&lt;/h3&gt;
&lt;p&gt;距离决定全职独立开发创业已经过去一个月了，打开记账软件满满的焦虑再次袭来，积蓄还能撑多久，梦还能做多久，之前预想到前期很长一段时间内将没有任何收入，可真正经历只出不进的日子，还是会非常焦虑。支出：首先是固定支出房租：4500，房贷：3534，社保：1901；第一个月置办了台性能比较好的电脑和一台测试机：16609，外加一些必要的生活开销总共支出：28697.77。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917166442409.IMG_0718.png&#34; alt=&#34;IMG_0718&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;收入&#34;&gt;收入&lt;/h3&gt;
&lt;p&gt;目前两款独立软件产品：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id1468603429&#34;&gt;学伟扫描&lt;/a&gt; （ https://apps.apple.com/cn/app/id1468603429 ） 收入：-4.5，&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt; （ https://apps.apple.com/cn/app/id1477743089 ） 收入：0，&lt;/li&gt;
&lt;li&gt;共：-4.5元。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创业第一个月收入为-4.5元。为什么是负的，因为唯一的一笔销售额是我测试的时候自己买的会员，苹果扣了15%的税，加一因为8月刚上线，还没有收入。&lt;br&gt;
落差大吗，看了下去年个人所得税的收入，对比现在，不可谓不惨，落差不可谓不大。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917166442428.16916782933520.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;给自己加油&#34;&gt;给自己加油&lt;/h3&gt;
&lt;p&gt;路是自己选的，即便再苦再累再穷，我也不打算放弃，希望我能一直坚持下去，坚持到柳暗花明那一天。&lt;/p&gt;
&lt;h3 id=&#34;周更和往期文章&#34;&gt;周更和往期文章&lt;/h3&gt;
&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;
&lt;p&gt;往期文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=653a502b51d5cd5fb9021eb1ce0c9179&amp;amp;chksm=fd9f624dcae8eb5bb19504f493a8c33b063a767626209a903ef3802f5a3a261946bbc4614b8e#rd&#34;&gt;程序员自由创业周记#5：加一上线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
"> 程序员自由创业周记#6：劝退</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-5jia-yi-shang-xian/"" data-c="
          &lt;h1 id=&#34;程序员自由创业周记5加一上线&#34;&gt;程序员自由创业周记#5：加一上线&lt;/h1&gt;
&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;
&lt;h3 id=&#34;充实&#34;&gt;充实&lt;/h3&gt;
&lt;p&gt;如果说程序员独立创业的成功率只有5%，那如果家里有一位3岁多还没上幼儿园的小朋友要照顾，成功的概率至少还要降低一半，过去一个月，除了吃饭睡觉几乎都在开发软件和构思新产品，完成了13个全新的让人眼前一亮的界面，其中的统计、展示、发布逻辑也费了一番功夫，毕竟做的产品要服务可能得服务成千上万的用户，让用户在使用产品的时候有一个好的体验尤为重要。原本想的是离职以后去318玩一圈，回来再打半个月篮球，睡到自然醒，真正开始创业才发现，比上班还忙，甚至忙到连电影都舍不得看，有一股很强的内驱力迫使自己往前走。体现在以前自然醒的时间是9点10分，最近一段时间是早上5点55。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;产品发布&#34;&gt;产品发布&lt;/h3&gt;
&lt;p&gt;之前在 &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt; 中提到过这一个月一直在忙的这个项目，一个记录生活的小而美产品，&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt; 在昨天通过了审核，成功上线AppStore。这大概是我之前做过的软件中最漂亮的一个。欣赏几张她的美照：&lt;/p&gt;
&lt;h4 id=&#34;截图1&#34;&gt;截图1&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377928.6271691025600_.pic_hd.jpg&#34; alt=&#34;6271691025600_.pic_hd&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;截图2&#34;&gt;截图2&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377936.6261691025599_.pic_hd.jpg&#34; alt=&#34;6261691025599_.pic_hd&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;截图3&#34;&gt;截图3&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377942.6251691025598_.pic_hd.jpg&#34; alt=&#34;6251691025598_.pic_hd&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;截图4&#34;&gt;截图4&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377949.6241691025596_.pic_hd.jpg&#34; alt=&#34;6241691025596_.pic_hd&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;有什么用&#34;&gt;有什么用&lt;/h3&gt;
&lt;p&gt;做一个产品光漂亮还不够，得有用，对用户有价值才行。加一是一个极简打卡计数器，主要用来：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;习惯养成打卡。喝水、早睡、阅读、不喝奶茶等等新习惯，只要做到了，就可用加一来打卡一次。&lt;/li&gt;
&lt;li&gt;记录情绪状态。生气、emo、失眠、熬夜等等不常发生的状态，一年下来究竟会发生多少次呢？发生一次，便可记录一次。&lt;/li&gt;
&lt;li&gt;追踪生活小事。今年感冒几次了、看了几次日出日落，给家里打了几次电话……不起眼的小事，记起来就不会忘记。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生活不止眼前的苟且，需要也值得认真对待，&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt; （ https://apps.apple.com/cn/app/id1477743089 ） 可以记录你做的每一件值得记录的事。闲暇时拿起 &lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt; 摇晃下首页的瓶子，会有满满成就感的！&lt;/p&gt;
&lt;p&gt;iPhone用户 AppStore搜索：加一，或者浏览器输入： https://apps.apple.com/cn/app/id1477743089&lt;/p&gt;
&lt;h3 id=&#34;收入&#34;&gt;收入&lt;/h3&gt;
&lt;p&gt;下周的周记会公布创业第一个月花了多少钱，挣了多少钱 😄&lt;/p&gt;
&lt;h3 id=&#34;周更和往期文章&#34;&gt;周更和往期文章&lt;/h3&gt;
&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;
&lt;p&gt;往期文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">程序员自由创业周记#5：加一上线</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-4cong-yi-bi-30-mei-yuan-de-shou-ru-tan-qi/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917196663205.pexels-freestocksorg-127713.jpg&#34; alt=&#34;pexels-freestocksorg-127713&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;本文是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。在文末，您还可以找到之前的历史文章。&lt;/p&gt;
&lt;h3 id=&#34;惊喜之旅&#34;&gt;惊喜之旅&lt;/h3&gt;
&lt;p&gt;这次的惊喜源于 &lt;a href=&#34;https://apps.apple.com/cn/app/id1507727251&#34;&gt;学伟扫描Pro&lt;/a&gt; 在美国销售的第一笔订单，这标志着我的产品获得了漂亮国用户的认可，让我感到非常欣慰。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id1468603429&#34;&gt;学伟扫描&lt;/a&gt; 是我四年前尝试独立开发的第一款产品，最初命名为微扫描，但商标注册失败；后来改成了微扫，商标依然未能注册成功；最终，我决定将”学伟“注册为第9类软件商标，成功注册，于是有了这个朴实无华的名字。然而，无论名字如何，最重要的是产品本身。&lt;a href=&#34;https://apps.apple.com/cn/app/id1468603429&#34;&gt;学伟扫描&lt;/a&gt; 上线三年来，在没有任何推广的前提下，收获了2.2万次下载，获得32个评分，其中30个是五星评价，1个是四星评价，1个是三星评价；好评率高达93.75%。因此，她确实挺好用，能够吸引漂亮国用户也就不足为奇了。值得一提的是，Pro版本在美区售价为30美元，而普通版本则为3.99美元（包年订阅）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917196663216.iScannerPro-29.99.png&#34; alt=&#34;iScannerPro-29.99&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;学伟扫描&#34;&gt;&lt;a href=&#34;https://apps.apple.com/cn/app/id1468603429&#34;&gt;学伟扫描&lt;/a&gt; 的功能简介&lt;/h3&gt;
&lt;p&gt;简单来说，&lt;a href=&#34;https://apps.apple.com/cn/app/id1468603429&#34;&gt;学伟扫描&lt;/a&gt; 的功能就是将照片中的文字提取出来，这项技术被称为OCR。除此之外，它还扩展了其他功能，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当朋友发来一张充满文字的图片时，可以用它提取文字内容；&lt;/li&gt;
&lt;li&gt;上课时拍摄了很多课件，可以用它按科目进行整理，并删除相册中的重复照片；&lt;/li&gt;
&lt;li&gt;在刷微博时看到一张英文图片，不知道其意思，可以用它进行识别和翻译，从而了解其含义；&lt;/li&gt;
&lt;li&gt;将一张或多张图片转换成PDF格式导出，或通过打印机进行打印。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;突出优势&#34;&gt;突出优势&lt;/h3&gt;
&lt;p&gt;市面上类似的软件成百上千，甚至iPhone自带的拍照功能也具备OCR功能，那么&lt;a href=&#34;https://apps.apple.com/cn/app/id1468603429&#34;&gt;学伟扫描&lt;/a&gt; 有何优势呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它采用了市面上最准确的API，确保了最高的识别准确率；&lt;/li&gt;
&lt;li&gt;完全无广告，用户体验更加纯粹；&lt;/li&gt;
&lt;li&gt;仅需0.25秒即可启动，操作更加高效便捷；&lt;/li&gt;
&lt;li&gt;可以根据需要建立文件夹分类整理文件；&lt;/li&gt;
&lt;li&gt;数据安全，所有资料均在本地管理，保障用户隐私。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917196663224.16917196406595.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;种下的种子&#34;&gt;种下的种子&lt;/h3&gt;
&lt;p&gt;虽然 &lt;a href=&#34;https://apps.apple.com/cn/app/id1468603429&#34;&gt;学伟扫描&lt;/a&gt; 三年来的收入还不足以覆盖一年开发者账号的年费，但它确实是当初我准备追求全职独立开发道路时所种下的一颗种子。通过这一过程，我深刻体验到开发一款完全属于自己的软件带来的乐趣。相比之下，为他人打工无论有多轻松都让我感到痛苦，而做自己的产品无论再累也让我感到幸福。&lt;/p&gt;
&lt;h3 id=&#34;周更和往期文章&#34;&gt;周更和往期文章&lt;/h3&gt;
&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;
&lt;p&gt;往期文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">程序员自由创业周记#4：从一笔30美元的收入谈起</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-3no1zuo-pin/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198093162.pexels-czapp-17077346.jpg&#34; alt=&#34;pexels-czapp-árpád-17077346&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。&lt;/p&gt;
&lt;h3 id=&#34;作息&#34;&gt;作息&lt;/h3&gt;
&lt;p&gt;如果不是热爱，很难解释为什么能早上6点自然醒后坐在电脑前除了吃饭一直敲代码到23点这个现象，而且还乐此不疲。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;之前上班的时候生活就很规律，没想到失业后的生活比之前还要规律；记得还在上班的时候，每天7点半懒洋洋的起床，洗洗涮涮挤上8点的地铁，晃晃悠悠到公司吃免费的早餐，开启一天司空寻常的打工时间，完成“上级”们规定的工作任务，到了6点打会球，再肝到89点下班回家，回家可能看看电影，刷刷手机就半夜了，周而复始，那时候有工资，周末隔三差五的京郊旅个游。现在，旅游对现在的自己来说算是很奢侈了，毕竟这点前得花13个月。还不确定产品何时才会有收入。&lt;/p&gt;
&lt;h3 id=&#34;焦虑&#34;&gt;焦虑&lt;/h3&gt;
&lt;p&gt;焦虑一直伴随着我，努力工作的时候想着会不会做不好；前期部门同事被优化的时候焦虑会不会临到我；被通知优化的时候焦虑失业会不会找不到工作；创业后焦虑没收入家里开销不够；打球投篮不准的时候焦虑会不会拉队友后腿。。。 还好我调整能力比较强，内心比较强大，能一直专注做我以为有价值的事，这其中家人、朋友还有坚持了一年每天10分钟的正念一直给我提供源源不断的能量。&lt;br&gt;
相信每个人都会或多或少的有过焦虑的情绪，这太正常不过了，哪有那么一帆风顺、波澜不惊的生活呢，即便有我也不想过。&lt;/p&gt;
&lt;h3 id=&#34;第一个作品&#34;&gt;第一个作品&lt;/h3&gt;
&lt;p&gt;最近一个月都在紧锣密鼓的开发第一个作品，预期月底能提审AppStore，这个产品的设计和第一个版本都不是我，我负责的是2.0的改版，前期是没有收入的，以收益分成的形式合作；也就是说App 上线后产生收入在扣除成本后的收益的一部分是我的报酬，我把他完全看做自己的产品，也在跟独立开发圈两位前辈的合作中学习，也正是在这个App的开发中渐渐进入创业的状态。&lt;/p&gt;
&lt;h3 id=&#34;什么作品&#34;&gt;什么作品&lt;/h3&gt;
&lt;p&gt;她在AppStore的名字叫：&lt;a href=&#34;https://apps.apple.com/cn/app/id1477743089&#34;&gt;加一&lt;/a&gt;；一个打卡类型的应用，记录日常生活的点点滴滴，比如今年看了几次日出&lt;/p&gt;
&lt;h5 id=&#34;这是她现在的样子&#34;&gt;这是她现在的样子：&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198093177.16899270859771.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;这是她未来的样子&#34;&gt;这是她未来的样子：&lt;/h5&gt;
&lt;p&gt;先留个悬念吧，肯定很漂亮，也很实用...&lt;/p&gt;
&lt;h3 id=&#34;文具&#34;&gt;文具&lt;/h3&gt;
&lt;p&gt;之前提到为了开发上上周买了一台 24G 内存 的MacBookAir，昨天刚折价800外加送300多配件外加送货上门把它卖了，没办法，现在开发的强度太大了；我怕它一直发热出问题，耽误我造火箭。然后在闲鱼上淘了台 32G 内存的MacBookPro，期望我跟它能合作愉快&lt;/p&gt;
&lt;h3 id=&#34;周更往期文章&#34;&gt;周更&amp;amp;往期文章&lt;/h3&gt;
&lt;p&gt;周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待关注。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;d)&lt;/p&gt;
">程序员自由创业周记#3：No1.作品</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-2qian-qi-zhun-bei/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198932716.pexels-skylar-kang-6368836.jpg&#34; alt=&#34;pexels-skylar-kang-6368836&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。&lt;/p&gt;
&lt;h3 id=&#34;感恩&#34;&gt;感恩&lt;/h3&gt;
&lt;p&gt;上次公开了创业的决定后，得到了很多亲朋好友和陌生朋友的鼓励或支持，以不同的形式，感动之情溢于言表。这些都会记在心里，大恩不言谢~&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;创业方向&#34;&gt;创业方向&lt;/h3&gt;
&lt;p&gt;笔者是一名资质平平的iOS开发程序猿，创业项目也就是开发App卖，类型的话主要以工具类为主，优先会解决一些我的需求。平台以iOS平台和MacOS平台为主，如果移动端产品反响不错会考虑使用Flutter开发Android版本。后续即将开发的产品会在如下几个里选几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MacOS 定时提醒休息&lt;/li&gt;
&lt;li&gt;MacOS 截图、OCR&lt;/li&gt;
&lt;li&gt;MacOS 番茄钟&lt;/li&gt;
&lt;li&gt;MacOS &amp;amp; iOS 纪念日倒计时&lt;/li&gt;
&lt;li&gt;iOS 各种类型的小组件&lt;/li&gt;
&lt;li&gt;iOS 个人OKR目标管理&lt;/li&gt;
&lt;li&gt;iOS 每日金句&lt;/li&gt;
&lt;li&gt;iOS 灵动岛动画&lt;/li&gt;
&lt;li&gt;iOS 音频转文字&lt;/li&gt;
&lt;li&gt;iOS 闹钟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的任何一种类型在商店都能找到一堆产品，我这边差异性可能就是极简和用户体验，还有就是出海，不限于国内市场；&lt;br&gt;
我负责产品规划，代码开发，运营推广，爱人负责UI设计。每个阶段都会借助AI工具的帮助，最大限度发挥个人的力量。而且个人精力和积蓄有效，所以只给自己13个月的时间，如果赚不到钱就找活。也正是因为只有13个月，所以不可能每个产品都做，会集中精力打磨其中的几个，中间涉及到任何经验我均会在周报中公开，也便监督自己。&lt;/p&gt;
&lt;p&gt;还有最近两周在跟独立开发圈的两位前辈在共同开发一款打卡类型的软件，产品经理的设计令人过目难忘，另外一位的技术能力让人折服；相信在跟两位前辈的合作能让我更快进入创业的状态。&lt;/p&gt;
&lt;h3 id=&#34;差生文具多&#34;&gt;差生文具多&lt;/h3&gt;
&lt;h4 id=&#34;macbook&#34;&gt;MacBook&lt;/h4&gt;
&lt;p&gt;既然是开发iOS App，必然需要一台Mac电脑，原本的 「MacBook Air 8G内存 M1芯片 13寸 2019款」，本来是我一直在用，但随着爱人研究生开学，和即将为产品设计UI也需要一台单独的电脑，所以决定再采购一台MacBook开发用，台式电脑肯定不行，既然独立开发，就要享受走到哪在哪工作的状态。结合预算和性能 「MacBook Pro 16G内存 M1 Pro芯片 51G硬盘 16寸 2021款」 和 「MacBook Air 24G内存 M2芯片 1T硬盘 15寸 2023」进入了最终的决赛，两款都是1.35万左右，开发iOS App都完全足够，最终通过拍脑门决定买了后者。而且之前的Air 用着很顺畅，也没有GPU的强需求，觉得Air足够；&lt;br&gt;
然后买完就后悔了，等电脑到了以后，发现用Xcode 15 beta版本调试发热严重，屏幕下沿温度能达到43摄氏度，去Apple直营店检测也没问题，可能这是Xcode 测试版本的通病吧。如果再让我选一次，可能选择有风扇的Pro吧。&lt;/p&gt;
&lt;h4 id=&#34;iphone&#34;&gt;iPhone&lt;/h4&gt;
&lt;p&gt;因为用Xcode15发热严重，加上我的主力机升级了iOS17必须用Xcode15才能调试，迫使我从咸鱼上淘了一台换过屏+电池循环897次的iPhone12 作为测试机。&lt;/p&gt;
&lt;h4 id=&#34;gpt&#34;&gt;GPT&lt;/h4&gt;
&lt;p&gt;除了MacBook，升级了ChatGPT Plus，以便使用 GPT4 的模型帮我写代码；然后买了 GitHub Copilot 也是在Xcode写代码的时候一些简单的语法能提示的更多一些；这两个AI工具大概每天能帮我节省半小时的开发时间吧，预估。&lt;/p&gt;
&lt;h3 id=&#34;工位&#34;&gt;工位&lt;/h3&gt;
&lt;p&gt;还有就是整理了下在家的工位，白天去图书馆、公园、咖啡馆写代码，晚上在家自己的工位上写。虽说没人监督，但是动力确实比上班的时候足。每天叫醒自己的真正的是梦想。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198932731.A9D8AFAF-C730-4917-8ECB-F1511030A5AB_1_105_c.jpeg&#34; alt=&#34;A9D8AFAF-C730-4917-8ECB-F1511030A5AB_1_105_c&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;周更往期文章&#34;&gt;周更&amp;amp;往期文章&lt;/h3&gt;
&lt;p&gt;周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待关注。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/p&gt;
">程序员自由创业周记#2：前期准备</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-1zuo-yi-chang-meng-ba/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917199828281.pexels-sindre-fs-1106416.jpg&#34; alt=&#34;pexels-sindre-fs-1106416&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;自由&#34;&gt;“自由”&lt;/h3&gt;
&lt;p&gt;为了做这一场梦，前前后后准备了4年，从19年接触 独立开发/数字游民/自由职业者 以后，总觉得这才是我一直追求的生活方式，没有职场的阿谀奉承，没有人强制你某个时间点必须坐到某个座位上，再也没有无休止的会，当然，也没有人再固定每个月往你银行卡打钱。然后可以自由的选择工作场所，自由的选择工作时间，自由的选择开发什么产品，自由的选择是否工作，自由的呼吸，自由的活。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;为了这种自由的生活方式，在深思熟虑了两周以后，决定暂时先不找工作，进行一次全职创业，做一场13个月的梦~&lt;/p&gt;
&lt;h3 id=&#34;我是谁&#34;&gt;我是谁&lt;/h3&gt;
&lt;p&gt;先介绍下自己：全网ID：极客学伟，一名从事了8年iOS开发的程序员，刚从BAT其中的一家被动离职，上个月刚过完30岁生日，一位3岁男孩的父亲，土生土长的山东农村孩子，也正因为没有背景，有家庭和孩子要养，这场梦不能做太久，所以暂定13个月，倘若13个月后没有挣到足够基本生活的收入，再去找个班上。&lt;/p&gt;
&lt;h3 id=&#34;缘由&#34;&gt;缘由&lt;/h3&gt;
&lt;p&gt;为什么选择这个时间节点创业，主要是以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己的开发技术随算不上什么大佬，但基本能完成大部分的开发任务。&lt;/li&gt;
&lt;li&gt;当前AI蓬勃发展，开发产品辅助AI的协助，如虎添翼。&lt;/li&gt;
&lt;li&gt;积累了很多idea，需要一段时间集中把他们变成产品推向市场，再慢慢打磨。&lt;/li&gt;
&lt;li&gt;工作几年也攒了一些钱，够一年家庭基本开销。&lt;/li&gt;
&lt;li&gt;积累了一些独立开发的经验，也加了几个群，不孤单。&lt;/li&gt;
&lt;li&gt;爱人支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;
&lt;p&gt;从19年接触独立开发之后，我主要做了这些事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独立开发了一款OCR软件：&lt;a href=&#34;https://apps.apple.com/mo/app/id1530758072&#34;&gt;学伟扫描&lt;/a&gt; ，独立开发产品初体验。&lt;/li&gt;
&lt;li&gt;注册了一家公司。&lt;/li&gt;
&lt;li&gt;注册了 ”学伟“ 的商标，计划后续所有的产品都叫 学伟xx ，希望能做成一个有些许知名度的品牌​。​&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;致敬&#34;&gt;致敬&lt;/h3&gt;
&lt;p&gt;受 &lt;a href=&#34;https://v2ex.com/member/maduoduo&#34;&gt;maduoduo&lt;/a&gt;、&lt;a href=&#34;https://www.v2ex.com/member/vulgur&#34;&gt;vulgur&lt;/a&gt; 等前辈的影响，会公开创业期间的所思所想和收支情况，也算对自己的督促。&lt;/p&gt;
&lt;p&gt;预计这13个月的总收入不会比之前上班一个月挣得多，大概95%的概率会失败，但就是图这5%的概率，万一成了呢！&lt;/p&gt;
&lt;h3 id=&#34;周更&#34;&gt;周更&lt;/h3&gt;
&lt;p&gt;周记主要发布在个人博客：&lt;a href=&#34;https://qiuxuewei.com/&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待关注。&lt;/p&gt;
">程序员自由创业周记#1：做一场梦吧</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/she-ji-mo-shi-xing-wei-xing/"" data-c="
          &lt;h1 id=&#34;设计模式-行为型&#34;&gt;设计模式-行为型&lt;/h1&gt;
&lt;p&gt;行为型设计模式主要用于软件运行时复杂的流程控制。包含：模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式和解释器模式&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;模板方法模式&#34;&gt;模板方法模式&lt;/h2&gt;
&lt;p&gt;在软件设计时，很多时候系统的运行流程都是确定的，在整个流程中，可能只有部分环节的具体实现是有差别的，这时我们就可以使用模板方法模式，其具体定义为：定义一个操作流程中的算法骨架，将部分算法环节的实现延迟到子类中，使子类可以在不改变算法骨架的前提下对特定步骤进行定制。&lt;/p&gt;
&lt;p&gt;以职员的工作流程为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Management {
    func clockIn() {
        print(&amp;quot;上班&amp;quot;)
    }
    func working() {
        print(&amp;quot;工作&amp;quot;)
    }
    func clockOut() {
        print(&amp;quot;下班&amp;quot;)
    }
    func start() {
        clockIn()
        working()
        clockOut()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无论对于任何岗位的职员，这个流程都不变，对于不同的岗位不同的是具体的工作内容，例如添加一位工程师，以模板方法模式设计：&lt;/p&gt;
&lt;h3 id=&#34;重构后&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;...
class Engineer: Management {
    override func working() {
        print(&amp;quot;软件设计&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用模板方法模式设计后，代码的复用性更强，但是因为子类修改了父类的方法的实现，有悖里氏替换原则，因此在选择时需要根据具体场景进行分析。&lt;/p&gt;
&lt;h2 id=&#34;策略模式&#34;&gt;策略模式&lt;/h2&gt;
&lt;p&gt;策略模式核心原则是定义一系列算法，将每个算法独立封装，使用者可以灵活的进行选择替换。&lt;/p&gt;
&lt;p&gt;例如现实生活中到某地的出行方式有很多种，可以灵活选择：出租车、公交车、地铁、自行车等，需要根据路程远近和交通状况灵活的选择，这就是一种策略模式。&lt;/p&gt;
&lt;h3 id=&#34;重构后-2&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Transport {
    func toDestination()
}
class Taxi: Transport {
    func toDestination() {
        print(&amp;quot;出租车&amp;quot;)
    }
}
class Bus: Transport {
    func toDestination() {
        print(&amp;quot;公交车&amp;quot;)
    }
}
class Subway: Transport {
    func toDestination() {
        print(&amp;quot;地铁&amp;quot;)
    }
}
class Action {
    var destination: String
    var transport: Transport
    init(destination: String, transport: Transport) {
        self.destination = destination
        self.transport = transport
    }
    func go() {
        self.transport.toDestination()
    }
}
let action = Action(destination: &amp;quot;北京&amp;quot;, transport: Subway())
action.go()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过策略模式，不同的Action对象调用go方法很容易根据场景实现不同的行为。&lt;/p&gt;
&lt;h2 id=&#34;命令模式&#34;&gt;命令模式&lt;/h2&gt;
&lt;p&gt;命令模式的核心是将请求封装为对象，使得请求的发起与执行分开，发起方和执行方通过命令进行交互。&lt;br&gt;
以教务系统为例，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Teacher {
    var name: String
    var subject: String
    func log() {
        print(&amp;quot;\(name) + \(subject)&amp;quot;)
    }
}
class School {
    var teachers = [Teacher]()
    func addTeacher(name: String, subject: String) {
        teachers.append(Teacher(name: name, subject: subject))
    }
    func deleteTeacher(name: String) {
        teachers = teachers.filter {$0.name != name}
    }
    func show() {
        for teacher in teachers {
            teacher.log()
        }
    }
}
let school = School()
school.addTeacher(name: &amp;quot;学伟&amp;quot;, subject: &amp;quot;计算机&amp;quot;)
school.addTeacher(name: &amp;quot;张三&amp;quot;, subject: &amp;quot;体育&amp;quot;)
school.addTeacher(name: &amp;quot;李四&amp;quot;, subject: &amp;quot;数学&amp;quot;)
school.show()
school.deleteTeacher(name: &amp;quot;李四&amp;quot;)
school.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;School&lt;/code&gt; 提供了展示所有教师信息的方法，也提供了添加和删除教师的方法，通过这种方式对教师的操作难以维护，可以使用命令模式对其重构，将添加和删除教师、展示所有教师的逻辑都封装成一种命令。&lt;/p&gt;
&lt;h3 id=&#34;重构后-3&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Teacher {
    var name: String
    var subject: String
    func log() {
        print(&amp;quot;\(name) + \(subject)&amp;quot;)
    }
}
class SchoolCommand {
    enum ActionType {
        case add
        case delete
        case show
    }
    var type: ActionType
    var name: String?
    var subject: String?
    init(type: ActionType, name: String? = nil, subject: String? = nil) {
        self.type = type
        self.name = name
        self.subject = subject
    }
}
class School {
    var teachers = [Teacher]()
    func runCommand(command: SchoolCommand) {
        switch command.type {
        case .add:
            addTeacher(name: command.name!, subject: command.subject!)
        case .delete:
            deleteTeacher(name: command.name!)
        case .show:
            show()
        }
    }
    private func addTeacher(name: String, subject: String) {
        teachers.append(Teacher(name: name, subject: subject))
    }
    private func deleteTeacher(name: String) {
        teachers = teachers.filter {$0.name != name}
    }
    private func show() {
        for teacher in teachers {
            teacher.log()
        }
    }
}
let school = School()
school.runCommand(command: SchoolCommand(type: .add, name: &amp;quot;学伟&amp;quot;, subject: &amp;quot;计算机&amp;quot;))
school.runCommand(command: SchoolCommand(type: .add, name: &amp;quot;张三&amp;quot;, subject: &amp;quot;体育&amp;quot;))
school.runCommand(command: SchoolCommand(type: .add, name: &amp;quot;李四&amp;quot;, subject: &amp;quot;数学&amp;quot;))
school.runCommand(command: SchoolCommand(type: .show))
school.runCommand(command: SchoolCommand(type: .delete,name: &amp;quot;李四&amp;quot;))
school.runCommand(command: SchoolCommand(type: .show))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用命令模式重构后，对于 &lt;code&gt;School&lt;/code&gt; 的操作都通过 命令 &lt;code&gt;SchoolCommand&lt;/code&gt; 触发，代码扩展性更强，且命令可以作为对象直接被存储、传输、重复和撤销，在某些场景下会非常有用。&lt;/p&gt;
&lt;h2 id=&#34;职责链模式&#34;&gt;职责链模式&lt;/h2&gt;
&lt;p&gt;一个请求被发出，从低层向高层依次寻找可以处理此请求的对象，直到找到处理者才结束责任链。&lt;/p&gt;
&lt;h3 id=&#34;重构后-4&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Requet {
    enum Level {
        case low
        case middle
        case high
    }
    var level: Level
}
protocol Handler {
    var nextHandler: Handler? { get }
    func handlerRequest(request: Requet)
    func nextHanderDo(request: Requet)
}
extension Handler {
    func nextHanderDo(request: Requet) {
        if let nextHandler = nextHandler {
            nextHandler.handlerRequest(request: request)
        } else {
            print(&amp;quot;无法处理请求&amp;quot;)
        }
    }
}
class HighHandler: Handler {
    var nextHandler: Handler? = nil
    func handlerRequest(request: Requet) {
        if request.level == .high {
            print(&amp;quot;HighHandler 处理请求&amp;quot;)
        } else {
            nextHanderDo(request: request)
        }
    }
}
class MiddleHandler: Handler {
    var nextHandler: Handler? = HighHandler()
    func handlerRequest(request: Requet) {
        if request.level == .middle {
            print(&amp;quot;MiddleHandler 处理请求&amp;quot;)
        } else {
            nextHanderDo(request: request)
        }
    }
}
class LowHandler: Handler {
    var nextHandler: Handler? = MiddleHandler()
    func handlerRequest(request: Requet) {
        if request.level == .low {
            print(&amp;quot;LowHandler 处理请求&amp;quot;)
        } else {
            nextHanderDo(request: request)
        }
    }
}
class Chain: Handler {
    var nextHandler: Handler? = LowHandler()
    func handlerRequest(request: Requet) {
        nextHandler?.handlerRequest(request: request)
    }
}
var request = Requet(level: .low)
Chain().handlerRequest(request: request)
request = Requet(level: .middle)
Chain().handlerRequest(request: request)
request = Requet(level: .high)
Chain().handlerRequest(request: request)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;外界只需传入指定等级的请求，责任链内部即可根据等级选择相应的处理逻辑。&lt;/p&gt;
&lt;p&gt;责任链模式的核心是将请求发送到责任链上，链上的每一个处理者可以根据实际情况决定是否处理此请求，如果不能处理则将请求继续向上发送，直到被某个处理者处理或者没有处理者为止。这种结构可以灵活地向责任链中增加或删除处理者，对于不同种类的请求，发出方只需要将其发送到责任链上，不需要关心具体被哪一个处理者处理。降低了对象间的耦合性，并且使责任的分担更加清晰。&lt;/p&gt;
&lt;h2 id=&#34;状态模式&#34;&gt;状态模式&lt;/h2&gt;
&lt;p&gt;状态模式的核心是：当控制一个对象行为的状态转换过于复杂时，把状态处理的逻辑分离出到单独的状态类中。&lt;br&gt;
在软件设计中，对象在不同的情况下会表现出不同的行为，被称为有状态的对象。影响对象行为的属性被称为状态，影响对象行为的属性被称为状态。对有状态的对象进行编程时，使用状态设计模式可以使代码的内聚性更强。&lt;/p&gt;
&lt;h3 id=&#34;重构后-5&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class StateContent {
    var currentState: State
    init(_ currentState: State) {
        self.currentState = currentState
    }
    func changeState(curState: State) {
        self.currentState = curState
    }
}
protocol State {
    func info()
    func doAction(content: StateContent)
}
class Open: State {
    func info() {
        print(&amp;quot;开灯&amp;quot;)
    }
    func doAction(content: StateContent) {
        content.currentState = Open()
    }
}
class Close: State {
    func info() {
        print(&amp;quot;关灯&amp;quot;)
    }
    func doAction(content: StateContent) {
        content.currentState = Close()
    }
}
class LightButton {
    var stateContent: StateContent
    init(state: State) {
        self.stateContent = StateContent(state)
    }
    func change(state: State) {
        self.stateContent.changeState(curState: state)
    }
    func log() {
        stateContent.currentState.info()
    }
}
let light = LightButton(state: Close())
light.log()
light.change(state: Open())
light.log()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;StateContent&lt;/code&gt; 定义了状态的上下文，用来维护当前开关的状态。而 &lt;code&gt;Open&lt;/code&gt; 、&lt;code&gt;Close&lt;/code&gt; 则是对状态的封装。&lt;/p&gt;
&lt;h2 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h2&gt;
&lt;p&gt;观察者模式又被称为发布-订阅模式，在观察者模式中，一个对象发生变化会通知到所有依赖它的对象，依赖它的对象可以根据情况进行自身行为的更改。&lt;br&gt;
在iOS开发中，通知中心和键值监听系统的实现都使用了观察者模式。如下代码通过实现一个简易的通知中心演示观察者模式&lt;/p&gt;
&lt;h3 id=&#34;重构后-6&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;typealias XWNotificationCallback = (XWNotification) -&amp;gt; Void
struct XWNotification {
    var name: String
    var data: String
    var object: AnyObject?
    func info() {
        print(&amp;quot;name: \(name), data: \(data), object: \(String(describing: object))&amp;quot;)
    }
}
struct XWObsever {
    var object: AnyObject
    var callback: XWNotificationCallback
}
class XWNotificationCenter {
    static let shared = XWNotificationCenter()
    private var observers = Dictionary&amp;lt;String, Array&amp;lt;XWObsever&amp;gt;&amp;gt;()
    private init() {}
    func addObserver(name: String, object: AnyObject, callback: @escaping XWNotificationCallback) {
        let observer = XWObsever(object: object, callback: callback)
        if var curObserver = observers[name] {
            curObserver.append(observer)
        } else {
            observers[name] = [observer]
        }
    }
    func removeObserver(name: String) {
        observers.removeValue(forKey: name)
    }
    func postNotification(notification: XWNotification) {
        if let array = observers[notification.name] {
            var postNotification = notification
            for observer in array {
                postNotification.object = observer.object
                observer.callback(postNotification)
            }
        }
    }
}
let key = &amp;quot;KEY&amp;quot;
XWNotificationCenter.shared.addObserver(name: key, object: &amp;quot;监听者A&amp;quot; as AnyObject) { noti in
    noti.info()
}
//XWNotificationCenter.shared.removeObserver(name: key)
XWNotificationCenter.shared.postNotification(notification: XWNotification(name: key, data: &amp;quot;通知内容&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是一个简易通知中心的实现，当添加了监听之后，一旦通知被发出，回调方法就会立刻执行，对于相同名称的通知，可以添加多个观察者。&lt;/p&gt;
&lt;h2 id=&#34;中介者模式&#34;&gt;中介者模式&lt;/h2&gt;
&lt;p&gt;中介者模式的核心是将网状的对象交互结构改为星形结构，即所有的对象都与一个中介者进行交互。使用中介者模式可以使原本耦合性很强的对象间的耦合变得松散，提高系统的灵活性和扩展性。&lt;/p&gt;
&lt;p&gt;如下代码演示了网状的对象交互结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ServerA {
    func handleClientA() {
        print(&amp;quot;ServerA 处理 ClientA 的请求&amp;quot;)
    }
    func handleClientB() {
        print(&amp;quot;ServerA 处理 ClientB 的请求&amp;quot;)
    }
}
class ServerB {
    func handleClientA() {
        print(&amp;quot;ServerB 处理 ClientA 的请求&amp;quot;)
    }
    func handleClientB() {
        print(&amp;quot;ServerB 处理 ClientB 的请求&amp;quot;)
    }
}
class ClientA {
    func requestServerA() {
        ServerA().handleClientA()
    }
    func requestServerB() {
        ServerB().handleClientA()
    }
}
class ClientB {
    func requestServerA() {
        ServerA().handleClientB()
    }
    func requestServerB() {
        ServerB().handleClientB()
    }
}
let clientA = ClientA()
clientA.requestServerA()
clientA.requestServerB()
let clientB = ClientB()
clientB.requestServerA()
clientB.requestServerB()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上所述，两个客户端可以分别与服务端进行交互，有时客户端也可以点对点的与另外的客户端进行交互，这样会使系统的结构更加复杂，可以通过中介者模式统一客户端与服务端的交互逻辑&lt;/p&gt;
&lt;h3 id=&#34;重构后-7&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ServerA {
    func handleClientA() {
        print(&amp;quot;ServerA 处理 ClientA 的请求&amp;quot;)
    }
    func handleClientB() {
        print(&amp;quot;ServerA 处理 ClientB 的请求&amp;quot;)
    }
}
class ServerB {
    func handleClientA() {
        print(&amp;quot;ServerB 处理 ClientA 的请求&amp;quot;)
    }
    func handleClientB() {
        print(&amp;quot;ServerB 处理 ClientB 的请求&amp;quot;)
    }
}
class ClientA {}
class ClientB {}
class Mediator {
    static func handler(client: AnyObject, server: AnyObject) {
        if client is ClientA {
            if server is ServerA {
                ServerA().handleClientA()
            } else {
                ServerB().handleClientA()
            }
        } else {
            if server is ServerA {
                ServerA().handleClientB()
            } else {
                ServerB().handleClientB()
            }
        }
    }
}
let clientA = ClientA()
let clientB = ClientB()
let serverA = ServerA()
let serverB = ServerB()
Mediator.handler(client: clientA, server: serverA)
Mediator.handler(client: clientA, server: serverB)
Mediator.handler(client: clientB, server: serverA)
Mediator.handler(client: clientB, server: serverB)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重构后客户端相关类中无须知道服务端具体的实现细节，中介者统一封装了这些逻辑。&lt;/p&gt;
&lt;h2 id=&#34;迭代器模式&#34;&gt;迭代器模式&lt;/h2&gt;
&lt;p&gt;软件设计中，很多对象都是以聚合的方式组成的，或者其内部包含集合类型的数据，在访问对象时，通常需要通过遍历的方式获取到其中的各个元素。这样，如果对象内部组合的方式产生了变化就必须对源码进行修改。&lt;/p&gt;
&lt;p&gt;迭代器模式的核心是提供一个对象来访问聚合对象中的一系列数据，不暴露聚合对象内部的具体实现，这样即保证了类的安全性，也将内部的集合遍历逻辑与聚合对象本身进行了分离。&lt;/p&gt;
&lt;h3 id=&#34;重构后-8&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Iterator {
    associatedtype ObjectType
    var cursor: Int { get }
    func next() -&amp;gt; ObjectType?
    func reset()
}
class School: Iterator {
    private var teachers = [String]()
    typealias ObjectType = String
    var cursor: Int = 0
    func next() -&amp;gt; String? {
        if cursor &amp;lt; teachers.count {
            let teacher = teachers[cursor]
            cursor += 1
            return teacher
        } else {
            return nil
        }
    }
    
    func reset() {
        cursor = 0
    }
    
    func addTeacher(name: String) {
        teachers.append(name)
    }
}
let school = School()
school.addTeacher(name: &amp;quot;学伟&amp;quot;)
school.addTeacher(name: &amp;quot;小王&amp;quot;)
school.addTeacher(name: &amp;quot;乔布斯&amp;quot;)
while let teacher = school.next() {
    print(teacher)
}
print(&amp;quot;遍历完成&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;外界对 &lt;code&gt;School&lt;/code&gt; 内部的数组是不感知的，使用迭代器模式可以很好的对内部实现进行封闭，外部除了通过类中暴露的函数来操作 teachers 数组外，不能直接操作。&lt;br&gt;
在&lt;code&gt;Swift&lt;/code&gt;标准库中，可以直接使用官方迭代器协议 &lt;code&gt;IteratorProtocol&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;访问者模式&#34;&gt;访问者模式&lt;/h2&gt;
&lt;p&gt;当数据的类型固定，但对其访问的操作相对灵活时，可以采用访问者模式对软件系统进行设计。访问者模式的核心是将数据的处理方式从数据结构中分离出来，之后可以方便地对数据的处理方法进行扩展。&lt;br&gt;
举一个现实生活中应用访问者模式的例子：作为一种数据，不同的角色对其访问会有不同的行为表现，对于景区门票这一数据，作为游客需要购买，作为验票员需要验票，这种场景：&lt;/p&gt;
&lt;h3 id=&#34;重构后-9&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Ticket {
    var name: String
}
protocol Visitor {
    func visit(ticket: Ticket)
}
class Tourist: Visitor {
    func visit(ticket: Ticket) {
        print(&amp;quot;游客购买\(ticket.name)&amp;quot;)
    }
}
class Guard: Visitor {
    func visit(ticket: Ticket) {
        print(&amp;quot;检票员检查了\(ticket.name)&amp;quot;)
    }
}
let ticket = Ticket(name: &amp;quot;公园门票&amp;quot;)
let tourist = Tourist()
tourist.visit(ticket: ticket)
let guarder = Guard()
guarder.visit(ticket: ticket)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上，不同角色对门票的操作分别封装在了独立的类中，这使之后新增行为变得非常容易，例如财务人员对门票价格进行核对等。&lt;/p&gt;
&lt;h2 id=&#34;备忘录模式&#34;&gt;备忘录模式&lt;/h2&gt;
&lt;p&gt;备忘录模式的定义：在不破坏封装性的前提下，对一个对象的状态进行保存，在需要时，可以方便地恢复到原来保存的状态，备忘录模式又被称为快照模式。&lt;br&gt;
从功能上讲，备忘录模式与命令模式有许多相似之处，都是提供了一种恢复状态的机制；不同的是，命令模式是将操作封装成命令，命令可以回滚，备忘录模式则是存储对象某一时刻的状态，可以将状态进行重置。&lt;br&gt;
例如，很多应用都提供了用户自定义偏好设置的功能，偏好设置的保存与重置可以采用备忘录模式实现。&lt;/p&gt;
&lt;h3 id=&#34;重构后-10&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol MementoProtocol {
    func allKeys() -&amp;gt; [String]
    func valueForKey(key: String) -&amp;gt; Any
    func setValue(value: Any, key: String)
}
class Setting: MementoProtocol {
    var setting1 = false
    var setting2 = false
    func allKeys() -&amp;gt; [String] {
        return [&amp;quot;setting1&amp;quot;, &amp;quot;setting2&amp;quot;]
    }
    
    func valueForKey(key: String) -&amp;gt; Any {
        switch key {
        case &amp;quot;setting1&amp;quot;:
            return setting1
        case &amp;quot;setting2&amp;quot;:
            return setting2
        default:
            return &amp;quot;&amp;quot;
        }
    }
    
    func setValue(value: Any, key: String) {
        switch key {
        case &amp;quot;setting1&amp;quot;:
            setting1 = value as? Bool ?? false
        case &amp;quot;setting2&amp;quot;:
            setting2 = value as? Bool ?? false
        default:
            print(&amp;quot;key: \(key) 设置错误&amp;quot;)
        }
    }
    func show() {
        print(&amp;quot;setting1: \(setting1) ++ setting2: \(setting2)&amp;quot;)
    }
}
class MementoManager {
    var dictionary = [String: [String: Any]]()
    func saveState(obj: MementoProtocol, stateName: String) {
        var dict = [String: Any]()
        for key in obj.allKeys() {
            dict[key] = obj.valueForKey(key: key)
        }
        dictionary[stateName] = dict
    }
    func resetState(obj: MementoProtocol, stateName: String) {
        if let dict = dictionary[stateName] {
            for kv in dict {
                obj.setValue(value: kv.value, key: kv.key)
            }
        }
    }
}
var setting = Setting()
let manager = MementoManager()
setting.setting1 = true
setting.setting2 = true
manager.saveState(obj: setting, stateName: &amp;quot;vip&amp;quot;)
setting.setting2 = false
manager.saveState(obj: setting, stateName: &amp;quot;super&amp;quot;)
setting.show()
manager.resetState(obj: setting, stateName: &amp;quot;vip&amp;quot;)
setting.show()
manager.resetState(obj: setting, stateName: &amp;quot;super&amp;quot;)
setting.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MementoManager&lt;/code&gt; 是一个快照管理类，可以将任何符合 &lt;code&gt;MementoProtocol&lt;/code&gt; 协议的对象进行快照保存。一个对象可以保存多个快照，在需要时可以方便地恢复到某个快照。有存档机制的软件可以按照备忘录设计模式的思路实现。&lt;/p&gt;
&lt;h2 id=&#34;解释器模式&#34;&gt;解释器模式&lt;/h2&gt;
&lt;p&gt;定义一种简洁的语言，通过实现一个解释器来对语言进行解析，从而实现逻辑。&lt;br&gt;
正则表达式和iOS开发中用于自动布局的 VFL（Visual Format Language）是对解释器模式的应用。&lt;/p&gt;
&lt;p&gt;例如，在软件中的页面路由跳转可以采用解释器模式进行设计。&lt;/p&gt;
&lt;h3 id=&#34;重构后-11&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Interpreter {
    static func handler(string: String) {
        let proto = string.components(separatedBy: &amp;quot;://&amp;quot;)
        if let pro = proto.first {
            print(&amp;quot;路由协议: \(pro)&amp;quot;)
            if proto.count &amp;gt; 1, let last = proto.last {
                let path = last.split(separator: &amp;quot;?&amp;quot;, maxSplits: 2, omittingEmptySubsequences: true)
                if let pathFirst = path.first {
                    print(&amp;quot;路由路径: \(pathFirst)&amp;quot;)
                    if path.count &amp;gt; 1, let param = path.last {
                        print(&amp;quot;路由参数: \(param)&amp;quot;)
                    }
                }
            }
        }
    }
}
Interpreter.handler(string: &amp;quot;http://www.xxx.com?key=value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此类用于解析某逻辑的设计模式即解释器模式的应用。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模板方法模式：定义算法骨架的前提下允许对关键环节的算法实现做修改&lt;/li&gt;
&lt;li&gt;策略模式：定义一系列方便切换的算法实现&lt;/li&gt;
&lt;li&gt;命令模式：将操作封装为命令对象&lt;/li&gt;
&lt;li&gt;责任链模式：通过责任链对请求进行处理，隐藏处理请求的对象细节&lt;/li&gt;
&lt;li&gt;状态模式：将变化的属性封装为状态对象进行统一管理&lt;/li&gt;
&lt;li&gt;观察者模式：通过监听的方式处理对象间的交互逻辑&lt;/li&gt;
&lt;li&gt;中介者模式：通过定义中介者来将网状结构的逻辑改为星状结构&lt;/li&gt;
&lt;li&gt;迭代器模式：提供一种访问对象内部集合数据的接口&lt;/li&gt;
&lt;li&gt;访问者模式：将数据的操作与数据本身分离&lt;/li&gt;
&lt;li&gt;备忘录模式：通过快照的方式存储对象的状态&lt;/li&gt;
&lt;li&gt;解释器模式：通过编写解释器对自定义的简单语言进行解析，从而实现逻辑&lt;/li&gt;
&lt;/ul&gt;
">设计模式-行为型</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/she-ji-mo-shi-jie-gou-xing/"" data-c="
          &lt;h1 id=&#34;设计模式-结构型&#34;&gt;设计模式-结构型&lt;/h1&gt;
&lt;p&gt;结构型设计模式包含：代理模式、适配器模式、桥接模式、装饰模式、外观设计模式、享元模式、组合模式&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;代理模式&#34;&gt;代理模式&lt;/h2&gt;
&lt;p&gt;核心是在具体的功能类与使用者之间建立一个中介类作为代理，使用者通过代理对象对真实的功能类进行访问。&lt;br&gt;
在iOS开发中，代理设计模式非常有用，在UIKit框架中，&lt;code&gt;UITableView&lt;/code&gt; 和 &lt;code&gt;UITextView&lt;/code&gt; 等组件的渲染和交互都采用了代理设计模式。&lt;/p&gt;
&lt;p&gt;以病人预约看病的软件设计举例，核心功能类只有两个医生类和病人类，病人看病前首先预约，预约完成后问诊，医生陈述病情，然后开药。整个系统中有些行为既不属于病人类也不属于医生类，如医生的预约和问诊过程的控制等，这时就需要一个代理类代理医生处理这些行为。&lt;/p&gt;
&lt;h3 id=&#34;重构后&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Patient {
    func describeCondition() -&amp;gt; String {
        let describe = &amp;quot;描述病情&amp;quot;
        print(describe)
        return describe
    }
}
class Doctor {
    func writPrescription(condition: String) -&amp;gt; String {
        let prescription = &amp;quot;依据病情: \(condition), 开的处方&amp;quot;
        print(prescription)
        return prescription
    }
}
class DoctorProxy {
    var patient: Patient
    init(patient: Patient) {
        self.patient = patient
    }
    func seeDoctor() {
        // 预约医生
        let doctor = reservation()
        // 病人描述病情
        let condition = self.patient.describeCondition()
        // 医生开处方
        doctor.writPrescription(condition: condition)
    }
    func reservation() -&amp;gt; Doctor {
        let doctor = Doctor()
        print(&amp;quot;预约医生&amp;quot;)
        return doctor
    }
}
let patient = Patient()
let doctorProxy = DoctorProxy(patient: patient)
doctorProxy.seeDoctor()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，病人并没有和医生进行直接交互，而是通过中间的代理类 &lt;code&gt;DoctorProxy&lt;/code&gt;。实际开发中，使用代理设计模式可以使具体的功能类的聚合性更强，并可以在某些功能的执行前后进行额外的准备工作和善后工作。&lt;/p&gt;
&lt;h2 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h2&gt;
&lt;p&gt;适配器模式并不是软件设计中的最佳实践，其主要为了解决软件开发过程中新旧模块不兼容的问题。其定义：将一个类的接口转换成使用者期望的另外接口，使得原本接口不兼容的类可以一起工作。&lt;/p&gt;
&lt;p&gt;当数据模型版本升级时，可以使用适配器模式兼容旧的数据模型&lt;/p&gt;
&lt;h3 id=&#34;重构后-2&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class User {
    var name: String
    var age: Int
}
class UserV2 {
    var nickName: String
    var age: Int
    var address: String
}
class UserAdapter {
    static func toUserV2(user: User) -&amp;gt; UserV2 {
        return UserV2(nickName: user.name, age: user.age, address: &amp;quot;&amp;quot;)
    }
}
let user = User(name: &amp;quot;学伟&amp;quot;, age: 18)
let userV2 = UserAdapter.toUserV2(user: user)
print(userV2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际开发中，由于数据模型升级造成的代码不兼容问题会经常遇到，当项目过于庞大时，如果贸然修改以往的旧代码，会有很大的工作量，同时也会伴随很大的风险，使用适配器模式就是一种比较适合的折中选择。&lt;/p&gt;
&lt;h2 id=&#34;桥接模式&#34;&gt;桥接模式&lt;/h2&gt;
&lt;p&gt;桥接模式是合成复用原则的一种应用，其核心是将抽象与实现分离，用组合来代替继承关系，从而给类更多的扩展性，降低类之间的耦合度。&lt;br&gt;
实际开发中，当某个类具有多维度的属性时，在组织类的结构时，使用桥接模式十分适合。&lt;br&gt;
例如：汽车从功能上分为轿车和卡车，颜色上又分为黑色白色。在设计时有两种设计方案：一种是创建轿车和卡车的类，每个类包含颜色属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Color {
    case red
    case green
}
class Car {
    var color: Color
}
class Saloon: Car {
    print(&amp;quot;我是轿车&amp;quot;)
}
class Truck: Car {
    print(&amp;quot;我是卡车&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一种设计方案可以根据桥接模式，根据实际需要对功能和颜色进行组合。&lt;/p&gt;
&lt;h3 id=&#34;重构后-3&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Color {
    case red
    case green
}
enum CarType {
    case saloon
    case truck
    var name: String {
        switch self {
        case .saloon:
            return &amp;quot;轿车&amp;quot;
        case .truck:
            return &amp;quot;卡车&amp;quot;
        }
    }
}
protocol CarProtocol {
    var color: Color { get }
    var carType: CarType { get }
    func log()
}
extension CarProtocol {
    func log() {
        print(&amp;quot;我是&amp;quot; + carType.name)
    }
}
class Car: CarProtocol {
    var color: Color
    var carType: CarType
    init(color: Color, carType: CarType) {
        self.color = color
        self.carType = carType
    }
}
let car = Car(color: .red, carType: .saloon)
car.log()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过组合颜色和类型两个枚举来构建汽车对象，避免了因继承带来的耦合问题。&lt;/p&gt;
&lt;h2 id=&#34;装饰模式&#34;&gt;装饰模式&lt;/h2&gt;
&lt;p&gt;在不改变对象结构的情况下，为该对象增加一些功能。&lt;br&gt;
类比现实生活中的：手机壳、壁画...&lt;/p&gt;
&lt;p&gt;以为墙添加贴纸的逻辑设计为例：&lt;/p&gt;
&lt;h3 id=&#34;重构后-4&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol WallProtocol {
    func printInfo()
}
class Wall: WallProtocol {
    func printInfo() {
        print(&amp;quot;墙面&amp;quot;)
    }
}
class StickerDecorator: WallProtocol {
    var wall: Wall
    init(wall: Wall) {
        self.wall = wall
    }
    func printInfo() {
        print(&amp;quot;贴纸装饰&amp;quot;)
        self.wall.printInfo()
    }
}
let wall = Wall()
let stickerDecorator = StickerDecorator(wall: wall)
stickerDecorator.printInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;StickerDecorator&lt;/code&gt; 即装饰器，也需要完整的实现功能类所实现的接口，这样才能不会改变被装饰对象的原始行为。&lt;br&gt;
使用装饰模式可以理解成：为对象的行为进行扩展，只是相比较于继承，装饰模式更加灵活、类之间的耦合度也更低。同时，装饰模式可能由于过度设计而增加过多装饰器类，使系统复杂性变高。&lt;/p&gt;
&lt;h2 id=&#34;外观设计模式&#34;&gt;外观设计模式&lt;/h2&gt;
&lt;p&gt;在软件设计中，当一个系统的功能越来越强时，子模块会越来越多，应用端对系统的访问也会越来越复杂。这时可以通过提供一个外观类来统一处理这些交互，降低应用端使用的复杂性。&lt;br&gt;
以客户购买商品流程的设计为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User {
    var name: String
}
struct Goods {
    static func choseGoods(user: User) {
        print(&amp;quot;\(user.name)选择商品&amp;quot;)
    }
}
struct Cashier {
    static func pay(user: User) {
        print(&amp;quot;\(user.name)付款&amp;quot;)
    }
}
struct Package {
    static func packing(user: User) {
        print(&amp;quot;\(user.name)打包&amp;quot;)
    }
}
let user = User(name: &amp;quot;学伟&amp;quot;)
Goods.choseGoods(user: user)
Cashier.pay(user: user)
Package.packing(user: user)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;User&lt;/code&gt;需要完成一个购物流程需要同时与 &lt;code&gt;Goods&lt;/code&gt; 、&lt;code&gt;Cashier&lt;/code&gt;、&lt;code&gt;Package&lt;/code&gt; 三个类进行交互。当每个模块都变得越来越复杂时，代码的扩展和维护将变得十分困难。&lt;br&gt;
对于这样的场景，可以定义一个外观类来统一处理用户的购物逻辑。&lt;/p&gt;
&lt;h3 id=&#34;重构后-5&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;...
struct Store {
    static func shop(user: User) {
        Goods.choseGoods(user: user)
        Cashier.pay(user: user)
        Package.packing(user: user)
    }
}
let user = User(name: &amp;quot;学伟&amp;quot;)
Store.shop(user: user)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;Store&lt;/code&gt; 起到外观的作用，顾客只需要与 &lt;code&gt;Store&lt;/code&gt; 一个类进行交互即可，&lt;/p&gt;
&lt;h2 id=&#34;享元模式&#34;&gt;享元模式&lt;/h2&gt;
&lt;p&gt;运用共享技术实现大量细粒度对象的复用，避免大量重复对象造成系统的资源开销。&lt;br&gt;
在享元模式中，需要根据共享性将对象中的数据拆分成内部状态和外部状态，之后将内部状态封装成享元对象用户共享。享元模式会增加系统的复杂度，对于不会产生大量重复对象的系统并不适用。&lt;/p&gt;
&lt;p&gt;以黑白棋设计为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Place {
    var x: Int
    var y: Int
}
enum Color {
    case White
    case Black
}
class ChessPiece {
    var place: Place
    var color: Color
    var radius: Double
    init(place: Place, color: Color, radius: Double) {
        self.place = place
        self.color = color
        self.radius = radius
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个棋子除了位置不同外，颜色和半径对于大部分棋子来说是相同的，这种场景下，place 就是 外部状态，color与radius为内部状态，可以使用享元模式重构&lt;/p&gt;
&lt;h3 id=&#34;重构后-6&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Place {
    var x: Int
    var y: Int
}
enum Color {
    case White
    case Black
}
class ChessPieceFlyweight {
    var color: Color
    var radius: Double
    init(color: Color, radius: Double) {
        self.color = color
        self.radius = radius
    }
}
class ChessPieceFlyweightFactory {
    static let white = ChessPieceFlyweight(color: .White, radius: 16.0)
    static let black = ChessPieceFlyweight(color: .Black, radius: 16.0)
    static func getChessPieceFlyweight(color: Color) -&amp;gt; ChessPieceFlyweight {
        switch color {
        case .White:
            return white
        case .Black:
            return black
        }
    }
}
class ChessPiece {
    var place: Place
    var chessPieceFlyweight: ChessPieceFlyweight
    init(place: Place, color: Color) {
        self.place = place
        self.chessPieceFlyweight = ChessPieceFlyweightFactory.getChessPieceFlyweight(color: color)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即便创建若干个棋子，真实的 ChessPieceFlyweight 只有两个，随着创建的个数越多，节省的内存也越多。&lt;/p&gt;
&lt;h2 id=&#34;组合模式&#34;&gt;组合模式&lt;/h2&gt;
&lt;p&gt;采用树状层级结构来表示部分与整体的关系，使得无论是整体对象还是单个对象，对其访问都具有一致性。&lt;br&gt;
在面向对象设计思想中，完整的文件系统至少需要两个类来描述，文件夹和文件；文件系统实际就是树状层级结构，可以使用组合模式设计。&lt;/p&gt;
&lt;h3 id=&#34;重构后-7&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum NodeType {
    case Folder
    case File
}
protocol FileNode {
    var type: NodeType { get }
    var name: String { get }
    func addNode(node: FileNode)
    func removeNode(node: FileNode)
    func getAllNode() -&amp;gt; [FileNode]
}
class file: FileNode {
    var type: NodeType
    var name: String
    var child = [FileNode]()
    init(type: NodeType, name: String) {
        self.type = type
        self.name = name
    }
    func addNode(node: FileNode) {
        self.child.append(node)
    }
    
    func removeNode(node: FileNode) {
        self.child = self.child.filter({ n in
            if node.name == n.name &amp;amp;&amp;amp; node.type == n.type {
                return false
            }
            return true
        })
    }
    
    func getAllNode() -&amp;gt; [FileNode] {
        return self.child
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过定义统一的 &lt;code&gt;FileNode&lt;/code&gt; 接口，使得使用方无论关心当前操作的节点是文件夹还是文件，都有统一的访问方式，而且屏蔽了树结构中层级的概念，这是组合模式最大的优势。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代理模式：使用中介处理对象间的交互&lt;/li&gt;
&lt;li&gt;适配器模式：新旧接口不兼容时的安全处理方案&lt;/li&gt;
&lt;li&gt;桥接模式：使用组合代替继承，将抽象与实现分离&lt;/li&gt;
&lt;li&gt;装饰模式：不改变原始行为的前提下对类的功能进行扩展&lt;/li&gt;
&lt;li&gt;外观模式：使用统一的外观接口处理类之间一对多的交互逻辑&lt;/li&gt;
&lt;li&gt;享元模式：创建大量重复对象的优化方案&lt;/li&gt;
&lt;li&gt;组合模式：部分与整体提供统一的功能接口&lt;/li&gt;
&lt;/ul&gt;
">设计模式-结构型</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/she-ji-mo-shi-chuang-jian-xing/"" data-c="
          &lt;h1 id=&#34;设计模式-创建型&#34;&gt;设计模式-创建型&lt;/h1&gt;
&lt;p&gt;创建型设计模式包含：单例模式、原型模式、工厂方法模式、抽象工厂模式、建造者模式&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;
&lt;p&gt;单例模式在开发中也是最常见的一种设计模式之一，系统原生提供的很多类的设计都采用了单例模式，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;FileManager.default
UserDefaults.standard
NotificationCenter.default
UIApplication.shared
URLSession.shared
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其目的是为了节省内存资源并保证数据内容的一致性，需要让某些类只能创建一个实例。单例模式有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单例类只有一个实例对象&lt;/li&gt;
&lt;li&gt;单例类的实例对象由自己创建&lt;/li&gt;
&lt;li&gt;需要对外提供一个访问其实例对象的接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在软件设计中，有关全局共享的资源数据，大型通用的管理类等都可以使用单例模式，例如登录用户的用户信息类、全局的计时器、程序的日志管理类&lt;/p&gt;
&lt;h3 id=&#34;swift-单例&#34;&gt;Swift 单例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ClassA {
    static let share = ClassA()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;objective-c-单例&#34;&gt;Objective-C 单例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static XXClassManager *_defaultManager;
+ (instancetype)shareInstance {
    if (!_defaultManager) {
        _defaultManager = [[self alloc] init];
    }
    return _defaultManager;
}
+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    if (!_defaultManager) {
        static dispatch_once_t onceToken;
        dispatch_once(&amp;amp;onceToken, ^{
            _defaultManager = [super allocWithZone:zone];
        });
    }
    return _defaultManager;
}
- (id)copyWithZone:(NSZone *)zone{
    return _defaultManager;
}
- (id)mutableCopyWithZone:(NSZone *)zone{
    return _defaultManager;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原型模式&#34;&gt;原型模式&lt;/h2&gt;
&lt;p&gt;以一个已经创建的实例作为原型，通过复制该原型对象来创建出对象，在使用对象时，使用者无需关心对象创建的细节。在iOS开发中：&lt;code&gt;copy&lt;/code&gt; 方法就是对原型设计模式的一种实现。主要是提供了一种大量创建复杂对象的方法。&lt;/p&gt;
&lt;h3 id=&#34;重构前&#34;&gt;重构前&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation
class Computer {
    var cpu: String
    var host: String
    var screen: String
    var uuid: String
    init(cpu: String, host: String, screen: String) {
        self.cpu = cpu
        self.host = host
        self.screen = screen
        self.uuid = UUID().uuidString
    }
    func logUUID() {
        print(uuid)
    }
}
let computer1 = Computer(cpu: &amp;quot;Intel core i7 7700K&amp;quot;, host: &amp;quot;GY088-GDF-60&amp;quot;, screen: &amp;quot;3008 x 1692&amp;quot;)
computer1.logUUID()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时若希望创建一台相同配置的电脑则只能使用重复的创建方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;let computer2 = Computer(cpu: &amp;quot;Intel core i7 7700K&amp;quot;, host: &amp;quot;GY088-GDF-60&amp;quot;, screen: &amp;quot;3008 x 1692&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重构后&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation
class Computer {
    ...
    
    func copy() -&amp;gt; Computer {
        return Computer(cpu: self.cpu, host: self.host, screen: self.screen)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增一个 copy() 方法，此时再创建相同配置的电脑只需调用原型的 copy() 方法即可，省去了配件的创建过程。&lt;br&gt;
使用原型模式，一旦第一个对象被创建，后面的对象创建都将变得非常容易。其中，作为模板对象被称为原型，创建出来的对象拥有和模板对象一致的属性和方法。&lt;/p&gt;
&lt;h2 id=&#34;工厂方法模式&#34;&gt;工厂方法模式&lt;/h2&gt;
&lt;p&gt;工厂方法设计模式注重于将对象的创建过程封闭起来，通过定义抽象的工厂接口和商品接口来隐藏负责对象创建的具体类&lt;/p&gt;
&lt;p&gt;对上述 Computer 类进行重构&lt;/p&gt;
&lt;h3 id=&#34;重构后-2&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Level {
    case low
    case high
}
protocol ComputerFactoryProtol {
    static func getComputer(level: Level) -&amp;gt; ComputerProtol
}
protocol ComputerProtol {
    var cpu: String { get }
    var host: String { get }
    var screen: String { get }
    var uuid: String { get }
    func logUUID()
}
class Computer: ComputerProtol {
    var cpu: String
    var host: String
    var screen: String
    var uuid: String
    init(cpu: String, host: String, screen: String) {
        self.cpu = cpu
        self.host = host
        self.screen = screen
        self.uuid = UUID().uuidString
    }
    func logUUID() {
        print(uuid)
    }
}
class ComputerFactory: ComputerFactoryProtol {
    static func getComputer(level: Level) -&amp;gt; ComputerProtol {
        switch level {
        case .low:
            return Computer(cpu: &amp;quot;Intel core i5 3300K&amp;quot;, host: &amp;quot;GY088-GDF-10&amp;quot;, screen: &amp;quot;1920 x 1080&amp;quot;)
        case .high:
            return Computer(cpu: &amp;quot;Intel core i7 7700K&amp;quot;, host: &amp;quot;GY088-GDF-60&amp;quot;, screen: &amp;quot;3008 x 1692&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引入的 ComputerFactory 即工厂设计模式的具体体现，外界不再指明具体的配置信息，只需要根据 level 即可创建指定配置的 Computer，&lt;br&gt;
创建高配电脑，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let computer3 = ComputerFactory.getComputer(level: .high)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果新增加了一种创建方式完全不同的计算机，我们只需要新建一个遵守 &lt;code&gt;ComputerProtol&lt;/code&gt; 的计算机类，之后在 &lt;code&gt;ComputerFactory&lt;/code&gt; 中统一处理这种新增的计算机类型即可，对使用者完全隐藏。&lt;/p&gt;
&lt;h2 id=&#34;抽象工厂模式&#34;&gt;抽象工厂模式&lt;/h2&gt;
&lt;p&gt;抽象工厂是对工厂模式的一种升级，核心思路是为各种类型的对象提供一组统一的创建接口，使用者无需关心这些对象具体是如何创建的。&lt;/p&gt;
&lt;p&gt;还是上述代码，若我们工厂方法即生产 &lt;code&gt;Computer&lt;/code&gt; 又可以生产 &lt;code&gt;TV&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;重构后-3&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Level {
    case low
    case high
}
protocol ComputerFactoryProtol {
    static func getComputer(level: Level) -&amp;gt; ComputerProtol
    static func getTV() -&amp;gt; TVProtol
}
protocol TVProtol {
    var name: String { get }
    func logName()
}
class TV: TVProtol {
    var name: String
    init(name: String) {
        self.name = name
    }
    func logName() {
        print(self.name)
    }
}
protocol ComputerProtol {
    ...
}
class Computer: ComputerProtol {
    ...    
}
class ComputerFactory: ComputerFactoryProtol {
    static func getTV() -&amp;gt; TVProtol {
        return TV(name: &amp;quot;海尔&amp;quot;)
    }
    static func getComputer(level: Level) -&amp;gt; ComputerProtol {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重构后工厂类可以创建不同的对象，对于使用者无需关心创建的细节，抽象工厂将对象的创建和使用进行了完全分离。&lt;/p&gt;
&lt;h2 id=&#34;建造者模式&#34;&gt;建造者模式&lt;/h2&gt;
&lt;p&gt;建造者模式用于复杂对象的创建，使代码聚合性更强，逻辑更加清晰。建造者模式通常与工程模式配合使用，工厂着重于对象的创建，建造者着重于创建复杂对象过程中组成对象的每一部分创建和最终组装。&lt;br&gt;
核心在于将复杂的对象拆解成多个简单对象，通过一步步构建简单对象最终组合成复杂对象。&lt;/p&gt;
&lt;h3 id=&#34;重构后-4&#34;&gt;重构后&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Foodtype {
    case a
    case b
}
enum Drink {
    case cola
    case juice
}
enum Staple {
    case hamburger
    case chickenRoll
}
class FoodPackage {
    var drink: Drink?
    var staple: Staple?
}
class BuildA {
    var foodPackage = FoodPackage()
    func build() -&amp;gt; FoodPackage {
        foodPackage.drink = .cola
        foodPackage.staple = .hamburger
        return foodPackage
    }
}
class BuildB {
    var foodPackage = FoodPackage()
    func build() -&amp;gt; FoodPackage {
        foodPackage.drink = .juice
        foodPackage.staple = .chickenRoll
        return foodPackage
    }
}
class FoodFactory {
    static func buildFood(type: Foodtype) -&amp;gt; FoodPackage {
        switch type {
        case .a:
            return BuildA().build()
        case .b:
            return BuildB().build()
        }
    }
}
let foodPackage = FoodFactory.buildFood(type: .a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，一个完整的套餐对象由饮料对象、主食对象组成，&lt;code&gt;FoodFactory&lt;/code&gt; 为工厂方法，其中根据套餐类型创建不同的套餐对象，具体的套餐对象的组成则是由 &lt;code&gt;BuildA&lt;/code&gt; 和 &lt;code&gt;BuildB&lt;/code&gt; 来完成。  &lt;code&gt;BuildA&lt;/code&gt; 和 &lt;code&gt;BuildB&lt;/code&gt; 是建造者模式的核心类，充当建造者的角色。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单例模式：全局共享数据的最佳实践&lt;/li&gt;
&lt;li&gt;原型模式：快速复制对象的便捷途径&lt;/li&gt;
&lt;li&gt;工厂方法模式：将对象的创建与使用进行隔离&lt;/li&gt;
&lt;li&gt;抽象工厂模式：提供一组接口创建不同类别的产品的实现方法&lt;/li&gt;
&lt;li&gt;建造者模式：拆分复杂对象为多个简单对象进行创建&lt;/li&gt;
&lt;/ul&gt;
">设计模式-创建型</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/she-ji-mo-shi-ruan-jian-she-ji-de-7-ge-yuan-ze/"" data-c="
          &lt;h1 id=&#34;设计模式-软件设计的7个原则&#34;&gt;设计模式-软件设计的7个原则&lt;/h1&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;在软件开发时为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，通常要遵守一定的设计原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开闭原则&lt;/li&gt;
&lt;li&gt;里式替换原则&lt;/li&gt;
&lt;li&gt;依赖倒置原则&lt;/li&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;/li&gt;
&lt;li&gt;迪米特原则&lt;/li&gt;
&lt;li&gt;合成复用原则&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-开闭原则&#34;&gt;1. 开闭原则&lt;/h3&gt;
&lt;p&gt;软件实体应当对扩展开放，对修改关闭。&lt;br&gt;
开闭原则是软件设计的终极目标，对扩展开放可以使软件具有一定的灵活性，同时对修改关闭又可以保证软件的稳定性。使用开闭原则设计的软件有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试方便。由于开闭原则对修改关闭，因此软件实体是拥有稳定性的，测试时只需要对扩展代码进行测试即可；&lt;/li&gt;
&lt;li&gt;更好地提高代码复用性。开闭原则通常采用抽象接口的方式来组织代码结构，抽象的编程本身就是对代码的复用性提高有很大的帮助；&lt;/li&gt;
&lt;li&gt;提高软件的维护性和扩展性。由于开闭原则对扩展开放，因此当软件需要升级时，可以很容易地通过扩展来实现新功能，开发效率更高，代码也更易于维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在面向对象开发中，实现开闭原则可以通过继承父类和实现接口两种方式。&lt;br&gt;
在开闭原则中，一个类只应该因为错误而修改，新加入的功能都不应该修改原始代码。&lt;/p&gt;
&lt;h4 id=&#34;重构前的代码&#34;&gt;重构前的代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Color: String {
    case unknown
    case black
    case white
    case gray
    case blue
    case red
}
class Style {
    var backgroudColor = Color.black
    var textColor = Color.white
    func apply() {
        print(&amp;quot;皮肤 - 背景色: \(self.backgroudColor), 文字颜色: \(self.textColor)&amp;quot;)
    }
}
let baseStyle = Style()
baseStyle.apply()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，如果有一个新需求增加一个背景色为灰色，文字颜色为蓝并且按钮颜色为红的主题，如何修改？并且需要遵守开闭原则&lt;/p&gt;
&lt;h4 id=&#34;继承&#34;&gt;继承&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Custom1Style: Style {
    var buttonColor = Color.red
    override init() {
        super.init()
        backgroudColor = .gray
        textColor = .blue
    }
    override func apply() {
        print(&amp;quot;皮肤 - 背景色: \(self.backgroudColor), 文字颜色: \(self.textColor), 按钮颜色: \(self.buttonColor)&amp;quot;)
    }
}
let custom1Style = Custom1Style()
custom1Style.apply()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过继承方式实现开闭原则并不彻底，通过接口可以更好的实现开闭原则。&lt;/p&gt;
&lt;h4 id=&#34;接口&#34;&gt;接口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol StyleInterface {
    var backgroudColor: Color { get }
    var textColor: Color { get }
    var buttonColor: Color { get }
    func apply()
}
extension StyleInterface {
    var buttonColor: Color {
        get {
            return .unknown
        }
    }
}
class BaseStyle: StyleInterface {
    var backgroudColor: Color = .black
    var textColor: Color = .white
    func apply() {
        print(&amp;quot;皮肤 - 背景色: \(self.backgroudColor), 文字颜色: \(self.textColor)&amp;quot;)
    }
}
class Custom2Style: StyleInterface {
    var backgroudColor: Color = .gray
    var textColor: Color = .blue
    var buttonColor: Color = .red
    func apply() {
        print(&amp;quot;皮肤 - 背景色: \(self.backgroudColor), 文字颜色: \(self.textColor), 按钮颜色: \(self.buttonColor)&amp;quot;)
    }
}
let baseStyle2 = BaseStyle()
let custom2Style = Custom2Style()
baseStyle2.apply()
custom2Style.apply()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;StyleInterface 协议定义了与主题相关的属性和方法，方法需要扩展多个主题时，需要对接口进行不同的实现即可。&lt;/p&gt;
&lt;h3 id=&#34;2-里式替换原则&#34;&gt;2. 里式替换原则&lt;/h3&gt;
&lt;p&gt;继承必须保证超类所拥有的性质在子类中依然成立。即：在进行类的继承时，要保证子类不对父类的属性或方法进行重写，只是扩展父类的功能。&lt;br&gt;
如果在设计时发现子类不得不重写父类的方法，则表明类的组织结构有问题，需要重新设计类的继承关系，比如将被重写的方法从父类抽离，仅在需要的子类声明。&lt;/p&gt;
&lt;h3 id=&#34;3-单一职责原则&#34;&gt;3. 单一职责原则&lt;/h3&gt;
&lt;p&gt;一个类只应该承担一项责任，在实际设计中，可以以是否只有一个引起类变化的原因作为准则如果不止一个原因会引起类的变化，则需要对类重新进行拆分。&lt;br&gt;
如果一个类或对象承担了太多的责任，则其中一个责任的变化可以带来对其他责任的影响，且不利于代码的复用性，容易造成代码的冗余，遵守单一职责设计的程序有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低类的复杂度，一个类承担单一的职责，逻辑清晰，提高内聚，降低耦合&lt;/li&gt;
&lt;li&gt;提高代码可读性和可复用性&lt;/li&gt;
&lt;li&gt;增强代码可维护性和可扩展性&lt;/li&gt;
&lt;li&gt;类的变更是必然的，功能的增加必然会产生类的变更，单一职责可以使变更带来的影响最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-接口隔离原则&#34;&gt;4. 接口隔离原则&lt;/h3&gt;
&lt;p&gt;将庞大的接口定义拆分为更小的和更具体的接口，其“隔离”的主要是指对接口依赖的隔离。例如 &lt;code&gt;UITableView&lt;/code&gt; 的 &lt;code&gt;UITableViewDataSource&lt;/code&gt; 和 &lt;code&gt;UITableViewDelegate&lt;/code&gt;。定义的各个接口各司其职，尽量少耦合其他业务逻辑。&lt;/p&gt;
&lt;h3 id=&#34;5-依赖倒置原则&#34;&gt;5. 依赖倒置原则&lt;/h3&gt;
&lt;p&gt;高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。与 开闭原则 的核心思路相同，都是要尽量减少对已有代码的修改，同时又易于进行扩展。优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于都对接口进行依赖，减少了类之间的耦合&lt;/li&gt;
&lt;li&gt;封闭了对类实现的修改，增强了程序的稳定性&lt;/li&gt;
&lt;li&gt;核心是面向接口开发，减少了并行开发的依赖于风险&lt;/li&gt;
&lt;li&gt;提高代码可读性和可维护性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重构前的代码：&lt;br&gt;
如下代码即上层依赖下层：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class FoodStore {
    func sell(count: Int) {
        print(&amp;quot;食品商店卖了\(count)食物&amp;quot;)
    }
}
class Customer {
    func buy(store: FoodStore, count: Int) {
        print(&amp;quot;购物--&amp;quot;)
        store.sell(count: count)
    }
}
let customer = Customer()
customer.buy(store: FoodStore(), count: 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当有新的商店出现时就需要更改上层的 &lt;code&gt;Customer&lt;/code&gt; 类。&lt;br&gt;
使用依赖倒置的原则进行重构，使 &lt;code&gt;Customer&lt;/code&gt; 只对抽象的接口进行依赖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Store {
    func sell(count: Int)
}
class FoodStore: Store {
    func sell(count: Int) {
        print(&amp;quot;食品商店卖了\(count)食物&amp;quot;)
    }
}
class ClothStore: Store {
    func sell(count: Int) {
        print(&amp;quot;服装商店卖了\(count)服装&amp;quot;)
    }
}
class Customer {
    func buy(store: Store, count: Int) {
        print(&amp;quot;购物--&amp;quot;)
        store.sell(count: count)
    }
}
let customer = Customer()
customer.buy(store: FoodStore(), count: 4)
customer.buy(store: ClothStore(), count: 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重构后的 &lt;code&gt;Customer&lt;/code&gt; 不再依赖具体的 &lt;code&gt;Store&lt;/code&gt; ，扩展也不需要更改其内部实现。&lt;/p&gt;
&lt;h3 id=&#34;6-迪米特原则&#34;&gt;6. 迪米特原则&lt;/h3&gt;
&lt;p&gt;又叫 “最小知识原则”。核心为一个类或对象尽可能少地与其他实体发生交互作用。通常，我们不会对单独的类使用迪米特原则，这样做的解耦效果并不明显，但是如果是模块之间的交互通过一个中介类来统一处理，那就可以大大减少模块间的耦合程度，例如在iOS组件化开发中的路由器，可以将模块之间的耦合通过路由进行隔离，降低模块间的耦合。&lt;/p&gt;
&lt;h3 id=&#34;7-合成复用原则&#34;&gt;7. 合成复用原则&lt;/h3&gt;
&lt;p&gt;在设计类的复用时，要尽量先使用组合或聚合的方式设计，尽量少使用继承。合成复用原则通过组合和聚合的方式实现复用，实现上通常使用属性、参数的方式引入其他实体进行通信。&lt;br&gt;
重构前的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Teacher {
    var name: String
    init(_ name: String) {
        self.name = name
    }
    func teach() {
        print(&amp;quot;讲课&amp;quot;)
    }
}
class MathTeacher: Teacher {
    override func teach() {
        print(&amp;quot;\(name)讲数学课&amp;quot;)
    }
}
class EnglishTeacher: Teacher {
    override func teach() {
        print(&amp;quot;\(name)讲英语课&amp;quot;)
    }
}
let james = MathTeacher(&amp;quot;james&amp;quot;)
james.teach()
let davis = EnglishTeacher(&amp;quot;davis&amp;quot;)
davis.teach()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据合成复用原则，不使用继承，把学科封装为Teacher的一个属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Suject {
    var name: String
    init(_ name: String) {
        self.name = name
    }
}
class Teacher {
    var name: String
    var subject: Suject
    init(_ name: String, subject: String) {
        self.name = name
        self.subject = Suject(subject)
    }
    func teach() {
        print(&amp;quot;\(name)讲\(subject.name)课&amp;quot;)
    }
}
let james = Teacher(&amp;quot;james&amp;quot;, subject: &amp;quot;数学&amp;quot;)
james.teach()
let davis = Teacher(&amp;quot;davis&amp;quot;, subject: &amp;quot;英语&amp;quot;)
davis.teach()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开闭原则是核心，在设计软件时保持扩展的开放性和修改的封闭性&lt;/li&gt;
&lt;li&gt;里式替换原则要求在继承时不要破坏父类的实现&lt;/li&gt;
&lt;li&gt;单一职责原则要求类的功能要单一&lt;/li&gt;
&lt;li&gt;接口隔离原则要求接口的设计要精简&lt;/li&gt;
&lt;li&gt;依赖倒置原则要求面向抽象编程，即面向接口编程&lt;/li&gt;
&lt;li&gt;迪米特原则提供一种降低系统耦合性的方式&lt;/li&gt;
&lt;li&gt;合成复用原则要求组织类的关系时谨慎使用继承&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7种基本设计原则&#34;&gt;7种基本设计原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;开闭原则：软件设计的终极目标，对扩展开放，对修改关闭&lt;/li&gt;
&lt;li&gt;里式替换原则：子类可以扩展父类方法，但不能修改父类原有方法本身行为&lt;/li&gt;
&lt;li&gt;依赖倒置原则：面向协议编程，尽量依赖抽象&lt;/li&gt;
&lt;li&gt;单一职责原则：降低类的复杂度，一个类只负责一种职责&lt;/li&gt;
&lt;li&gt;接口隔离原则：精简接口，一个接口只负责一类职责&lt;/li&gt;
&lt;li&gt;迪米特原则：简化类之间的交互，使用中介者统一处理&lt;/li&gt;
&lt;li&gt;合成复用原则：使用组合或聚合代理继承&lt;/li&gt;
&lt;/ul&gt;
">设计模式-软件设计的7个原则</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/git-he-bing-liang-ge-bu-tong-de-cang-ku/"" data-c="
          &lt;h1 id=&#34;git-合并两个不同的仓库&#34;&gt;Git-合并两个不同的仓库&lt;/h1&gt;
&lt;p&gt;有时候我们需要合并两个不同地址的Git仓库，比如：其中一个仓库A我们在GitHub上部署，另外一个仓库B我们在国内的Coding上部署，两者为同一个工程，如果我们希望将仓库A的所有改动合并到仓库B上。&lt;/p&gt;
&lt;p&gt;整个操作的思路是伪造伪造其中一个远程仓库作为另一个仓库的一个分支，然后进行分支合并。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;背景&#34;&gt;背景：&lt;/h4&gt;
&lt;p&gt;A仓库地址为：git@github.com:qxuewei/notebook.git&lt;br&gt;
B仓库地址为：git@e.coding.net:qxuewei/notebook/notebook.git&lt;br&gt;
需要将A仓库改动合并到B仓库中，首先保证A仓库内所有的改动均已提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外一个前提是你需要有两个仓库的代码操作权限，否则无法合并。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-下载需要进行合并的仓库-b&#34;&gt;1. 下载需要进行合并的仓库 B&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git clone git@e.coding.net:qxuewei/notebook/notebook.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-添加需要被合并的远程仓库-a&#34;&gt;2. 添加需要被合并的远程仓库 A&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git remote add base git@github.com:qxuewei/notebook.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 base 作为远程仓库，添加到 本地仓库(origin)中，设置别名为 base(自定义，为了方便与本地仓库origin作区分)&lt;/p&gt;
&lt;p&gt;此时使用 &lt;code&gt;git remote&lt;/code&gt; 查看所有远程仓库将看到两个 一个本地默认仓库origin 另外一个我们新增的 base&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426962995.16129414984288.jpg&#34; alt=&#34;-w772&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-把base远程仓库a中数据抓取到本仓库b&#34;&gt;3. 把base远程仓库（A）中数据抓取到本仓库（B）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git fetch base
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第2步 &lt;code&gt;git remote add xxx&lt;/code&gt; 我们仅仅是新增了远程仓库的引用，这一步真正将远程仓库的数据抓取到本地，准备后续的更新。&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426963015.16129417088506.jpg&#34; alt=&#34;-w669&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4-基于base仓库的master分支新建一个分支并切换到该分支命名为-githubb&#34;&gt;4. 基于base仓库的master分支，新建一个分支，并切换到该分支，命名为 &amp;quot;githubB&amp;quot;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b githubB base/master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时我们的仓库B就有了一个基于仓库A内容的分支 &amp;quot;githubB&amp;quot;，后续我们将 &amp;quot;githubB&amp;quot; 分支代码合并到master就可以了。&lt;/p&gt;
&lt;p&gt;此时使用 &lt;code&gt;git branch&lt;/code&gt; 查看所有分支&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426963027.16129419488703.jpg&#34; alt=&#34;-w222&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;5-我们切换到需要合并的分支-master&#34;&gt;5. 我们切换到需要合并的分支 master&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第 4 步我们创建了即将被合并分支 &amp;quot;githubB&amp;quot; ，默认是在当前分支上的，所以我们需要切换回我们的目标分支。&lt;/p&gt;
&lt;h4 id=&#34;6-合并&#34;&gt;6. 合并&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git merge githubB --allow-unrelated-histories
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不加 &lt;code&gt;--allow-unrelated-histories&lt;/code&gt; 关键字会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fatal: refusing to merge unrelated histories
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在流程中报上述错误加该关键词&lt;code&gt;--allow-unrelated-histories&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;合并过程中可能会遇到各种冲突，如果有冲突解决就可以了。&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426963038.16129425194956.jpg&#34; alt=&#34;-w817&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;7-提交&#34;&gt;7. 提交&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后提交，大功告成。👌&lt;/p&gt;
">Git-合并两个不同的仓库</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/mysql-ji-chu-yu-fa/"" data-c="
          &lt;h1 id=&#34;mysql-基础语法&#34;&gt;MySQL - 基础语法&lt;/h1&gt;
&lt;h2 id=&#34;sql&#34;&gt;SQL&lt;/h2&gt;
&lt;p&gt;Structured Query Language：结构化查询语言&lt;br&gt;
定义了了操作所有关系型数据库的规则&lt;/p&gt;
&lt;h2 id=&#34;sql-通用语法&#34;&gt;SQL 通用语法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SQL 语句可以单行或多行书写，以分号结尾&lt;/li&gt;
&lt;li&gt;可使用空格和缩进来增强语句的可读性&lt;/li&gt;
&lt;li&gt;MySQL 数据库的SQL语句不区分大小写，关键字建议大写&lt;/li&gt;
&lt;li&gt;注释：
&lt;ol&gt;
&lt;li&gt;单行注释：-- 注释内容 或 # 注释内容 （MySQL独有）&lt;/li&gt;
&lt;li&gt;多行注释：/* 注释内容 */&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;sql-分类&#34;&gt;SQL 分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;DDL（Date Definition Language） 数据库定义语言：定义数据库对象：数据库、表、列。关键字：&lt;code&gt;CREATE&lt;/code&gt;、&lt;code&gt;DROP&lt;/code&gt;、&lt;code&gt;ALTER&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;DML（Date Manipulation Language）数据库操作语言：对数据库表中的数据进行增删改。关键字：&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;DQL (Date Query Language) 数据库查询语言：用来查询数据库表中的数据。关键字：&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;WHERE&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;DCL (Date Control Language) 数据库控制语言：定于数据库的访问权限和安全级别。关键字：&lt;code&gt;CRANT&lt;/code&gt;、&lt;code&gt;REVOKE&lt;/code&gt; 等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ddl&#34;&gt;DDL&lt;/h3&gt;
&lt;h4 id=&#34;操作数据库&#34;&gt;操作数据库&lt;/h4&gt;
&lt;h5 id=&#34;c-create-创建&#34;&gt;C (Create) - 创建&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;创建数据库：&lt;code&gt;CREATE DATABASE 数据库名称;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建数据库-不存在再创建：&lt;code&gt;CREATE DATABASE IF NOT EXISTS 数据库名称;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建数据库-指定字符集：&lt;code&gt;CREATE DATABASE 数据库名称 CHARACTER SET 字符集名;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;r-retrieve-查询&#34;&gt;R (Retrieve) - 查询&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;查询所有数据库名称：&lt;code&gt;SHOW DATABASE;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询某个数据库的字符集：查询某个数据库的创建语句：&lt;code&gt;SHOW CREATE DATABASE 数据库名称;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;u-update-修改&#34;&gt;U (Update) - 修改&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;修改数据库的字符集：&lt;code&gt;ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;d-delete-删除&#34;&gt;D (Delete) - 删除&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;删除数据库：&lt;code&gt;DROP DATABASE 数据库名称&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除数据库-存在再删除：&lt;code&gt;DROP DATABASE IF EXISTS 数据库名称&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;使用数据库&#34;&gt;使用数据库&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;查询当前正在使用的数据库名称：&lt;code&gt;SELECT DATABASE();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用数据库：&lt;code&gt;USE 数据库名称;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;操作表&#34;&gt;操作表&lt;/h4&gt;
&lt;h5 id=&#34;c-create-创建-2&#34;&gt;C (Create) - 创建&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREAT TABLE 表名(
    列名1 数据类型1,
    列名2 数据类型2,
    ...
    列名n 数据类型n
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用表类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int: &lt;code&gt;age INT,&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;double: &lt;code&gt;score DOUBLE(5,2), # 最多5位，保留2位小数 99.12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;date: 日期，只包含年月日，yyyy-MM-dd&lt;/li&gt;
&lt;li&gt;datetime: 日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss&lt;/li&gt;
&lt;li&gt;timestamp: 时间戳，包含年月日时分秒，yyyy-MM-dd HH:mm:ss，如果不给其赋值，或赋值为null，则默认使用当前系统时间自动赋值，常用语 创建时间 字段&lt;/li&gt;
&lt;li&gt;varchar: 字符串，&lt;code&gt;name VARCHAR(20) # 最大20字符的姓名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;复制表：&lt;code&gt;CREATE TABLE 新表名 LIKE 旧表名;&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;r-retrieve-查询-2&#34;&gt;R (Retrieve) - 查询&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;查询某个数据库中所有的表名称：&lt;code&gt;SHOW TABLES;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询表结构：&lt;code&gt;DESC 表名称;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询建表语句：&lt;code&gt;SHOW CREATE TABLE 表名;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;u-update-修改-2&#34;&gt;U (Update) - 修改&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;修改表名：&lt;code&gt;ALTER TABLE 旧表名 RENAME TO 新表名;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改表字符集：&lt;code&gt;ALTER TABLE 表名 CHARACTER SET 字符集名称;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加一列：&lt;code&gt;ALTER TABLE 表名 ADD 列名 数据类型;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改列名称和数据类型：
&lt;ul&gt;
&lt;li&gt;即修改名称也修改数据类型：&lt;code&gt;ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只修改数据类型：&lt;code&gt;ALTER TABLE 表名 MODIFY 列名 新数据类型;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除列：&lt;code&gt;ALTER TABLE 表名 DROP 列名;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;d-delete-删除-2&#34;&gt;D (Delete) - 删除&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;删除表：&lt;code&gt;DROP TABLE 表名;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除表-存在再删：&lt;code&gt;DROP TABLE IF EXISTS 表名;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dml&#34;&gt;DML&lt;/h3&gt;
&lt;h4 id=&#34;添加数据&#34;&gt;添加数据&lt;/h4&gt;
&lt;p&gt;语法：&lt;code&gt;INSTER INTO 表名(列名1,列名2,...,列名n) VALUES(值1,值2,...,值n);&lt;/code&gt;&lt;br&gt;
注意：1. 列名和值要一一对应。2.如果表名后，不定义列名，则默认给所列添加值(&lt;code&gt;INSERT INTO 表名 VALUES(值1,值2,...,值n)&lt;/code&gt;)。3.除了数字类型，其他类型需要使用引号（单引号、双引号都行）引起来&lt;/p&gt;
&lt;h4 id=&#34;删除数据&#34;&gt;删除数据&lt;/h4&gt;
&lt;p&gt;语法：&lt;code&gt;DELETE FROM 表名 [WHERE 条件]&lt;/code&gt;&lt;br&gt;
注意：1. 如果不加条件（&lt;code&gt;DELETE FORM 表名;&lt;/code&gt;），删除表中所有记录。如果不加 WHERE 则删除整个表中所有数据(会执行n次删除操作)。2. 如果想删除整个表中所有数据，建议使用&lt;code&gt;TRUNCATE TABLE 表名; (删除表，然后创建一个同名空表)&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;修改数据&#34;&gt;修改数据&lt;/h4&gt;
&lt;p&gt;语法：&lt;code&gt;UPDATE 表名 SET 列名1=值1, 列名2=值2, ... [WHERE 条件];&lt;/code&gt;&lt;br&gt;
注意：1. 如果不加条件（&lt;code&gt;UPDATE 表名 SET 列名1=值1, 列名2=值2, ...&lt;/code&gt;）,则会将表中所有记录全部修改。&lt;/p&gt;
&lt;h3 id=&#34;dql&#34;&gt;DQL&lt;/h3&gt;
&lt;p&gt;查询表中的记录：&lt;code&gt;SELECT * FROM 表名;&lt;/code&gt;&lt;br&gt;
语法：&lt;code&gt;SELECT 字段列表 FROM 表名列表 WHERE 条件列表  GROUP BY 分组字段 HAVING 分组之后的条件 ORDER BY 排序 LIMIT 分页限定&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;基础查询&#34;&gt;基础查询&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;多个字段的查询
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SELECT 字段名1，字段名2，... FROM 表名;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：如果查询所有字段，则可以使用 * 来替代字段列表&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;去除重复
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DISTINCT&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;eg: &lt;code&gt;SELECT DISTINCT address FROM student;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算列
&lt;ol&gt;
&lt;li&gt;一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
&lt;ul&gt;
&lt;li&gt;eg: &lt;code&gt;SELECT name,math,english,math + english FROM student;&lt;/code&gt; # (查询每个人的各科成绩和总分)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ifnull(表达式1，表达式2)：null 参与的运算，计算结果都为null
&lt;ol&gt;
&lt;li&gt;表达式1：哪个字段需要判断是否为 null&lt;/li&gt;
&lt;li&gt;表达式2：如果1字段为null后替换的新值&lt;/li&gt;
&lt;li&gt;eg: &lt;code&gt;SELECT name,math,english,math + IFNULL(english, 0) FROM student;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;起别名
&lt;ol&gt;
&lt;li&gt;as: as 可以省略&lt;/li&gt;
&lt;li&gt;eg: &lt;code&gt;SELECT name,math AS 数学,english AS 英语,math + IFNULL(english, 0) AS 总分 FROM student;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;条件查询&#34;&gt;条件查询&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;WHERERE&lt;/code&gt; 子句后跟条件&lt;/li&gt;
&lt;li&gt;运算符
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;、 &amp;lt;、 &amp;lt;=、 &amp;gt;=、 =、 &amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BETWEEN...AND&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IN (集合)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IS NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AND 或 &amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OR 或 ||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOT 或 !&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;占位符
&lt;ol&gt;
&lt;li&gt;_: 单个任意字符&lt;/li&gt;
&lt;li&gt;%: 多个任意字符&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;eg&#34;&gt;eg:&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 查询年龄大于20岁
SELECT * FROM student WHERE age &amp;gt; 20;

-- 查询年龄大于等于20岁
SELECT * FROM student WHERE age &amp;gt;= 20;
	
-- 查询年龄等于20岁
SELECT * FROM student WHERE age = 20;
	
-- 查询年龄不等于20岁
SELECT * FROM student WHERE age != 20;
SELECT * FROM student WHERE age &amp;lt;&amp;gt; 20;
	
-- 查询年龄大于等于20 小于等于30
SELECT * FROM student WHERE age &amp;gt;= 20 &amp;amp;&amp;amp;  age &amp;lt;=30;
SELECT * FROM student WHERE age &amp;gt;= 20 AND  age &amp;lt;=30;
SELECT * FROM student WHERE age BETWEEN 20 AND 30;
	
-- 查询年龄22岁，18岁，25岁的信息
SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25
SELECT * FROM student WHERE age IN (22,18,25);
	
-- 查询英语成绩为null
SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断
SELECT * FROM student WHERE english IS NULL;
	
-- 查询英语成绩不为null
SELECT * FROM student WHERE english  IS NOT NULL;

-- 查询姓马的有哪些？ like
SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;

-- 查询姓名第二个字是化的人
SELECT * FROM student WHERE NAME LIKE &amp;quot;_化%&amp;quot;;
	
-- 查询姓名是3个字的人
SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;
				
-- 查询姓名中包含德的人
SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;排序查询&#34;&gt;排序查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;ORDER BY 子句&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ORDER BY 排序字段1 排序方式1, 排序字段2 排序方式2...;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序方式：
&lt;ul&gt;
&lt;li&gt;ASC：升序 （默认）&lt;/li&gt;
&lt;li&gt;DESC：降序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ul&gt;
&lt;li&gt;如果有多个排序条件，则当前面条件值一致时，才会判断第二条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;聚合函数&#34;&gt;聚合函数&lt;/h4&gt;
&lt;p&gt;将一列数据作为一个整体，进行纵向计算。&lt;br&gt;
注意：聚合函数的计算时，默认排除null值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;COUNT&lt;/code&gt;: 计算个数
&lt;ul&gt;
&lt;li&gt;一般选择非空的列：主键&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COUNT(*)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAX&lt;/code&gt;: 最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MIN&lt;/code&gt;: 最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUM&lt;/code&gt;: 和&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AVG&lt;/code&gt;: 平均值&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分组查询&#34;&gt;分组查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;GROUP BY 分组字段;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：
&lt;ul&gt;
&lt;li&gt;分组之后查询的字段只能是: 分组字段和聚合函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 的区别？
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 在分组之前进行限定，如果不满足条件，则不参与分组。&lt;code&gt;HAVING&lt;/code&gt; 在分组之后限定，如果不满足结果，则不会被查询出来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 后不可以跟聚合函数，&lt;code&gt;HAVING&lt;/code&gt; 可以进行聚合函数的判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;eg-2&#34;&gt;eg:&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 按照性别分组。分别查询男、女同学的平均分
SELECT sex , AVG(math) FROM student GROUP BY sex;
	
-- 按照性别分组。分别查询男、女同学的平均分,人数
SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;
	
--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组
SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &amp;gt; 70 GROUP BY sex;
	
--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人
SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &amp;gt; 70 GROUP BY sex HAVING COUNT(id) &amp;gt; 2;

SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &amp;gt; 70 GROUP BY sex HAVING 人数 &amp;gt; 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;分页查询&#34;&gt;分页查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;LIMIT&lt;/code&gt; 开始的索引，每页查询的条数；&lt;/li&gt;
&lt;li&gt;公式：开始的索引 = （当前的页码-1） * 每页显示的条数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIMIT&lt;/code&gt; 是一个MYSQL的特有关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dcl&#34;&gt;DCL&lt;/h3&gt;
&lt;p&gt;管理用户，授权。&lt;/p&gt;
&lt;h4 id=&#34;管理用户&#34;&gt;管理用户&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;添加用户：&lt;code&gt;CREATE USER &#39;用户名&#39;@&#39;主机名&#39; INDENTIFIED&#39; BY &#39;密码&#39;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除用户：&lt;code&gt;DROP USER &#39;用户名&#39;@&#39;主机名&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改用户密码：&lt;code&gt;UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;&lt;/code&gt; 或 &lt;code&gt;SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;权限管理&#34;&gt;权限管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;查询权限: &lt;code&gt;SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;授予权限：&lt;code&gt;GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;; -- 为张三授予root权限&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;撤销权限：&lt;code&gt;REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REVOKE UPDATE ON db3.&lt;/code&gt;account&lt;code&gt; FROM &#39;lisi&#39;@&#39;%&#39;; -- 撤销李四db3的account表的操作权限&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;eg-3&#34;&gt;eg:&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 每页显示3条记录 
SELECT * FROM student LIMIT 0,3; -- 第1页
SELECT * FROM student LIMIT 3,3; -- 第2页
SELECT * FROM student LIMIT 6,3; -- 第3页
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;约束&#34;&gt;约束&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。&lt;/li&gt;
&lt;li&gt;分类：
&lt;ul&gt;
&lt;li&gt;主键：&lt;code&gt;PRIMARY KEY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非空：&lt;code&gt;NOT NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;唯一：&lt;code&gt;UNIQUE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;外键：&lt;code&gt;FOREIGN KEY&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非空not-null-某一列的值不能为-null&#34;&gt;非空：&lt;code&gt;NOT NULL&lt;/code&gt;, 某一列的值不能为 null&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建表时添加非空约束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;CREAT TABLE student (
    id INT,
    NAME VARCHAR(20) NOT NULL -- name 不为空    
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建完表后，添加非空约束&lt;br&gt;
&lt;code&gt;ALTER TABLE student MODIFY NAME VARCHAR(20) NOT NULL;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建完表后，删除非空约束&lt;br&gt;
&lt;code&gt;ALTER TABLE student MODIFY NAME VARCHAR(20);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;唯一约束unique-某一列的值不能重复&#34;&gt;唯一约束：&lt;code&gt;UNIQUE&lt;/code&gt; 某一列的值不能重复&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注意：唯一约束可以有 NULL 值，但只能有一条记录为 NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建表时添加唯一约束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREAT TABLE student (
id INT,
phoneNumber VARCHAR(20) UNIQUE -- 手机号 不可重复    
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建完表后，添加唯一约束&lt;br&gt;
&lt;code&gt;ALTER TABLE student MODIFY phoneNumber VARCHAR(20) UNIQUE;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建完表后，删除唯一约束&lt;br&gt;
&lt;code&gt;ALTER TABLE student DROP INDEX phoneNumber;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主键约束primary-key&#34;&gt;主键约束：&lt;code&gt;PRIMARY KEY&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;含义：非空且唯一&lt;/li&gt;
&lt;li&gt;一张表只能有一个字段为主键&lt;/li&gt;
&lt;li&gt;主键就是表中记录的唯一标识&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在创建表时，添加主键约束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;CREAT TABLE student(
    id INT PRIMARY KEY, -- 给id添加主键约束
    name VARCHAR(20)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除主键约束&lt;br&gt;
&lt;code&gt;ALTER TABLE student DROP PRIMARY KEY;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建完表后，添加主键&lt;br&gt;
&lt;code&gt;ALTER TABLE student MODIFY id INT PRIMARY KEY;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动增长：如果某一列是数值类型，使用 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 可以完成值的自动增长。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在创建表时，添加主键约束，并且完成主键自增长&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;CREATE TABLE student (
    id INT PRIMARY KEY AUTO_INCREMENT, -- 给id添加主键约束
    name VARCHAR(20)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除自动增长&lt;br&gt;
&lt;code&gt;ALTER TABLE student MODIFY id INT&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加自动增长&lt;br&gt;
&lt;code&gt;ALTER TABLE student MODIFY id INT AUTO_INCREMENT&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;外键约束foreign-key&#34;&gt;外键约束：&lt;code&gt;FOREIGN KEY&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在创建表时，可以添加外键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注意：外键可以为null，但不能为不存在的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;CREATE TABLE 表名(
	....
	外键列
    CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除外键&lt;br&gt;
&lt;code&gt;ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建表之后，添加外键&lt;br&gt;
&lt;code&gt;ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;级联操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;添加级联操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分类：
&lt;ol&gt;
&lt;li&gt;级联更新：ON UPDATE CASCADE&lt;/li&gt;
&lt;li&gt;级联删除：ON DELETE CASCADE&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;语法：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;ALTER TABLE 表名 ADD CONSTRAINT 外键名称 
FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE / ON DELETE CASCADE;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库的设计&#34;&gt;数据库的设计&lt;/h2&gt;
&lt;h3 id=&#34;多表之间的关系&#34;&gt;多表之间的关系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一对一：eg: 人和身份证&lt;/li&gt;
&lt;li&gt;一对多：eg: 部门和员工
&lt;ul&gt;
&lt;li&gt;实现方式：在&amp;quot;多&amp;quot;的一方建立外键，指向&amp;quot;一&amp;quot;的一方的主键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多对多：eg: 学生和课程
&lt;ul&gt;
&lt;li&gt;实现方式：借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;案例&#34;&gt;案例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;-- 创建旅游线路分类表 tab_category
-- cid 旅游线路分类主键，自动增长
-- cname 旅游线路分类名称非空，唯一，字符串 100
CREATE TABLE tab_category (
    cid INT PRIMARY KEY AUTO_INCREMENT,
    cname VARCHAR(100) NOT NULL UNIQUE
);
	
-- 创建旅游线路表 tab_route
/*
rid 旅游线路主键，自动增长
rname 旅游线路名称非空，唯一，字符串 100
price 价格
rdate 上架时间，日期类型
cid 外键，所属分类
*/
CREATE TABLE tab_route(
    rid INT PRIMARY KEY AUTO_INCREMENT,
    rname VARCHAR(100) NOT NULL UNIQUE,
    price DOUBLE,
    rdate DATE,
    cid INT,
    FOREIGN KEY (cid) REFERENCES tab_category(cid)
);
	
/*创建用户表 tab_user
uid 用户主键，自增长
username 用户名长度 100，唯一，非空
password 密码长度 30，非空
name 真实姓名长度 100
birthday 生日
sex 性别，定长字符串 1
telephone 手机号，字符串 11
email 邮箱，字符串长度 100
*/
CREATE TABLE tab_user (
    uid INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(100) UNIQUE NOT NULL,
    PASSWORD VARCHAR(30) NOT NULL,
    NAME VARCHAR(100),
    birthday DATE,
    sex CHAR(1) DEFAULT &#39;男&#39;,
    telephone VARCHAR(11),
    email VARCHAR(100)
);
	
/*
创建收藏表 tab_favorite
rid 旅游线路 id，外键
date 收藏时间
uid 用户 id，外键
rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次
*/
CREATE TABLE tab_favorite (
    rid INT, -- 线路id
    DATE DATETIME,
    uid INT, -- 用户id
    -- 创建复合主键
    PRIMARY KEY(rid,uid), -- 联合主键
    FOREIGN KEY (rid) REFERENCES tab_route(rid),
    FOREIGN KEY(uid) REFERENCES tab_user(uid)
);

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据库设计的范式&#34;&gt;数据库设计的范式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  	设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
  	目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式（1NF）：每一列都是不可分割的原子数据项&lt;/li&gt;
&lt;li&gt;第二范式（2NF）：在第一范式的基础上，非码属性必须完全依赖于码。（在1NF基础上消除非主属性对码的部分函数依赖）
&lt;ul&gt;
&lt;li&gt;函数依赖：A-&amp;gt;B, 如果通过A属性（属性组）的值，可以确定唯一B属性的值，则称B依赖于A。eg: 学号-&amp;gt;姓名，（学号，课程名称）-&amp;gt; 分数
&lt;ul&gt;
&lt;li&gt;完全函数依赖：A-&amp;gt;B，如果A是一个属性组，则B属性的值需要依赖于A属性组中的所有元素值。eg:（学号，课程名称）-&amp;gt; 分数&lt;/li&gt;
&lt;li&gt;部分函数依赖：A-&amp;gt;B，如果A是一个属性组，则B属性值只需要依赖A属性组中的某一些值即可。eg:（学号，课程名称）-&amp;gt; 姓名&lt;/li&gt;
&lt;li&gt;传递函数依赖：A-&amp;gt;B, B-&amp;gt;C，如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性（属性组）的值可以确定唯一C属性的值，则称C传递依赖于A。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;码：如果在一张表中，一个属性（属性组）被其他所有属性完全依赖，则称这个属性（属性组）为该表的码。eg: （学号，课程名称）
&lt;ul&gt;
&lt;li&gt;主属性：码属性（组）中所有的属性&lt;/li&gt;
&lt;li&gt;非主属性：除码属性（组）外的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三范式（3NF）：在2NF的基础上，任何非主属性不依赖于其他非主属性。（在2NF基础上消除传递依赖）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库的备份和还原&#34;&gt;数据库的备份和还原&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;命令行：
&lt;ul&gt;
&lt;li&gt;备份语法：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名称 &amp;gt; 保存的位置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;还原方式：
&lt;ul&gt;
&lt;li&gt;登录数据库&lt;/li&gt;
&lt;li&gt;创建数据库&lt;/li&gt;
&lt;li&gt;使用数据库&lt;/li&gt;
&lt;li&gt;执行文件 （之前保存的文件路径）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多表查询&#34;&gt;多表查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;笛卡尔积：有两个集合A、B, 取这两个集合的所有组成情况&lt;/li&gt;
&lt;li&gt;要完成多表查询，需要消除无用的数据&lt;/li&gt;
&lt;li&gt;语法：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;SELECT
    列名列表
FROM
    表名列表
WHERE
    条件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;# 创建部门表
CREATE TABLE dept(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20)
);
INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);
# 创建员工表
CREATE TABLE emp (
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(10),
	gender CHAR(1), -- 性别
	salary DOUBLE, -- 工资
	join_date DATE, -- 入职日期
	dept_id INT,
	FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)
);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);
INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多表查询的分类&#34;&gt;多表查询的分类&lt;/h3&gt;
&lt;h4 id=&#34;内连接查询&#34;&gt;内连接查询&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1. 从哪些表中查询数据
2. 条件是什么
3. 查询哪些字段
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;隐式内连接&#34;&gt;隐式内连接&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 查询所有员工信息和对应的部门信息
SELECT * FROM emp,dept WHERE emp.dept_id = dept.id;
    
-- 查询员工表的名称，性别。部门表的名称
-- 查询员工表的名称，性别。部门表的名称
SELECT
	t1.`NAME`,
	t1.gender,
	t2.`NAME`
FROM
	emp t1,		-- 员工表
	dept t2		-- 部门表
WHERE
	t1.dept_id = t2.id
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;显式内连接&#34;&gt;显式内连接&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;SELECT 字段名称 FROM 表名1 [INNER] JOIN 表名2 ON 条件;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;例如 &lt;code&gt;SELECT * FROM emp JOIN dept ON emp.dept_id = dept.id;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;外连接查询&#34;&gt;外连接查询&lt;/h4&gt;
&lt;h5 id=&#34;左外连接&#34;&gt;左外连接&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;含义：查询左表所有的数据与有表有交集的部分&lt;/li&gt;
&lt;li&gt;实例：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
SELECT
	t1.*,
	t2.`NAME`
FROM
	emp t1
LEFT JOIN
	dept t2
ON
	t1.dept_id = t2.id
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;子查询&#34;&gt;子查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;概念：查询中嵌套查询，成嵌套查询为子查询。&lt;/li&gt;
&lt;li&gt;实例：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;-- 查询工资最高的员工信息
SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);

-- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息
SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);

-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
SELECT 
    * 
FROM 
    dept t1 ,
    (SELECT * FROM emp WHERE emp.`join_date` &amp;gt; &#39;2011-11-11&#39;) t2
WHERE 
    t1.id = t2.dept_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;事务&#34;&gt;事务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。&lt;/li&gt;
&lt;li&gt;操作:
&lt;ul&gt;
&lt;li&gt;开启事务：&lt;code&gt;START TRANSACTION;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;回滚：&lt;code&gt;ROLLBACK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提交：&lt;code&gt;COMMIT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MySQL 中事务是默认自动提交。（运行一条DML(增删改)语句就会自动提交一次事务）&lt;/li&gt;
&lt;li&gt;Oracle 数据库是默认手动提交事务，需要先开启事务，再提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;事务的四大特征&#34;&gt;事务的四大特征：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。&lt;/li&gt;
&lt;li&gt;持久性：当事务提交或回滚后，数据库会持久化的保存数据。&lt;/li&gt;
&lt;li&gt;隔离性：多个事务之间。相互独立。&lt;/li&gt;
&lt;li&gt;一致性：事务操作前后，数据总量不变&lt;/li&gt;
&lt;/ol&gt;
">MySQL - 基础语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/ios-runtime-xiang-jie/"" data-c="
          &lt;h1 id=&#34;ios-runtime-详解&#34;&gt;iOS - Runtime 详解&lt;/h1&gt;
&lt;h2 id=&#34;0-概述&#34;&gt;0. 概述&lt;/h2&gt;
&lt;p&gt;Objective-C Runtime 使得C具有了面向对象的能力，在程序运行时创建，检查，修改类，对象和它们的方法。Runtime 是 C和汇编写的，这里&lt;a href=&#34;http://www.opensource.apple.com/source/objc4/&#34;&gt;http://www.opensource.apple.com/source/objc4/&lt;/a&gt;可以下载Apple维护的开源代码，GUN也有一个开源的Runtime版本，它们都努力保持一致。&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048&#34;&gt;Apple官方的runtime编程指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于 C 语言，函数的调用会在编译期就已经决定好，在编译完成后直接顺序执行。但是 OC 是一门动态语言，函数调用变成了消息发送，在编译期不能知道调用哪个函数，Runtime 就是去解决如何在运行时期找到调用方法的问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-runtime-函数&#34;&gt;1、Runtime 函数&lt;/h2&gt;
&lt;p&gt;Runtime 系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/user/includeobjc 目录下可以看到头文件，可以用到其中一些函数通过C语言实现Objective-C中一样的功能。&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html&#34;&gt;苹果官方文档&lt;/a&gt;  里有详细的Runtime 函数文档。&lt;/p&gt;
&lt;h2 id=&#34;2-class-和-nsobject-基础数据结构&#34;&gt;2. Class 和 NSObject 基础数据结构&lt;/h2&gt;
&lt;h3 id=&#34;21-class&#34;&gt;2.1 Class&lt;/h3&gt;
&lt;p&gt;objc_class 结构体的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//-------- [file:objc-runtime-new.h] --------
struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
    ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-objc_object&#34;&gt;2.2 objc_object&lt;/h3&gt;
&lt;p&gt;objc_object 是一个类的实例结构体，objc/objc.h 中 objc_object是一个类的实例结构体定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//-------- [file:objc-private.h] --------
typedef struct objc_class *Class;
typedef struct objc_object *id;

struct objc_object {
private:
    isa_t isa;
    ......
}

union isa_t 
{
    ......
    Class cls;
    uintptr_t bits;
    ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;向object发送消息时，Runtime 库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类的方法列表中寻找对应的方法运行。id 是一个objc_object结构类型的指针，这个类型的对象能转换成任何一种对象。&lt;/p&gt;
&lt;h3 id=&#34;23-cache_t&#34;&gt;2.3 cache_t&lt;/h3&gt;
&lt;p&gt;cache_t 结构体中cache字段用于缓存调用过的method。cache指针指向cache_t结构体，这个结构体定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-meta-class&#34;&gt;2.4 Meta Class&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;meta class&lt;/code&gt; 是一个类对象的类，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当向对象发送消息时，runtime 会在这个对象所属类方法列表中查找发送消息对应的方法;&lt;/li&gt;
&lt;li&gt;但当向类发送消息时，runtime 就会在这个类的 &lt;code&gt;meta class&lt;/code&gt; 方法列表中查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的 &lt;code&gt;meta class&lt;/code&gt;，包括&lt;code&gt;Root class&lt;/code&gt;，&lt;code&gt;SuperClass&lt;/code&gt;, &lt;code&gt;SubClass&lt;/code&gt;的&lt;code&gt;isa&lt;/code&gt;都指向 &lt;code&gt;Root class&lt;/code&gt; 的 &lt;code&gt;meta class&lt;/code&gt;，这样能够形成一个闭环。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/qxuewei/XWResources/master/images/metaClass.png&#34; alt=&#34;meta class 关系图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3runtime-类与对象操作函数&#34;&gt;3.Runtime 类与对象操作函数&lt;/h2&gt;
&lt;p&gt;Runtime 有很多函数可以操作类和对象。类相关的是class为前缀，对象相关相关的函数是 objc 或者 object 为前缀。&lt;/p&gt;
&lt;h3 id=&#34;31类相关操作函数&#34;&gt;3.1类相关操作函数&lt;/h3&gt;
&lt;h4 id=&#34;name&#34;&gt;name&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取类的类名
const cahr * class_getName (Class cls);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;super_class-和-meta_class&#34;&gt;super_class 和 meta_class&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取类的父类
Class class_getSuperclass (Class cls);

// 判断给定的Class是否是一个meta class
BOOL class_isMetaClass (Class cls);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;instance_size&#34;&gt;instance_size&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取实例大小
size_t class_getInstanceSize (Class cls);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32-成员变量ivars及属性&#34;&gt;3.2 成员变量（ivars）及属性&lt;/h3&gt;
&lt;h4 id=&#34;321-成员变量操作函数&#34;&gt;3.2.1 成员变量操作函数&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取类中指定名称实例成员变量的信息
Ivar class_getInstanceVariable (Class cls, const char *name);

// 获取类成员变量的信息
Ivar class_getClassVariable (Class cls, const char *name);

// 添加成员变量
BOOL class_addIvar (Class cls, const char *name, size_t size, uint8_t alignment, const char *types);  //只能向在runtime时创建的类添加成员变量，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。

// 获取整个成员变量列表
Ivar * class_copyIvarList (Class cls, unsigned int *outCount); // 必须使用free()来释放这个数组

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试成员变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//成员变量
- (void)testIvar {
    BOOL isSuccessAddIvar = class_addIvar([NSString class], &amp;quot;_phone&amp;quot;, sizeof(id), log2(sizeof(id)), &amp;quot;@&amp;quot;);
    if (isSuccessAddIvar) {
        NSLog(@&amp;quot;Add Ivar success&amp;quot;);
    }else{
        NSLog(@&amp;quot;Add Ivar error&amp;quot;);
    }
    unsigned int outCount;
    Ivar *ivarList = class_copyIvarList([People class], &amp;amp;outCount);
    for (int i = 0; i &amp;lt; outCount; i++) {
        Ivar ivar = ivarList[i];
        const char *ivarName = ivar_getName(ivar);
        const char *type = ivar_getTypeEncoding(ivar);
        ptrdiff_t offset = ivar_getOffset(ivar);
        NSLog(@&amp;quot;ivar:%s, offset:%zd, type:%s&amp;quot;, ivarName, offset, type);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;322-属性操作函数&#34;&gt;3.2.2 属性操作函数&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取指定的属性
objc_property_t class_getProperty(Class cls, const char *name);

// 获取属性列表
objc_property_t * class_copyPropertyList(Class cls, unsigned int *outCount);

// 为类添加属性
BOOL class_addProperty (Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);

// 替换类的属性
void class_replaceProperty (Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对ivar来操作的，不过它只操作那些property的值，包括扩展中的property。&lt;/p&gt;
&lt;p&gt;测试属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)testProperty {    
    objc_property_attribute_t attribute1 = {&amp;quot;T&amp;quot;, &amp;quot;@\&amp;quot;NSString\&amp;quot;&amp;quot;};
    objc_property_attribute_t attribute2 = {&amp;quot;C&amp;quot;, &amp;quot;&amp;quot;};
    objc_property_attribute_t attribute3 = {&amp;quot;N&amp;quot;, &amp;quot;&amp;quot;};
    objc_property_attribute_t attribute4 = {&amp;quot;V&amp;quot;, &amp;quot;_addProperty&amp;quot;};
    objc_property_attribute_t attributesList[] = {attribute1, attribute2, attribute3, attribute4};
    BOOL isSuccessAddProperty = class_addProperty([People class], &amp;quot;addProperty&amp;quot;, attributesList, 4);
    if (isSuccessAddProperty) {
        NSLog(@&amp;quot;Add Property Success&amp;quot;);
    }else{
        NSLog(@&amp;quot;Add Property Error&amp;quot;);
    }
    unsigned int outCount;
    objc_property_t * propertyList = class_copyPropertyList([People class], &amp;amp;outCount);
    for (unsigned int i = 0; i &amp;lt; outCount; i++) {
        objc_property_t property = propertyList[i];
        const char *propertyName = property_getName(property);
        const char *attribute = property_getAttributes(property);
        NSLog(@&amp;quot;propertyName: %s, attribute: %s&amp;quot;, propertyName, attribute);
        unsigned int attributeCount;
        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;amp;attributeCount);
        for (unsigned int i = 0; i &amp;lt; attributeCount; i++) {
            objc_property_attribute_t attribute = attributeList[i];
            const char *name = attribute.name;
            const char *value = attribute.value;
            NSLog(@&amp;quot;attribute name: %s, value: %s&amp;quot;,name,value);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2018-05-01 17:14:52.957653+0800 RuntimeDemo[24515:910260] Add Property Success
2018-05-01 17:14:52.957871+0800 RuntimeDemo[24515:910260] propertyName: addProperty, attribute: T@&amp;quot;NSString&amp;quot;,C,N,V_addProperty
2018-05-01 17:14:52.958034+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSString&amp;quot;
2018-05-01 17:14:52.958175+0800 RuntimeDemo[24515:910260] attribute name: C, value:
2018-05-01 17:14:52.958309+0800 RuntimeDemo[24515:910260] attribute name: N, value:
2018-05-01 17:14:52.958452+0800 RuntimeDemo[24515:910260] attribute name: V, value: _addProperty
2018-05-01 17:14:52.958575+0800 RuntimeDemo[24515:910260] propertyName: name, attribute: T@&amp;quot;NSString&amp;quot;,C,N,V_name
2018-05-01 17:14:52.958732+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSString&amp;quot;
2018-05-01 17:14:52.958850+0800 RuntimeDemo[24515:910260] attribute name: C, value:
2018-05-01 17:14:52.958983+0800 RuntimeDemo[24515:910260] attribute name: N, value:
2018-05-01 17:14:52.959096+0800 RuntimeDemo[24515:910260] attribute name: V, value: _name
2018-05-01 17:14:52.959225+0800 RuntimeDemo[24515:910260] propertyName: age, attribute: T@&amp;quot;NSNumber&amp;quot;,&amp;amp;,N,V_age
2018-05-01 17:14:52.959319+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSNumber&amp;quot;
2018-05-01 17:14:52.959420+0800 RuntimeDemo[24515:910260] attribute name: &amp;amp;, value:
2018-05-01 17:14:52.959646+0800 RuntimeDemo[24515:910260] attribute name: N, value:
2018-05-01 17:14:52.959847+0800 RuntimeDemo[24515:910260] attribute name: V, value: _age
2018-05-01 17:14:52.960024+0800 RuntimeDemo[24515:910260] propertyName: sex, attribute: TQ,N,V_sex
2018-05-01 17:14:52.960186+0800 RuntimeDemo[24515:910260] attribute name: T, value: Q
2018-05-01 17:14:52.960365+0800 RuntimeDemo[24515:910260] attribute name: N, value:
2018-05-01 17:14:52.960584+0800 RuntimeDemo[24515:910260] attribute name: V, value: _sex
2018-05-01 17:14:52.960737+0800 RuntimeDemo[24515:910260] propertyName: address, attribute: T@&amp;quot;NSString&amp;quot;,C,N,V_address
2018-05-01 17:14:52.960928+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSString&amp;quot;
2018-05-01 17:14:52.961101+0800 RuntimeDemo[24515:910260] attribute name: C, value:
2018-05-01 17:14:52.961274+0800 RuntimeDemo[24515:910260] attribute name: N, value:
2018-05-01 17:14:52.961463+0800 RuntimeDemo[24515:910260] attribute name: V, value: _address
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;T 是固定的，放在第一个
@”NSString” 代表这个property是一个字符串对象
&amp;amp; 代表强引用，其中与之并列的是：’C’代表Copy，’&amp;amp;’代表强引用，’W’表示weak，assign为空，默认为assign。R 代表readOnly属性，readwrite时为空
N 区分的nonatomic和atomic，默认为atomic，atomic为空，’N’代表是nonatomic
V_exprice V代表变量，后面紧跟着的是成员变量名，代表这个property的成员变量名为_exprice
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/qxuewei/XWResources/master/images/runtime_property_attrit.png&#34; alt=&#34;property_getAttributes 说明&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;323-协议相关函数&#34;&gt;3.2.3 协议相关函数&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 添加协议
BOOL class_addProtocol ( Class cls, Protocol *protocol );
 
// 返回类是否实现指定的协议
BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );
 
// 返回类实现的协议列表
Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试协议&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;@protocol PeopleProcol &amp;lt;NSObject&amp;gt;
@end

- (void)testProtocol {
    // 添加协议
    Protocol *p = @protocol(PeopleProcol);
    if (class_addProtocol([People class], p)) {
        NSLog(@&amp;quot;Add Protoclol Success&amp;quot;);
    }else{
        NSLog(@&amp;quot;Add protocol Fail&amp;quot;);
    }
    if (class_conformsToProtocol([People class], p)) {
        NSLog(@&amp;quot;实现了 PeopleProcol 协议&amp;quot;);
    }else{
        NSLog(@&amp;quot;没有实现 PeopleProcol 协议&amp;quot;);
    }
    unsigned int outCount;
    Protocol *__unsafe_unretained *protocolList = class_copyProtocolList([People class], &amp;amp;outCount);
    for (unsigned int i = 0; i &amp;lt; outCount; i++) {
        Protocol *p = protocolList[i];
        const char *protocolName = protocol_getName(p);
        NSLog(@&amp;quot;协议名称: %s&amp;quot;,protocolName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
2018-05-01 17:29:12.580433+0800 RuntimeDemo[25007:940310] Add Protoclol Success
2018-05-01 17:29:12.580591+0800 RuntimeDemo[25007:940310] 实现了 PeopleProcol 协议
2018-05-01 17:29:12.580707+0800 RuntimeDemo[25007:940310] 协议名称: PeopleProcol
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;324-版本号&#34;&gt;3.2.4 版本号&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- (void)testVersion {
    int version = class_getVersion([People class]);
    NSLog(@&amp;quot;version %d&amp;quot;,version);
    
    class_setVersion([People class], 10086);
    
    int nerVersion = class_getVersion([People class]);
    NSLog(@&amp;quot;nerVersion %d&amp;quot;,nerVersion);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2018-05-01 17:38:29.593821+0800 RuntimeDemo[25266:956588] version 0
2018-05-01 17:38:29.593972+0800 RuntimeDemo[25266:956588] nerVersion 10086
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-动态创建类和对象&#34;&gt;3.3 动态创建类和对象&lt;/h3&gt;
&lt;h4 id=&#34;331-动态创建类&#34;&gt;3.3.1. 动态创建类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 创建一个新类和元类
Class objc_allocateClassPair (Class superclass, const char *name, size_t extraBytes);

// 销魂一个类及其相关联的类
void objc_disposeClassPair (Class cls);

// 在应用中注册由objc_allocateClassPair创建类
void objc_registerClassPair (Class cls);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;（1）objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。&lt;/p&gt;
&lt;p&gt;（2）为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。&lt;/p&gt;
&lt;p&gt;（3）实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。&lt;/p&gt;
&lt;p&gt;（4）objc_disposeClassPair只能销毁由objc_allocateClassPair创建的类，当有实例存在或者它的子类存在时，调用这个函数会抛出异常。&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objctive-c&#34;&gt;- (void)testAddClass {
    Class TestClass = objc_allocateClassPair([NSObject class], &amp;quot;myClass&amp;quot;, 0);
    if (class_addIvar(TestClass, &amp;quot;myIvar&amp;quot;, sizeof(NSString *), sizeof(NSString *), &amp;quot;@&amp;quot;)) {
        NSLog(@&amp;quot;Add Ivar Success&amp;quot;);
    }
    class_addMethod(TestClass, @selector(method1:), (IMP)method0, &amp;quot;v@:&amp;quot;);
    // 注册这个类到runtime才可使用
    objc_registerClassPair(TestClass);
    
    // 生成一个实例化对象
    id myObjc = [[TestClass alloc] init];
    NSString *str = @&amp;quot;qiuxuewei&amp;quot;;
    //给刚刚添加的变量赋值
    //object_setInstanceVariable(myobj, &amp;quot;myIvar&amp;quot;, (void *)&amp;amp;str);在ARC下不允许使用
    [myObjc setValue:str forKey:@&amp;quot;myIvar&amp;quot;];
    [myObjc method1:10086];
}
- (void)method1:(int)a {
}
void method0(id self, SEL _cmd, int a) {
    Ivar v = class_getInstanceVariable([self class], &amp;quot;myIvar&amp;quot;);
    id o = object_getIvar(self, v);
    NSLog(@&amp;quot;%@ \n int a is %d&amp;quot;, o,a);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2018-05-01 22:30:30.159096+0800 RuntimeDemo[31292:1162987] Add Ivar Success
2018-05-01 22:30:30.159344+0800 RuntimeDemo[31292:1162987] qiuxuewei 
 int a is 10086
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;332-动态创建对象&#34;&gt;3.3.2. 动态创建对象&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 创建类的实例
id class_createInstance (Class cls, size_t extraBytes);

// 在指定位置创建类实例
id objc_constructInstance (Class cls, void *bytes);

// 销毁类实例
void * objc_destructInstance (id obj);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。&lt;/p&gt;
&lt;p&gt;调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)testCreteInstance {
    id testInstance = class_createInstance([NSString class], sizeof(unsigned));
    id str1 = [testInstance init];
    NSLog(@&amp;quot;%@&amp;quot;,[str1 class]);
    id str2 = [[NSString alloc] initWithString: @&amp;quot;Test&amp;quot;];
    NSLog(@&amp;quot;%@&amp;quot;,[str2 class]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2018-05-01 23:43:25.941205+0800 RuntimeDemo[32783:1223167] NSString
2018-05-01 23:43:25.941364+0800 RuntimeDemo[32783:1223167] __NSCFConstantString
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;333-其他类和对象相关的操作函数&#34;&gt;3.3.3. 其他类和对象相关的操作函数&lt;/h4&gt;
&lt;p&gt;类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取已注册的类定义的列表
int objc_getClassList(Class *buffer, int bufferCount);

// 创建并返回一个指向所有已注册类的指针列表
Class * objc_copyClassList (unsigned int * outCount);

// 返回指定类的类定义
Class objc_lookUpClass ( const char *name );
Class objc_getClass ( const char *name );
Class objc_getRequiredClass ( const char *name );
 
// 返回指定类的元类
Class objc_getMetaClass ( const char *name );

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;
// 返回指定对象的一份拷贝
id object_copy ( id obj, size_t size );
 
// 释放指定对象占用的内存
id object_dispose ( id obj );

// 修改类实例的实例变量的值
Ivar object_setInstanceVariable ( id obj, const char *name, void *value );
 
// 获取对象实例变量的值
Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );
 
// 返回指向给定对象分配的任何额外字节的指针
void * object_getIndexedIvars ( id obj );
 
// 返回对象中实例变量的值
id object_getIvar ( id obj, Ivar ivar );
 
// 设置对象中实例变量的值
void object_setIvar ( id obj, Ivar ivar, id value );

// 返回给定对象的类名
const char * object_getClassName ( id obj );
 
// 返回对象的类
Class object_getClass ( id obj );
 
// 设置对象的类
Class object_setClass ( id obj, Class cls );

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取类的定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取已注册的类定义的列表
int objc_getClassList (Class *)

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;334-应用实例&#34;&gt;3.3.4. 应用实例&lt;/h4&gt;
&lt;h5 id=&#34;1-json-转-model&#34;&gt;1. Json 转 Model&lt;/h5&gt;
&lt;p&gt;操作函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (instancetype)initWithDict:(NSDictionary *)dict {
    if (self = [self init]) {
        NSMutableArray &amp;lt;NSString *&amp;gt;*keys = [NSMutableArray array];
        NSMutableArray &amp;lt;NSString *&amp;gt;*attributes = [NSMutableArray array];
        
        unsigned int outCount;
        objc_property_t * propertyList = class_copyPropertyList([self class], &amp;amp;outCount);
        for (unsigned int i = 0; i &amp;lt; outCount; i++) {
            objc_property_t property = propertyList[i];
            const char *name = property_getName(property);
            NSString *propertyName = [NSString stringWithCString:name encoding:NSUTF8StringEncoding];
            [keys addObject:propertyName];
            
            const char *attribute = property_getAttributes(property);
            NSString *attributeName = [NSString stringWithCString:attribute encoding:NSUTF8StringEncoding];
            [attributes addObject:attributeName];
        }
        free(propertyList);
        for (NSString *key in keys) {
            if ([dict valueForKey:key]) {
                [self setValue:[dict valueForKey:key] forKey:key];
            }
        }
    }
    return self;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-快速归解档&#34;&gt;2. 快速归解档&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;遵循 NSCoding 协议
// 归档
- (instancetype)initWithCoder:(NSCoder *)aDecoder {
    if (self = [super init]) {
        unsigned int outCount;
        Ivar * ivarList = class_copyIvarList([self class], &amp;amp;outCount);
        for (unsigned int i = 0; i &amp;lt; outCount; i++) {
            Ivar ivar = ivarList[i];
            NSString *key = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding];
            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];
        }
    }
    return self;
}
// 解档
- (void)encodeWithCoder:(NSCoder *)aCoder {
    unsigned int outCount;
    Ivar * ivarList = class_copyIvarList([self class], &amp;amp;outCount);
    for (unsigned int i = 0; i &amp;lt; outCount; i++) {
        Ivar ivar = ivarList[i];
        NSString *key = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding];
        [aCoder encodeObject:[self valueForKey:key] forKey:key];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)testCoder {
    NSString *key = @&amp;quot;peopleKey&amp;quot;;
    People * people = [[People alloc] init];
    people.name = @&amp;quot;邱学伟&amp;quot;;
    people.age = @18;
    NSData *peopleData = [NSKeyedArchiver archivedDataWithRootObject:people];
    [[NSUserDefaults standardUserDefaults] setObject:peopleData forKey:key];
    
    NSData *testData = [[NSUserDefaults standardUserDefaults] objectForKey:key];
    People *testPeople = [NSKeyedUnarchiver unarchiveObjectWithData:testData];
    NSLog(@&amp;quot;%@&amp;quot;,testPeople.name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3-关联对象&#34;&gt;3. 关联对象&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 关联对象
void objc_setAssociatedObject (id object, const void * key, id value, objc_AssociationPolicy policy);

// 获取关联的对象
id objc_getAssociatedObject (id object, const void * key);

// 移除关联的对象
void objc_removeAssociatedObjects (id object);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;id object : 被关联的对象 
const void *key : 关联的key， set和get 需统一
id value : 关联的对象
objc_AssociationPolicy policy : 内存管理的策略
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;objc_AssociationPolicy policy的enum值有：、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;
typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {

    OBJC_ASSOCIATION_ASSIGN = 0,           /**&amp;lt; Specifies a weak reference to the associated object. */
    
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&amp;lt; Specifies a strong reference to the associated object. 
                                            *   The association is not made atomically. */
    
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&amp;lt; Specifies that the associated object is copied. 
                                            *   The association is not made atomically. */
    
    OBJC_ASSOCIATION_RETAIN = 01401,       /**&amp;lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    
    OBJC_ASSOCIATION_COPY = 01403          /**&amp;lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */

};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应用实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//
//  People+Category.h
//  RuntimeDemo
//
//  Created by 邱学伟 on 2018/5/3.
//  Copyright © 2018年 邱学伟. All rights reserved.
//

#import &amp;quot;People.h&amp;quot;
@interface People (Category)
/**
 新增属性
 */
@property (nonatomic, copy) NSString *blog;
@end

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//
//  People+Category.m
//  RuntimeDemo
//
//  Created by 邱学伟 on 2018/5/3.
//  Copyright © 2018年 邱学伟. All rights reserved.
//

#import &amp;quot;People+Category.h&amp;quot;
#import &amp;lt;objc/runtime.h&amp;gt;
@implementation People (Category)
static const char * cPeopleBlogKey = &amp;quot;cPeopleBlogKey&amp;quot;;
- (NSString *)blog {
    return objc_getAssociatedObject(self, cPeopleBlogKey);
}
- (void)setBlog:(NSString *)blog {
    objc_setAssociatedObject(self, cPeopleBlogKey, blog, OBJC_ASSOCIATION_COPY);
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-方法与消息&#34;&gt;4. 方法与消息&lt;/h2&gt;
&lt;h3 id=&#34;41-sel&#34;&gt;4.1 SEL&lt;/h3&gt;
&lt;p&gt;SEL 又叫方法选择器， 是表示一个方法的selector的指针，其定义如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;typedef  struct objc_selector *SEL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法的selector用于表示运行时方法的名字，Objective-C在编译时，会根据每一个方法的名字，参数序列，生成一个唯一的整型标示（Int类型的地址），这个标识就是SEL. 如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;+ (void)load {
    SEL sel = @selector(testMethod);
    NSLog(@&amp;quot;Programmer sel = %p&amp;quot;,sel);
}
- (void)testMethod {
    NSLog(@&amp;quot;testMethod&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差.&lt;br&gt;
当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。&lt;/p&gt;
&lt;p&gt;本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。&lt;/p&gt;
&lt;p&gt;我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:&lt;/p&gt;
&lt;p&gt;（1）sel_registerName函数&lt;/p&gt;
&lt;p&gt;（2）Objective-C编译器提供的@selector()&lt;/p&gt;
&lt;p&gt;（3）NSSelectorFromString()方法&lt;/p&gt;
&lt;h3 id=&#34;42-imp&#34;&gt;4.2 IMP&lt;/h3&gt;
&lt;p&gt;IMP 是一个函数指针，指向方法实现的首地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id (*IMP)(id,SEL,...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。&lt;/p&gt;
&lt;p&gt;前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。&lt;/p&gt;
&lt;p&gt;通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。&lt;/p&gt;
&lt;h3 id=&#34;43-method&#34;&gt;4.3 Method&lt;/h3&gt;
&lt;p&gt;Method 用于表示类定义中的方法，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;typedef struct objc_method *Method;

struct objc_method {
     SEL method_name OBJC2_UNAVAILABLE; // 方法名
     char *method_types OBJC2_UNAVAILABLE; //是个char指针，存储着方法的参数类型和返回值类型
     IMP method_imp OBJC2_UNAVAILABLE; // 方法实现，函数指针
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。&lt;/p&gt;
&lt;h3 id=&#34;44-objc_method_description&#34;&gt;4.4 objc_method_description&lt;/h3&gt;
&lt;p&gt;objc_method_description定义了一个Objective-C方法，其定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;struct objc_method_description { SEL name; char *types; };
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;45-method-相关操作函数&#34;&gt;4.5 Method 相关操作函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt; // 调用指定方法的实现
    id method_invoke (id receiver, Method m, ...);
    
    // 调用返回一个数据结构的方法的实现
    void method_invoke_stret (id receiver, Method m, ...);
    
    // 获取方法名
    SEL method_getName (Method m);
    
    // 获取方法的实现
    IMP method_getImplementation (Method m);
    
    // 获取描述方法参数和返回值类型的字符串
    const char * method_getTypeEncoding (Method m);
    
    // 获取方法的返回值类型的字符串
    char * method_copyReturnType ( Method m );
    
    // 获取方法的指定位置参数的类型字符串
    char * method_copyArgumentType ( Method m, unsigned int index );
    
    // 通过引用返回方法的返回值类型字符串
    void method_getReturnType ( Method m, char *dst, size_t dst_len );
    
    // 返回方法的参数的个数
    unsigned int method_getNumberOfArguments ( Method m );
    
    // 通过引用返回方法指定位置参数的类型字符串
    void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );
    
    // 返回指定方法的方法描述结构体
    struct objc_method_description * method_getDescription ( Method m );
    
    // 设置方法的实现
    IMP method_setImplementation ( Method m, IMP imp );
    
    // 交换两个方法的实现
    void method_exchangeImplementations ( Method m1, Method m2 );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（1）method_invoke函数，返回的是实际实现的返回值。参数receiver不能为空。这个方法的效率会比method_getImplementation和method_getName更快。&lt;/p&gt;
&lt;p&gt;（2）method_getName函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用sel_getName(method_getName(method))。&lt;/p&gt;
&lt;p&gt;（3）method_getReturnType函数，类型字符串会被拷贝到dst中。&lt;/p&gt;
&lt;p&gt;（4）method_setImplementation函数，注意该函数返回值是方法之前的实现。&lt;/p&gt;
&lt;h3 id=&#34;46-方法选择器&#34;&gt;4.6 方法选择器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 返回给定选择器指定的方法的名称
const char * sel_getName ( SEL sel );

// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器
SEL sel_registerName ( const char *str );

// 在Objective-C Runtime系统中注册一个方法
SEL sel_getUid ( const char *str );

// 比较两个选择器
BOOL sel_isEqual ( SEL lhs, SEL rhs );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sel_registerName函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。&lt;/p&gt;
&lt;h3 id=&#34;47-方法调用流程&#34;&gt;4.7 方法调用流程&lt;/h3&gt;
&lt;h4 id=&#34;1-消息发送&#34;&gt;1. 消息发送&lt;/h4&gt;
&lt;p&gt;在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(receiver, selector)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果消息中还有其他参数，则该方法的形式如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(receiver, selector，arg1, arg2, ...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数完成了动态绑定的所有事情：&lt;/p&gt;
&lt;p&gt;（1）首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。&lt;/p&gt;
&lt;p&gt;（2）它调用方法实现，并将接收者对象及方法的所有参数传给它。&lt;/p&gt;
&lt;p&gt;（3）最后，它将实现返回的值作为它自己的返回值。&lt;/p&gt;
&lt;p&gt;消息的关键在于结构体 objc_class, 这个结构体有两个字段是我们在分发消息的时候关注的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指向父类的指针。&lt;/li&gt;
&lt;li&gt;一个类的方法分发表，即methodLists&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。&lt;/p&gt;
&lt;p&gt;下图演示了这样一个消息的基本框架：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/qxuewei/XWResources/master/images/runtime_msgSend.gif&#34; alt=&#34;消息的基本框架&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程&lt;/p&gt;
&lt;h4 id=&#34;2-隐藏参数&#34;&gt;2. 隐藏参数&lt;/h4&gt;
&lt;p&gt;objc_msgSend 有两个隐藏参数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息接收对象&lt;/li&gt;
&lt;li&gt;方法的selector&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为他们在定义方法的源代码中没有声明。他们是在编译时被插入实现代码的。&lt;/p&gt;
&lt;p&gt;虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用_cmd 来引用选择器。如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- strange
{
    id  target = getTheReceiver();
    SEL method = getTheMethod();
    if ( target == self || method == _cmd )
        return nil;
    return [target performSelector:method];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，这两个参数我们用的比较多的是self，_cmd 在实际中用得比较少。&lt;/p&gt;
&lt;h4 id=&#34;3-获取方法地址&#34;&gt;3. 获取方法地址&lt;/h4&gt;
&lt;p&gt;Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。&lt;/p&gt;
&lt;p&gt;我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。&lt;/p&gt;
&lt;p&gt;NSObject类提供了methodForSelector:方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将methodForSelector:返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。&lt;/p&gt;
&lt;p&gt;这里需要注意的就是函数指针的前两个参数必须是id和SEL。&lt;/p&gt;
&lt;p&gt;当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，methodForSelector:是由Cocoa运行时提供的；它不是Objective-C语言的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)testCommonMethod {
    for (int i = 0; i &amp;lt; 10000; i++) {
        [self logMethod:i];
    }
    //执行时长: Test Case &#39;-[RuntimeDemoTests testCommonMethod]&#39; passed (2.311 seconds).
}

- (void)testRuntimeMethod {
    void(*logM)(id, SEL, int);
    IMP imp = [self methodForSelector:@selector(logMethod:)];
    logM = (void(*)(id, SEL, int))imp;
    for (int i = 0; i &amp;lt; 10000; i++) {
        logM(self, @selector(logMethod:), i);
    }
    //执行时长: Test Case &#39;-[RuntimeDemoTests testRuntimeMethod]&#39; passed (2.199 seconds).
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-消息转发&#34;&gt;4. 消息转发&lt;/h4&gt;
&lt;p&gt;当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。&lt;/p&gt;
&lt;p&gt;通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// perform方法要求传入参数必须是对象，如果方法本身的参数是int，直接传NSNumber会导致得到的int参数不正确
if ([self respondsToSelector:@selector(logMethod:)]) {
        [self performSelector:@selector(logMethod:) withObject:[NSNumber numberWithInt:10086]];
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当一个对象无法接收某一消息时，就会启动所谓”消息转发(message forwarding)“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unrecognized selector sent to instance 0x100111940&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。&lt;/p&gt;
&lt;p&gt;消息转发机制基本上分为三个步骤：&lt;/p&gt;
&lt;p&gt;（1）动态方法解析&lt;/p&gt;
&lt;p&gt;（2）备用接收者&lt;/p&gt;
&lt;p&gt;（3）完整转发&lt;/p&gt;
&lt;h5 id=&#34;1-动态方法解析&#34;&gt;1.  动态方法解析&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;void functionForMethod (id self, SEL _cmd) {
    NSLog(@&amp;quot;functionForMethod&amp;quot;);
}
/// 调用未实现对象方法
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    NSString *selName = NSStringFromSelector(sel);
    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {
        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);
        return YES;
    }
    return [super resolveClassMethod:sel];
}
/// 调用未实现类方法
+ (BOOL)resolveClassMethod:(SEL)sel {
    NSString *selName = NSStringFromSelector(sel);
    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {
        //v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html
        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);
        return YES;
    }
    return [super resolveClassMethod:sel];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-备用接受者&#34;&gt;2.  备用接受者&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;如果在上一步无法处理消息，则Runtime会继续调以下方法：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。&lt;/p&gt;
&lt;p&gt;使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//
//  People.m
//  RuntimeDemo
//
//  Created by 邱学伟 on 2018/4/27.
//  Copyright © 2018年 邱学伟. All rights reserved.
//

#import &amp;quot;People.h&amp;quot;
#import &amp;lt;objc/runtime.h&amp;gt;

@interface XWPeople : NSObject
- (void)people2log;
@end
@implementation XWPeople
- (void)people2log {
    NSLog(@&amp;quot;people2log&amp;quot;);
}
@end

@interface People () &amp;lt;NSCoding&amp;gt; {
}
@property (nonatomic, strong) XWPeople *xw_people;
@end
@implementation People

//// 1 级处理
void functionForMethod (id self, SEL _cmd) {
    NSLog(@&amp;quot;functionForMethod&amp;quot;);
}
/// 调用未实现对象方法
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    NSString *selName = NSStringFromSelector(sel);
    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {
        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);
        return YES;
    }
    return [super resolveClassMethod:sel];
}
/// 调用未实现类方法
+ (BOOL)resolveClassMethod:(SEL)sel {
    NSString *selName = NSStringFromSelector(sel);
    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {
        //v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html
        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);
        return YES;
    }
    return [super resolveClassMethod:sel];
}

/// 2 级处理
- (id)forwardingTargetForSelector:(SEL)aSelector {
    NSString *selName = NSStringFromSelector(aSelector);
    if ([selName isEqualToString:@&amp;quot;people2log&amp;quot;]) {
        return self.xw_people;
    }
    return [super forwardingTargetForSelector:aSelector];
}
- (XWPeople *)xw_people {
    if(!_xw_people){
        _xw_people = [[XWPeople alloc] init];
    }
    return _xw_people;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。&lt;/p&gt;
&lt;h5 id=&#34;3-完整转发&#34;&gt;3.  完整转发&lt;/h5&gt;
&lt;p&gt;如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象。&lt;/p&gt;
&lt;p&gt;forwardInvocation:方法的实现有两个任务：&lt;/p&gt;
&lt;p&gt;（1）定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。&lt;/p&gt;
&lt;p&gt;（2）使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。&lt;/p&gt;
&lt;p&gt;不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。&lt;/p&gt;
&lt;p&gt;还有一个很重要的问题，我们必须重写以下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。&lt;/p&gt;
&lt;p&gt;完整的示例如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//
//  People.m
//  RuntimeDemo
//
//  Created by 邱学伟 on 2018/4/27.
//  Copyright © 2018年 邱学伟. All rights reserved.
//

#import &amp;quot;People.h&amp;quot;
#import &amp;lt;objc/runtime.h&amp;gt;

@interface XWPeople : NSObject
- (void)people2log;
- (void)people3log;
@end
@implementation XWPeople
- (void)people2log {
    NSLog(@&amp;quot;people2log&amp;quot;);
}

- (void)people3log {
    NSLog(@&amp;quot;people3log&amp;quot;);
}
@end

@interface People () &amp;lt;NSCoding&amp;gt; {
}
@property (nonatomic, strong) XWPeople *xw_people;
@end
@implementation People

//// 1 级处理
void functionForMethod (id self, SEL _cmd) {
    NSLog(@&amp;quot;functionForMethod&amp;quot;);
}
/// 调用未实现对象方法
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    NSString *selName = NSStringFromSelector(sel);
    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {
        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);
        return YES;
    }
    return [super resolveClassMethod:sel];
}
/// 调用未实现类方法
+ (BOOL)resolveClassMethod:(SEL)sel {
    NSString *selName = NSStringFromSelector(sel);
    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {
        //v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html
        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);
        return YES;
    }
    return [super resolveClassMethod:sel];
}

/// 2 级处理
- (id)forwardingTargetForSelector:(SEL)aSelector {
    NSString *selName = NSStringFromSelector(aSelector);
    if ([selName isEqualToString:@&amp;quot;people2log&amp;quot;]) {
        return self.xw_people;
    }
    return [super forwardingTargetForSelector:aSelector];
}
- (XWPeople *)xw_people {
    if(!_xw_people){
        _xw_people = [[XWPeople alloc] init];
    }
    return _xw_people;
}

/// 3 级处理
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];
    if (!signature) {
        if ([XWPeople instancesRespondToSelector:aSelector]) {
            signature = [XWPeople instanceMethodSignatureForSelector:aSelector];
        }
    }
    return signature;
}
- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([XWPeople instancesRespondToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:self.xw_people];
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。&lt;/p&gt;
&lt;p&gt;从某种意义上来讲，forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。&lt;/p&gt;
&lt;h5 id=&#34;4-消息转发与多重继承&#34;&gt;4、消息转发与多重继承&lt;/h5&gt;
&lt;p&gt;回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。&lt;/p&gt;
&lt;p&gt;不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如respondsToSelector:和isKindOfClass:只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (BOOL)respondsToSelector:(SEL)aSelector   {
       if ( [super respondsToSelector:aSelector] )         
       		return YES;     
       else {          
       		/* Here, test whether the aSelector message can     *            
      		 * be forwarded to another object and whether that  *            
      		* object can respond to it. Return YES if it can.  */      
       }
      return NO;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;46-method-swizzling&#34;&gt;4.6 Method Swizzling&lt;/h3&gt;
&lt;h4 id=&#34;461-概述&#34;&gt;4.6.1 概述&lt;/h4&gt;
&lt;p&gt;Objective-C 中的 Method Swizzling 是一项异常强大的技术，它可以允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。&lt;/p&gt;
&lt;h4 id=&#34;462-原理&#34;&gt;4.6.2 原理&lt;/h4&gt;
&lt;p&gt;Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。所以下面两个方法在 runtime 看来就是同一个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)viewWillAppear:(BOOL)animated;
- (void)viewWillAppear:(NSString *)string;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而下面两个方法却是可以共存的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)viewWillAppear:(BOOL)animated;
+ (void)viewWillAppear:(BOOL)animated;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为实例方法和类方法是分别保存在类对象和元类对象中的。&lt;/p&gt;
&lt;p&gt;原则上，方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的&lt;/p&gt;
&lt;p&gt;原有方法和实现的对应关系如下图：&lt;br&gt;
&lt;img src=&#34;https://github.com/qxuewei/XWResources/blob/master/images/Swizzling_1.png?raw=true&#34; alt=&#34;原有方法和实现的对应关系&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过runtime可实现：&lt;br&gt;
&lt;img src=&#34;https://github.com/qxuewei/XWResources/blob/master/images/Swizzling_2.png?raw=true&#34; alt=&#34;runtime 调整的对应关系&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在OC语言的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的SEL，这个SEL对应着一个IMP(一个IMP可以对应多个SEL)，通过这个IMP找到对应的方法调用。&lt;/p&gt;
&lt;p&gt;在每个类中都有一个Dispatch Table，这个Dispatch Table本质是将类中的SEL和IMP(可以理解为函数指针)进行对应。而我们的Method Swizzling就是对这个table进行了操作，让SEL对应另一个IMP。&lt;/p&gt;
&lt;h4 id=&#34;463-使用注意&#34;&gt;4.6.3 使用注意&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Swizzling应该总在+load中执行：Objective-C在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载&lt;/li&gt;
&lt;li&gt;Swizzling应该总是在dispatch_once中执行：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。&lt;/li&gt;
&lt;li&gt;Selector，Method和Implementation：这几个之间关系可以这样理解，一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个Method，其中key是一个特定的名称，及SEL，与其对应的实现是IMP即指向底层C函数的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;464-应用实例&#34;&gt;4.6.4 应用实例&lt;/h4&gt;
&lt;h5 id=&#34;1-替换方法实现&#34;&gt;1. 替换方法实现&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//  ViewController+Method.m
//  RuntimeDemo
//
//  Created by 邱学伟 on 2018/5/4.
//  Copyright © 2018年 邱学伟. All rights reserved.
//

#import &amp;quot;ViewController+Method.h&amp;quot;
#import &amp;lt;objc/runtime.h&amp;gt;

@implementation ViewController (Method)
+ (void)load {
    [super load];
    [self exchangeMethod];
}

/// runtime 交换方法
+ (void)exchangeMethod {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        Class class = [self class];
        
        SEL originSel = @selector(viewWillAppear:);
        SEL swizzledSel = @selector(xw_viewWillAppear:);
        
        Method originMethod = class_getInstanceMethod(class, originSel);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSel);
        
        //先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况
        BOOL isAddMethod = class_addMethod(class, originSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
        if (isAddMethod) {
            class_replaceMethod(class, swizzledSel, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));
        }else{
            method_exchangeImplementations(originMethod, swizzledMethod);
        }
    });
}
- (void)xw_viewWillAppear:(BOOL)animation {
    [self xw_viewWillAppear:animation];
    NSLog(@&amp;quot;xw_viewWillAppear - %@&amp;quot;,self);
}
@end

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-method-swizzling类簇&#34;&gt;2、Method Swizzling类簇&lt;/h5&gt;
&lt;p&gt;在我们项目开发过程中，经常因为NSArray数组越界或者NSDictionary的key或者value值为nil等问题导致的崩溃，我们可以尝试使用前面知识对NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等类进行Method Swizzling，但是结果发现Method Swizzling根本就不起作用，到底为什么呢？&lt;/p&gt;
&lt;p&gt;这是因为Method Swizzling对NSArray这些的类簇是不起作用的。因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用NSArray的objectAtIndex:方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。&lt;/p&gt;
&lt;p&gt;所以也就是我们对NSArray类进行操作其实只是对父类进行了操作，在NSArray内部会创建其他子类来执行操作，真正执行操作的并不是NSArray自身，所以我们应该对其“真身”进行操作。&lt;/p&gt;
&lt;p&gt;下面我们实现了防止NSArray因为调用objectAtIndex:方法，取下标时数组越界导致的崩溃：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &amp;quot;NSArray+ MyArray.h&amp;quot;
#import &amp;quot;objc/runtime.h&amp;quot;
@implementation NSArray MyArray)
+ (void)load {
    Method fromMethod = class_getInstanceMethod(objc_getClass(&amp;quot;__NSArrayI&amp;quot;), @selector(objectAtIndex:));
    Method toMethod = class_getInstanceMethod(objc_getClass(&amp;quot;__NSArrayI&amp;quot;), @selector(my_objectAtIndex:));
    method_exchangeImplementations(fromMethod, toMethod);
}

- (id)my_objectAtIndex:(NSUInteger)index {
    if (self.count-1 &amp;lt; index) {
        // 这里做一下异常处理，不然都不知道出错了。
        @try {
            return [self my_objectAtIndex:index];
        }
        @catch (NSException *exception) {
            // 在崩溃后会打印崩溃信息，方便我们调试。
            NSLog(@&amp;quot;---------- %s Crash Because Method %s  ----------\n&amp;quot;, class_getName(self.class), __func__);
            NSLog(@&amp;quot;%@&amp;quot;, [exception callStackSymbols]);
            return nil;
    }
        @finally {}
    } else {
        return [self my_objectAtIndex:index];
    }
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见类簇真身：&lt;br&gt;
&lt;img src=&#34;https://github.com/qxuewei/XWResources/blob/master/images/runtime_%E7%B1%BB%E7%B0%87%E7%9C%9F%E8%BA%AB.png?raw=true&#34; alt=&#34;类簇&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-protocol-和-category&#34;&gt;5. Protocol 和 Category&lt;/h2&gt;
&lt;h3 id=&#34;51-category&#34;&gt;5.1 Category&lt;/h3&gt;
&lt;p&gt;指向分类的结构体的指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;typedef struct objc_category *Category;

struct objc_category {
     char *category_name OBJC2_UNAVAILABLE; // 分类名
     char *class_name OBJC2_UNAVAILABLE; // 分类所属的类名
     struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表
     struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表，Meta Class方法列表的子集
     struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 分类所实现的协议列表
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//
//  main.m
//  RuntimeDemo
//
//  Created by 邱学伟 on 2018/4/27.
//  Copyright © 2018年 邱学伟. All rights reserved.
//

#import &amp;lt;UIKit/UIKit.h&amp;gt;
#import &amp;quot;AppDelegate.h&amp;quot;

@interface NSObject (Fuck)
+ (void)foo;
@end

@implementation NSObject (Fuck)
- (void)foo {
    NSLog(@&amp;quot;我是Foo %@&amp;quot;,[self class]);
}
@end

int main(int argc, char * argv[]) {
    @autoreleasepool {
        
        [NSObject foo];
        [[NSObject new] foo];
        
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2018-05-04 16:23:26.643100+0800 RuntimeDemo[48558:2377362] 我是Foo NSObject
2018-05-04 16:23:26.644354+0800 RuntimeDemo[48558:2377362] 我是Foo NSObject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;objc runtime加载后NSObject的Sark Category被加载，头文件+(void)foo没有IMP，只会出现一个warning。被加到Class的Method list里的方法只有-(void)foo，Meta Class的方法列表里没有。&lt;/p&gt;
&lt;p&gt;执行[NSObject foo]时，会在Meta Class的Method list里找，找不着就继续往super class里找，NSObject Meta Clas的super class是NSObject本身，这时在NSObject的Method list里就有foo这个方法了，能够正常输出。&lt;/p&gt;
&lt;p&gt;执行[[NSObject new] foo]就简单的多了，[NSObject new]生成一个实例，实例的Method list是有foo方法的，于是正常输出。&lt;/p&gt;
&lt;p&gt;如果换做其他类就会报错了&lt;/p&gt;
&lt;h3 id=&#34;52-protocol&#34;&gt;5.2 Protocol&lt;/h3&gt;
&lt;p&gt;Protocol其实就是一个对象结构体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct objc_object Protocol;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 返回指定的协议
Protocol * objc_getProtocol ( const char *name );
// 获取运行时所知道的所有协议的数组
Protocol ** objc_copyProtocolList ( unsigned int *outCount );
// 创建新的协议实例
Protocol * objc_allocateProtocol ( const char *name );
// 在运行时中注册新创建的协议
void objc_registerProtocol ( Protocol *proto ); //创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。
// 为协议添加方法
void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );
// 添加一个已注册的协议到协议中
void protocol_addProtocol ( Protocol *proto, Protocol *addition );
// 为协议添加属性
void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );
// 返回协议名
const char * protocol_getName ( Protocol *p );
// 测试两个协议是否相等
BOOL protocol_isEqual ( Protocol *proto, Protocol *other );
// 获取协议中指定条件的方法的方法描述数组
struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );
// 获取协议中指定方法的方法描述
struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );
// 获取协议中的属性列表
objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );
// 获取协议的指定属性
objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );
// 获取协议采用的协议
Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );
// 查看协议是否采用了另一个协议
BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-补充&#34;&gt;6. 补充&lt;/h2&gt;
&lt;h3 id=&#34;61-super&#34;&gt;6.1 Super&lt;/h3&gt;
&lt;p&gt;在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到super，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;@interface MyViewController: UIViewController
@end
@implementation MyViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    // do something
    ...
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;struct objc_super { id receiver; Class superClass; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个结构体有两个成员：&lt;/p&gt;
&lt;p&gt;（1）receiver：即消息的实际接收者&lt;/p&gt;
&lt;p&gt;（2）superClass：指针当前类的父类&lt;/p&gt;
&lt;p&gt;当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是MyViewController对象，与self相同；superClass指向MyViewController的父类UIViewController。&lt;/p&gt;
&lt;p&gt;接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc-&amp;gt;receiver去调用这个selector，而此时的操作就是如下方式了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;objc_msgSend(objc_super-&amp;gt;receiver, @selector(viewDidLoad))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于objc_super-&amp;gt;receiver就是self本身，所以该方法实际与下面这个调用是相同的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;objc_msgSend(self, @selector(viewDidLoad))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;+ (void)load {
    [super load];
    NSLog(@&amp;quot;self class: %@&amp;quot;, self.class);
    NSLog(@&amp;quot;super class: %@&amp;quot;, super.class);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2018-05-04 15:19:45.264902+0800 RuntimeDemo[47032:2208798] self class: ViewController
2018-05-04 15:19:45.265792+0800 RuntimeDemo[47032:2208798] super class: ViewController

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;62-库相关操作&#34;&gt;6.2 库相关操作&lt;/h3&gt;
&lt;p&gt;库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 获取所有加载的Objective-C框架和动态库的名称
const char ** objc_copyImageNames ( unsigned int *outCount );

// 获取指定类所在动态库
const char * class_getImageName ( Class cls );

// 获取指定库或框架中所有类的类名
const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)testImage {
    NSLog(@&amp;quot;获取指定类所在动态库&amp;quot;);
    NSLog(@&amp;quot;UIView&#39;s Framework: %s&amp;quot;, class_getImageName(NSClassFromString(@&amp;quot;UIView&amp;quot;)));
    NSLog(@&amp;quot;获取指定库或框架中所有类的类名&amp;quot;);
    unsigned int outCount;
    const char ** classes = objc_copyClassNamesForImage(class_getImageName(NSClassFromString(@&amp;quot;UIView&amp;quot;)), &amp;amp;outCount);
    for (int i = 0; i &amp;lt; outCount; i++) {
        NSLog(@&amp;quot;class name: %s&amp;quot;, classes[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;2018-05-04 15:30:51.342342+0800 RuntimeDemo[47333:2253385] 获取指定类所在动态库
2018-05-04 15:30:51.342499+0800 RuntimeDemo[47333:2253385] UIView&#39;s Framework: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/UIKit.framework/UIKit
2018-05-04 15:30:51.342620+0800 RuntimeDemo[47333:2253385] 获取指定库或框架中所有类的类名
2018-05-04 15:30:51.343164+0800 RuntimeDemo[47333:2253385] class name: UIGestureKeyboardIntroduction
2018-05-04 15:30:51.343269+0800 RuntimeDemo[47333:2253385] class name: _UIPreviewPresentationPlatterView
2018-05-04 15:30:51.343364+0800 RuntimeDemo[47333:2253385] class name: UIKeyboardUISettings
2018-05-04 15:30:51.343456+0800 RuntimeDemo[47333:2253385] class name: _UIFocusScrollManager
2018-05-04 15:30:51.343550+0800 RuntimeDemo[47333:2253385] class name: _UIPickerViewTopFrame
2018-05-04 15:30:51.343655+0800 RuntimeDemo[47333:2253385] class name: _UIOnePartImageView
2018-05-04 15:30:51.343749+0800 RuntimeDemo[47333:2253385] class name: _UIPickerViewSelectionBar
。。。。。。。。。。。。。。。。。。。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;63-块操作&#34;&gt;6.3 块操作&lt;/h3&gt;
&lt;p&gt;我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 创建一个指针函数的指针，该函数调用时会调用特定的block
IMP imp_implementationWithBlock ( id block );

// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block
id imp_getBlock ( IMP anImp );

// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝
BOOL imp_removeBlock ( IMP anImp );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。如下代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)testBlock {
    IMP imp = imp_implementationWithBlock(^(id obj, NSString *str) {
        NSLog(@&amp;quot;testBlock - %@&amp;quot;,str);
    });
    class_addMethod(self.class, @selector(testBlock:), imp, &amp;quot;v@:@&amp;quot;);
    [self performSelector:@selector(testBlock:) withObject:@&amp;quot;邱学伟!&amp;quot;];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;2018-05-04 15:41:47.221228+0800 RuntimeDemo[47587:2282146] testBlock - 邱学伟!
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;64-弱引用操作&#34;&gt;6.4 弱引用操作&lt;/h3&gt;
&lt;p&gt;操作函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// 加载弱引用指针引用的对象并返回
id objc_loadWeak ( id *location );

// 存储__weak变量的新值
id objc_storeWeak ( id *location, id obj );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。&lt;/p&gt;
&lt;p&gt;objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。&lt;/p&gt;
">iOS - Runtime 详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/ios-xi-tong-zhong-de-suo/"" data-c="
          &lt;p&gt;多线程同时访问同一块资源会造成资源抢夺，容易引发数据错乱和数据安全问题，此时我们需要保证资源同时只有一个线程访问，加锁就是为了解决这个问题。&lt;/p&gt;
&lt;p&gt;常用的加锁方式：（性能由差到好）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OSSpinLock&lt;/code&gt; 自旋锁，存在优先级反转问题，破坏了 spinLock，后来Apple推出 &lt;code&gt;os_unfair_lock_t&lt;/code&gt; 解决优先级翻转问题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt; 信号量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_mutex&lt;/code&gt; 互斥锁 （C语言）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSLock&lt;/code&gt; 对象锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSCondition&lt;/code&gt; 条件锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt; 递归锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 条件锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@synchronized&lt;/code&gt; 性能最差&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;p&gt;各种锁的性能比较&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.06.11.15918541083583.15910531507405.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h2&gt;
&lt;h3 id=&#34;osspinlock-os_unfair_lock&#34;&gt;&#39;OSSpinLock&#39;、&#39;os_unfair_lock&#39;&lt;/h3&gt;
&lt;p&gt;&#39;OSSpinLock&#39; 是一种自旋锁，和互斥锁类似，都是为了保证线程安全的锁。对于互斥锁，当一个线程获得这个锁以后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放；自旋锁，当一个线程获得锁之后，其他线程将会一直循环查看该锁是否被释放，此锁适用于锁的持有者保存时间较短的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spinLock = OS_SPINLOCK_INIT;
OSSpinLockLock(&amp;amp;spinLock);
sleep(4);
OSSpinLockUnlock(&amp;amp;spinLock);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&#39;OSSpinLock&#39; 不再安全了？ 因为存在优先级翻转的问题。&lt;br&gt;
在新版本iOS系统中，系统维护了5个不同的线程优先级(Qos): background, utility, default, user-initiated, user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比他更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级翻转的问题，从而破坏 spin lock.&lt;/p&gt;
&lt;p&gt;实例：如果一个低优先级的线程获得锁并访问共享资源，此时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙时状态从而占用大量CPU，此时低优先级线程无法与高优先级线程抢夺CPU时间，从而导致任务迟迟无法完成，无法释放lock。&lt;/p&gt;
&lt;p&gt;为解决此问题，在iOS10，给出了新API：&lt;code&gt;os_unfair_lock&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;os_unfair_lock_t unfairLock = &amp;amp;(OS_UNFAIR_LOCK_INIT);
os_unfair_lock_lock(unfairLock);
sleep(4);
os_unfair_lock_unlock(unfairLock);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;信号量&#34;&gt;信号量&lt;/h2&gt;
&lt;h3 id=&#34;dispatch_semaphore&#34;&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt; 可以通过控制并发数实现锁机制。通过控制信号量的值为 0 或 1 来实现锁。&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt; 会使信号量-1，&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt; 会使信号量+1，信号量为0时线程等待，为1时方可继续执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;quot;Dispatch_Semaphore.h&amp;quot;
@interface Dispatch_Semaphore ()
{
    dispatch_semaphore_t _semaphore;
}
@property (nonatomic, strong) NSMutableArray *array;
@property (assign) NSUInteger index;
@end
@implementation Dispatch_Semaphore
- (instancetype)init {
    self = [super init];
    if (self) {
        /// 通道默认为1, 首次执行
        _semaphore = dispatch_semaphore_create(1);
    }
    return self;
}
- (void)run {
    for (NSUInteger i = 0; i &amp;lt; self.array.count; i++) {
        if (i % 2 == 0) {
            dispatch_async(dispatch_get_global_queue(0, 0), ^{
                [self log];
            });
        } else {
            dispatch_async(dispatch_get_global_queue(0, 0), ^{
                [self log];
            });
        }
    }
}
- (void)log {
    /// 通道 -1 阻塞其他线程进入
    dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&amp;quot;%@&amp;quot;,self.array[self.index++]);
    /// 通道+1 其他线程可进入
    dispatch_semaphore_signal(_semaphore);
}
- (NSMutableArray *)array {
    if(!_array){
        NSMutableArray *arrayM = [NSMutableArray array];
        for (NSUInteger i = 0; i &amp;lt; 1000; i++) {
            [arrayM addObject:@(i)];
        }
        _array = arrayM;
    }
    return _array;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;互斥锁&#34;&gt;互斥锁&lt;/h2&gt;
&lt;h3 id=&#34;pthread_mutex&#34;&gt;&lt;code&gt;pthread_mutex&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;quot;Phread_mutex.h&amp;quot;
#import &amp;lt;pthread.h&amp;gt;
@interface Phread_mutex ()
{
    pthread_mutex_t _mutex_t;
}
@property (nonatomic, strong) NSMutableArray *array;
@property (assign) NSUInteger index;
@end

@implementation Phread_mutex
- (instancetype)init {
    self = [super init];
    if (self) {
        /// 锁初始化
        pthread_mutex_t mutex_t = PTHREAD_MUTEX_INITIALIZER;
        _mutex_t = mutex_t;
    }
    return self;
}
- (void)run {
    for (NSUInteger i = 0; i &amp;lt; self.array.count; i++) {
        if (i % 2 == 0) {
            dispatch_async(dispatch_get_global_queue(0, 0), ^{
                [self log];
            });
        } else {
            dispatch_async(dispatch_get_global_queue(0, 0), ^{
                [self log];
            });
        }
    }
}
- (void)log {
    // 加互斥锁
    pthread_mutex_lock(&amp;amp;(_mutex_t));
    NSLog(@&amp;quot;%@&amp;quot;,self.array[self.index++]);
    // 解互斥锁
    pthread_mutex_unlock(&amp;amp;(_mutex_t));
}
- (NSMutableArray *)array {
    if(!_array){
        NSMutableArray *arrayM = [NSMutableArray array];
        for (NSUInteger i = 0; i &amp;lt; 1000; i++) {
            [arrayM addObject:@(i)];
        }
        _array = arrayM;
    }
    return _array;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nslock&#34;&gt;&lt;code&gt;NSLock&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NSLock&lt;/code&gt; 和 &lt;code&gt;NSRecursiveLock&lt;/code&gt;, &lt;code&gt;NSConditionLock&lt;/code&gt; 都是对 &lt;code&gt;pthread_mutex&lt;/code&gt; 的封装。&lt;/p&gt;
&lt;p&gt;NSLock 遵循 NSLocking 协议. lock 加锁，unlock 解锁，tryLock 尝试加锁，如果失败的话返回 NO，lockBeforeDate: 是在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSLocking&lt;/code&gt; 协议&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@protocol NSLocking

- (void)lock;
- (void)unlock;

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)log {
    // 加互斥锁
    [self.lock lock];
    NSLog(@&amp;quot;%@&amp;quot;,self.array[self.index++]);
    // 解互斥锁
    [self.lock unlock];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;条件锁&#34;&gt;条件锁&lt;/h2&gt;
&lt;h3 id=&#34;nsconditionlock&#34;&gt;&lt;code&gt;NSConditionLock&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 同样遵循了&lt;code&gt;NSLocking&lt;/code&gt; 协议，除此之外，还可以设置自定义条件来获得锁和释放锁.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;quot;NSConditionLockDemo.h&amp;quot;
@interface NSConditionLockDemo ()
@property (nonatomic, strong) NSMutableArray *images;
@property (assign) NSUInteger index;
@property (nonatomic, strong) NSConditionLock *conditionLock;
@end
@implementation NSConditionLockDemo
static const NSInteger lockTag = 10086;
static const NSInteger imageCount = 100;
- (instancetype)init {
    self = [super init];
    if (self) {
        self.conditionLock = [[NSConditionLock alloc] init];
    }
    return self;
}
- (void)run {
    for (NSUInteger i = 0; i &amp;lt; imageCount; i++) {
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            [self downloadImages];
        });
    }
    [self showImages];
}
/// 异步下载 imageCount 张图片
- (void)downloadImages {
    sleep(arc4random_uniform(5));
    [self.conditionLock lock];
    [self.images addObject:@(arc4random_uniform(100))];
    [self.conditionLock unlock];
    if (self.images.count == imageCount) {
        [self.conditionLock unlockWithCondition:lockTag];
    }
}
/// 展示下载好的 imageCount 张图片
- (void)showImages {
    [self.conditionLock lockWhenCondition:lockTag];
    [self.images enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@&amp;quot;show: %@&amp;quot;,obj);
    }];
    [self.conditionLock unlockWithCondition:lockTag];
}
- (NSMutableArray *)images {
    if(!_images){
        _images = [NSMutableArray array];
    }
    return _images;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;递归锁&#34;&gt;递归锁&lt;/h2&gt;
&lt;h3 id=&#34;nsrecursivelock&#34;&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@interface NSRecursiveLockDemo ()
@property (nonatomic, strong) NSRecursiveLock *recursiveLock;
@end

@implementation NSRecursiveLockDemo
- (instancetype)init {
    self = [super init];
    if (self) {
        self.recursiveLock = [[NSRecursiveLock alloc] init];
    }
    return self;
}
- (void)run {
    NSInteger n = 3;
    NSLog(@&amp;quot;%ld! = %ld&amp;quot;,(long)n, (long)[self sum:3]);
}
- (NSInteger)sum:(NSUInteger)n {
    [self.recursiveLock lock];
    NSInteger result = 0;
    if (n &amp;lt;= 1) {
        result = n;
    } else {
        result = [self sum:n - 1] * n;
    }
    [self.recursiveLock unlock];
    return result;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果将 &lt;code&gt;NSRecursiveLock&lt;/code&gt; 换成 &lt;code&gt;NSLock&lt;/code&gt; 就会造成死锁。&lt;/p&gt;
&lt;h3 id=&#34;synchronized&#34;&gt;&lt;code&gt;@synchronized&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)lock1 {
    @synchronized (self) {
        // 加锁操作
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;性能最差&lt;/p&gt;
">iOS - 系统中的锁</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/java-ji-chu-yu-fa-er/"" data-c="
          &lt;h1 id=&#34;java-基础语法二&#34;&gt;Java - 基础语法二&lt;/h1&gt;
&lt;h2 id=&#34;1-常用-api&#34;&gt;① 常用 API&lt;/h2&gt;
&lt;h3 id=&#34;object-类&#34;&gt;Object 类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。&lt;/p&gt;
&lt;p&gt;常用 API：&lt;br&gt;
&lt;code&gt;public String toString()&lt;/code&gt;: 返回该对象的字符串表示&lt;br&gt;
&lt;code&gt;public boolean equals(Object obj)&lt;/code&gt; : 与其他对象比较是否与当前对象“相等”&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;objects-类&#34;&gt;Objects 类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; 类的 &lt;code&gt;equals&lt;/code&gt; 方法容易抛出空指针异常，在 &lt;code&gt;Objects&lt;/code&gt; 类中提供了 &lt;code&gt;equals&lt;/code&gt; 方法优化这个问题。&lt;br&gt;
&lt;code&gt;public static boolean equals(Object a, Object b)&lt;/code&gt;:判断两个对象是否相等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public static boolean equals(Object a, Object b) {  
    return (a == b) || (a != null &amp;amp;&amp;amp; a.equals(b));  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;date-类&#34;&gt;Date 类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public Date()&lt;/code&gt;：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public Date(long date)&lt;/code&gt;：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public long getTime()&lt;/code&gt; 把日期对象转换成对应的时间毫秒值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dateformat-类&#34;&gt;DateFormat 类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.text.DateFormat&lt;/code&gt; 是日期/时间格式化子类的抽象类，通过这个类完成日期和文本之间的转换。&lt;/p&gt;
&lt;h4 id=&#34;格式规则&#34;&gt;格式规则&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标识字母（区分大小写）&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;年&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;月&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;日&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;秒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Demo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   /*从出生到现在经历多少天*/
    private static void daysFormBirthday() throws ParseException {
        System.out.println(&amp;quot;输入生日：（格式 yyyy-MM-dd）&amp;quot;);
        Scanner scanner = new Scanner(System.in);
        String birthday = scanner.next();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&amp;quot;yyyy-MM-dd&amp;quot;);
        Date birthdayDate = simpleDateFormat.parse(birthday);

        long birthdayDateTime = birthdayDate.getTime();
        long nowTime = new Date().getTime();
        long interval = nowTime - birthdayDateTime;
        long days = interval / 1000 / 60 / 60 / 24;
        System.out.println(&amp;quot;从出生到现在已过&amp;quot; + days + &amp;quot;天！&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;calendar-类&#34;&gt;Calendar 类&lt;/h3&gt;
&lt;p&gt;日历类。&lt;br&gt;
Calendar类中提供很多成员常量，代表给定的日历字段：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段值&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;年&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MONTH&lt;/td&gt;
&lt;td&gt;月（从0开始，可以+1使用）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DAY_OF_MONTH&lt;/td&gt;
&lt;td&gt;月中的天（几号）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HOUR&lt;/td&gt;
&lt;td&gt;时（12小时制）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HOUR_OF_DAY&lt;/td&gt;
&lt;td&gt;时（24小时制）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MINUTE&lt;/td&gt;
&lt;td&gt;分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SECOND&lt;/td&gt;
&lt;td&gt;秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DAY_OF_WEEK&lt;/td&gt;
&lt;td&gt;周中的天（周几，周日为1，可以-1使用）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;system-类&#34;&gt;System 类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public static long currentTimeMillis()&lt;/code&gt;：返回以毫秒为单位的当前时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)&lt;/code&gt;：将数组中指定的数据拷贝到另一个数组中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数序号&lt;/th&gt;
&lt;th&gt;参数名称&lt;/th&gt;
&lt;th&gt;参数类型&lt;/th&gt;
&lt;th&gt;参数含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;源数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;srcPos&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;源数组索引起始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;dest&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;目标数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;destPos&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;目标数组索引起始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;复制元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2-collection-集合&#34;&gt;② Collection 集合&lt;/h2&gt;
&lt;p&gt;数组的长度是固定的，集合的长度是可变的&lt;br&gt;
数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致，在开发中一般当对象多的时候，使用集合存储。&lt;/p&gt;
&lt;h3 id=&#34;collection-常用功能&#34;&gt;Collection 常用功能&lt;/h3&gt;
&lt;p&gt;Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public boolean add(E e)&lt;/code&gt;：  把给定的对象添加到当前集合中 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void clear()&lt;/code&gt; :清空集合中所有的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public boolean remove(E e)&lt;/code&gt;: 把给定的对象在当前集合中删除。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public boolean contains(E e)&lt;/code&gt;: 判断当前集合中是否包含给定的对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public boolean isEmpty()&lt;/code&gt;: 判断当前集合是否为空。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public int size()&lt;/code&gt;: 返回集合中元素的个数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public Object[] toArray()&lt;/code&gt;: 把集合中的元素，存储到数组中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;迭代器-iterator&#34;&gt;迭代器 （Iterator）&lt;/h3&gt;
&lt;p&gt;Iterator接口的常用方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public E next()&lt;/code&gt;:返回迭代的下一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public boolean hasNext()&lt;/code&gt;:如果仍有元素可以迭代，则返回 true。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;泛型&#34;&gt;泛型&lt;/h3&gt;
&lt;p&gt;当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&amp;lt;?&amp;gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。&lt;/p&gt;
&lt;p&gt;受限泛型&lt;br&gt;
&lt;strong&gt;泛型的上限&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;格式&lt;/strong&gt;： &lt;code&gt;类型名称 &amp;lt;? extends 类 &amp;gt; 对象名称&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;： &lt;code&gt;只能接收该类型及其子类&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;泛型的下限&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;格式&lt;/strong&gt;： &lt;code&gt;类型名称 &amp;lt;? super 类 &amp;gt; 对象名称&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;： &lt;code&gt;只能接收该类型及其父类型&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.util.ArrayList&lt;/code&gt; 集合数据存储的结构是数组结构，元素增删满，查找快。日常开发常用的功能是查询数据和遍历数据，所以&lt;code&gt;ArrayList&lt;/code&gt;是最常用的集合。&lt;br&gt;
&lt;code&gt;java.until.LinkedList&lt;/code&gt;集合数据存储的结构是链表结构，方便元素添加和删除的集合，但是查询慢。&lt;/p&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.until.Set&lt;/code&gt; 接口和 &lt;code&gt;java.util.List&lt;/code&gt; 接口一样，同样继承于 &lt;code&gt;Collection&lt;/code&gt; 接口，它与 &lt;code&gt;Collection&lt;/code&gt; 接口中的方法基本一致。&lt;code&gt;Set&lt;/code&gt;接口中的元素无序，并且都会以某种规则保证存入的元素不会出现重复。&lt;br&gt;
&lt;code&gt;HashSet&lt;/code&gt; 能保证存储的元素唯一，但是无序。想要即唯一，又有顺序就需要用 &lt;code&gt;java.util.LinkedHashSet&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;collections&#34;&gt;Collections&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.utils.Collections&lt;/code&gt;是集合工具类，用来对集合进行操作。部分方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; boolean addAll(Collection&amp;lt;T&amp;gt; c, T... elements)  &lt;/code&gt;:往集合中添加一些元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static void shuffle(List&amp;lt;?&amp;gt; list) 打乱顺序&lt;/code&gt;:打乱集合顺序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list)&lt;/code&gt;:将集合中元素按照默认规则排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list，Comparator&amp;lt;? super T&amp;gt; )&lt;/code&gt;:将集合中元素按照指定规则排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Comparator&lt;/code&gt; 接口代表一个比较器，其中：&lt;br&gt;
&lt;code&gt;public int compare(String o1, String o2);&lt;/code&gt; 比较其两个参数的顺序。&lt;br&gt;
若按照升序排序，则 o1 &amp;lt; o2 (负数)&lt;br&gt;
若按照降序排序，则 o1 &amp;gt; o1 (正数)&lt;/p&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;private static void sortDemo() {
    ArrayList&amp;lt;Student&amp;gt; arrayList = new ArrayList&amp;lt;Student&amp;gt;();
    arrayList.add(new Student(&amp;quot;邱学伟&amp;quot;,18));
    arrayList.add(new Student(&amp;quot;梁朝伟&amp;quot;,30));
    arrayList.add(new Student(&amp;quot;周星驰&amp;quot;,24));
    arrayList.add(new Student(&amp;quot;刘德华&amp;quot;,28));
    arrayList.add(new Student(&amp;quot;a&amp;quot;,22));
    arrayList.add(new Student(&amp;quot;b&amp;quot;,22));
    // 按类内定义排序
//        Collections.sort(arrayList); 

    // 年龄降序
//        arrayList.sort(new Comparator&amp;lt;Student&amp;gt;() {
//            @Override
//            public int compare(Student o1, Student o2) {
//                return o2.getAge() - o1.getAge();//年龄降序
//            }
//        });

    // 年龄升序，相同年龄 按首字母
    arrayList.sort(new Comparator&amp;lt;Student&amp;gt;() {
        @Override
        public int compare(Student o1, Student o2) {
            int result = o1.getAge() - o2.getAge();
            if (result == 0) {
                result = o1.getName().charAt(0) - o2.getName().charAt(0);
            }
            return result;
        }
    });

    for (Student student : arrayList) {
        System.out.println(student);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map&#34;&gt;Map&lt;/h3&gt;
&lt;p&gt;Map 中的集合，元素是成对存在的，每个元素由键和值两部分组成，通过键可以找到所对应的值；&lt;br&gt;
Collection 中的集合称为单列集合，Map 中的集合称为双列集合；&lt;br&gt;
Map 中的集合不能包含重复的键，值可以重复。每个键对应一个值。&lt;br&gt;
Map接口中定义了很多方法，常用的如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public V put(K key, V value)&lt;/code&gt;:  把指定的键与指定的值添加到Map集合中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public V remove(Object key)&lt;/code&gt;: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public V get(Object key)&lt;/code&gt; 根据指定的键，在Map集合中获取对应的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean containsKey(Object key)  &lt;/code&gt; 判断集合中是否包含指定的键。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public Set&amp;lt;K&amp;gt; keySet()&lt;/code&gt;: 获取Map集合中所有的键，存储到Set集合中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()&lt;/code&gt;: 获取到Map集合中所有的键值对对象的集合(Set集合)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;entry-键值对对象&#34;&gt;Entry 键值对对象&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Entry&lt;/code&gt; 将键值对的对应关系封装成了对象，即键值对对象，这样我们在遍历 Map 集合时，就可以从每一个键值对（&lt;code&gt;Entry&lt;/code&gt;）对象中获取对应的键与其对应的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public K getKey()&lt;/code&gt;：获取Entry对象中的键。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public V getValue()&lt;/code&gt;：获取Entry对象中的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Map集合中也提供了获取所有Entry对象的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()&lt;/code&gt;: 获取到Map集合中所有的键值对对象的集合(Set集合)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当给 HashMap 中存放自定义对象时，如果自定义对象作为 Key 存在，这时要保证对象的唯一，则必须重写对象的 &lt;code&gt;hashCode&lt;/code&gt; 和 &lt;code&gt;equals&lt;/code&gt; 方法。&lt;br&gt;
如果要保证 map 中存在的 key 和取出的顺序一致，可以使用 &lt;code&gt;java.util.LinkedHashMap&lt;/code&gt;集合存放。&lt;/p&gt;
&lt;h2 id=&#34;3-线程&#34;&gt;③ 线程&lt;/h2&gt;
&lt;p&gt;并发：指两个或多个事件在同一时间段内发生。&lt;br&gt;
并行：指两个或多个事件在同一时刻发生（同时发生）。&lt;/p&gt;
&lt;p&gt;进程：一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。&lt;br&gt;
线程：线程是进程中的一个执行单元，负责当前进程中的程序的执行，一个进程中至少有一个线程。一个进程是可以有多个线程的，这个应用程序也可称之为多线程程序。&lt;/p&gt;
&lt;p&gt;简而言之：一个程序运行后至少有一个进程，一个进程可以包含多个线程。&lt;/p&gt;
&lt;p&gt;线程的调度方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。&lt;/li&gt;
&lt;li&gt;抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java 使用的是抢占式调度。
&lt;ol&gt;
&lt;li&gt;CPU 使用抢占式调度模式在多个线程间进行着高速的切换，对于 CPU 的一个核而言，某个时刻，只能执行一个线程，而 CPU 在多个线程间切换速度相对我们感觉要快，看上去就像在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序的运行效率，让 CPU 的使用率更高。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线程同步的三种方式&#34;&gt;线程同步的三种方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;同步代码块&lt;/li&gt;
&lt;li&gt;同步方法&lt;/li&gt;
&lt;li&gt;锁机制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同步代码块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;synchronized(同步锁) 
{
    /// 需要同步执行的代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中同步锁：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;锁对象，可以是任意类型&lt;/li&gt;
&lt;li&gt;多个线程对象，要使用同一把锁&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线程之间的通信&#34;&gt;线程之间的通信&lt;/h3&gt;
&lt;p&gt;wait/notify 就是线程间的一种协作机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用wait和notify方法需要注意的细节&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。&lt;/li&gt;
&lt;li&gt;wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。&lt;/li&gt;
&lt;li&gt;wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线程池&#34;&gt;线程池&lt;/h3&gt;
&lt;p&gt;一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源。&lt;/p&gt;
&lt;h2 id=&#34;4-lambda&#34;&gt;④ Lambda&lt;/h2&gt;
&lt;p&gt;面向对象的思想：&lt;br&gt;
做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情；&lt;br&gt;
函数式编程思想：&lt;br&gt;
只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果不重视过程。&lt;/p&gt;
&lt;h3 id=&#34;lambda-的标准格式&#34;&gt;Lambda 的标准格式：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一些参数&lt;/li&gt;
&lt;li&gt;一个箭头&lt;/li&gt;
&lt;li&gt;一段代码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;(参数类型 参数名称) -&amp;gt; { 代码语句 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。&lt;br&gt;
-&amp;gt; 是新引入的语法，代表指向动作&lt;br&gt;
大括号内的语法与传统方法体要求基本一致&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// Lambda , 年龄升序，相同年龄，首字母降序
arrayList.sort((Student s1, Student s2)-&amp;gt;{
    int result = s1.getAge() - s2.getAge();
    if (result == 0) {
        result = s2.getName().charAt(0) - s1.getName().charAt(0);
    }
    return result;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;省略规则：&lt;br&gt;
小括号内参数的类型可以省略；&lt;br&gt;
如果小括号内有且仅有一个参数，则小括号可以省略&lt;br&gt;
如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return 关键字及语句分号。&lt;/p&gt;
&lt;p&gt;使用 Lambda 注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 Lambda 必须有接口，且要求接口中有且仅有一个抽象方法&lt;/li&gt;
&lt;li&gt;使用 Lambda 必须具有上下文推断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java 中的 Lambda 可以被当做是匿名内部类的替代品。&lt;br&gt;
如果函数的参数是一个函数式接口类型，就可以使用 Lambda 表达式进行替代，使用 Lambda 表达式作为方法参数，其实就是使用函数式接口作为方法参数。&lt;br&gt;
类似的，如果一个方法的返回值是一个函数式接口，那么也可以直接返回一个 Lambda 表达式。&lt;/p&gt;
&lt;h3 id=&#34;常用函数式接口&#34;&gt;常用函数式接口&lt;/h3&gt;
&lt;h4 id=&#34;1-supplier-接口&#34;&gt;1. Supplier 接口&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;java.util.function.Supplier&amp;lt;T&amp;gt;&lt;/code&gt; 接口仅包含一个无参方法 &lt;code&gt;T get()&lt;/code&gt;。用以获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的 Lambda 表达式需要“对外提供”一个符合泛型类型的对象数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void demo2() {
    String s1 = &amp;quot;极客学伟&amp;quot;;
    String s2 = &amp;quot;科技有限公司&amp;quot;;
    String s3 = getString(()-&amp;gt; s1 + s2 );
    System.out.print(s3);
}
private static String getString(Supplier&amp;lt;String&amp;gt; function) {
    return function.get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-consumer-接口&#34;&gt;2. Consumer 接口&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;java.util.function.Consumer&amp;lt;T&amp;gt;&lt;/code&gt; 接口与 Supplier 相反，它不是产生一个数据，而是消费一个数据，其数据类型由泛型决定。&lt;/p&gt;
&lt;h5 id=&#34;抽象方法-accept&#34;&gt;抽象方法 accept&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void demo3() {
    consumerString((num)-&amp;gt; System.out.println(&amp;quot;打印：&amp;quot; + num));
}
private static void consumerString(Consumer&amp;lt;Integer&amp;gt; function) {
    function.accept(1024);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;默认方法-andthen&#34;&gt;默认方法 andThen&lt;/h5&gt;
&lt;p&gt;消费数据时，首先做一个操作，然后再做一个操作，实现组合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void demo4() {
    consumerAndThenString(s -&amp;gt; System.out.println(s.toLowerCase()) ,s -&amp;gt; System.out.println(s.toUpperCase()));
}
private static void consumerAndThenString(Consumer&amp;lt;String&amp;gt; f1, Consumer&amp;lt;String&amp;gt; f2) {
    f1.andThen(f2).accept(&amp;quot;Hello World!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;private static void demo5() {
    ArrayList&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;Student&amp;gt;(Arrays.asList(new Student(&amp;quot;极客&amp;quot;,18) , new Student(&amp;quot;学伟&amp;quot;,28)));
    userInfoLog(students,student -&amp;gt; System.out.print(&amp;quot;姓名：&amp;quot; + student.getName()) , student -&amp;gt; System.out.print(&amp;quot; 年龄：&amp;quot; + student.getAge() + &amp;quot;;\n&amp;quot;));
}
private static void userInfoLog(ArrayList&amp;lt;Student&amp;gt; s, Consumer&amp;lt;Student&amp;gt; s1, Consumer&amp;lt;Student&amp;gt; s2) {
    for (Student student : s) {
        s1.andThen(s2).accept(student);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-predicate-接口&#34;&gt;3. Predicate 接口&lt;/h4&gt;
&lt;p&gt;对某种类型的数据进行判断，从而得到一个 boolean 值的结果，可以使用 &lt;code&gt;java.util.function.Predicate&amp;lt;T&amp;gt;&lt;/code&gt; 接口。&lt;/p&gt;
&lt;h5 id=&#34;抽象方法test&#34;&gt;抽象方法：test&lt;/h5&gt;
&lt;p&gt;用于条件判断的场景：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;private static void demo6() {
    Student s = new Student(&amp;quot;极客学伟&amp;quot;,27);
    adjustMethod(student -&amp;gt; student.getName().equals(&amp;quot;极客学伟&amp;quot;) , s);
}
private static void adjustMethod(Predicate&amp;lt;Student&amp;gt; predicate, Student s) {
    boolean isMe = predicate.test(s);
    System.out.println(&amp;quot;名字叫&amp;quot; + s.getName() + &amp;quot;的&amp;quot; + (isMe ? &amp;quot;很帅&amp;quot; : &amp;quot;一点点丑&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;默认方法and&#34;&gt;默认方法：and&lt;/h5&gt;
&lt;p&gt;逻辑判断中将两个 &lt;code&gt;Predicate&lt;/code&gt; 条件使用“与”逻辑连接起来实现 “并且”的效果&lt;/p&gt;
&lt;h5 id=&#34;默认方法or&#34;&gt;默认方法：or&lt;/h5&gt;
&lt;p&gt;逻辑判断中将两个 &lt;code&gt;Predicate&lt;/code&gt; 条件使用“或”逻辑连接起来实现 “或者”的效果&lt;/p&gt;
&lt;h5 id=&#34;默认方法negate&#34;&gt;默认方法：negate&lt;/h5&gt;
&lt;p&gt;逻辑判断中将两个 &lt;code&gt;Predicate&lt;/code&gt; 条件使用“非”逻辑连接起来实现 “取反”的效果&lt;/p&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;private static void demo7() {
    String[] girls = {&amp;quot;邓紫棋，26&amp;quot;, &amp;quot;韩红，46&amp;quot;, &amp;quot;韩雪，36&amp;quot;, &amp;quot;杨紫，29&amp;quot;, &amp;quot;慧慧，28&amp;quot;, &amp;quot;古力娜扎，32&amp;quot;, &amp;quot;AngelaBaby，28&amp;quot;};
    /// 筛选 二十来岁名字是两个字的女神
    ArrayList&amp;lt;String&amp;gt; result = predicateDemo(girls, g -&amp;gt; Integer.parseInt(g.split(&amp;quot;，&amp;quot;)[1]) &amp;lt; 30, g -&amp;gt; g.split(&amp;quot;，&amp;quot;)[0].length() &amp;lt; 3);
    result.forEach(System.out::println);
}
// 筛选满足两个条件的数组
private static ArrayList&amp;lt;String&amp;gt; predicateDemo(String[] girls, Predicate&amp;lt;String&amp;gt; p1, Predicate&amp;lt;String&amp;gt; p2) {
    ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(girls.length);
    for (String girl : girls) {
        if (p1.and(p2).test(girl)) {
            list.add(girl);
        }
    }
    return list;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-function-接口&#34;&gt;4. Function 接口&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;java.util.function.Function&amp;lt;T,R&amp;gt;&lt;/code&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者成为前置条件，后者称为后置条件。&lt;/p&gt;
&lt;h5 id=&#34;抽象方法apply&#34;&gt;抽象方法：apply&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;R apply(T t)&lt;/code&gt; 根据类型 T 的参数获取类型 R 的结果。&lt;/p&gt;
&lt;h2 id=&#34;5-stream&#34;&gt;⑤ Stream&lt;/h2&gt;
&lt;p&gt;Java 中的流思想类似于工厂车间的“生产流水线”。&lt;br&gt;
Stream（流）是一个来自数据源的元素队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素是特定类型的对象，形成一个队列。Java 中的 Stream 并不会存储元素，而是按需计算。&lt;/li&gt;
&lt;li&gt;数据源 流的来源，可以是集合数组等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基础特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pipelining：中间操作都会返回流对象本身，这样多个操作可以串联成一个管道，如同流式风格。&lt;/li&gt;
&lt;li&gt;内部迭代：以前对集合遍历都是通过 &lt;code&gt;Iterator&lt;/code&gt; 或者增强 &lt;code&gt;for&lt;/code&gt; 的方式，显式的在集合外部进行迭代，这叫外部迭代。Stream 提供内部迭代的方式，流可以直接调用遍历方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用步骤：&lt;br&gt;
获取一个数据源 -&amp;gt; 数据转换 -&amp;gt; 执行操作获取想要的结果。每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。&lt;/p&gt;
&lt;p&gt;demo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;
/// 筛选 二十来岁名字是两个字的女神
private static void streamDemo1() {
    String[] girls = {&amp;quot;邓紫棋，26&amp;quot;, &amp;quot;韩红，46&amp;quot;, &amp;quot;韩雪，36&amp;quot;, &amp;quot;杨紫，29&amp;quot;, &amp;quot;慧慧，28&amp;quot;, &amp;quot;古力娜扎，32&amp;quot;, &amp;quot;AngelaBaby，28&amp;quot;};
    Arrays.stream(girls).filter(s -&amp;gt; parseInt(s.split(&amp;quot;，&amp;quot;)[1]) &amp;lt; 30).filter(s -&amp;gt; s.split(&amp;quot;，&amp;quot;)[0].length() &amp;lt; 3).forEach(s -&amp;gt; System.out.println(s));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取-stream&#34;&gt;获取 Stream&lt;/h3&gt;
&lt;h4 id=&#34;collection&#34;&gt;Collection&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;java.util.Collection&lt;/code&gt; 接口中加入了 default 方法 &lt;code&gt;stream&lt;/code&gt; 用来获取流，所以其所有实现类均可直接获取流。&lt;/p&gt;
&lt;h4 id=&#34;map-2&#34;&gt;Map&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;java.util.Map&lt;/code&gt; 接口不是 &lt;code&gt;Collection&lt;/code&gt; 的子接口，且其 K-V 数据结构不符合流元素的单一特征，所以获取对应的流需要 Key、Value 或 entry 等情况。&lt;/p&gt;
&lt;h4 id=&#34;数组&#34;&gt;数组&lt;/h4&gt;
&lt;p&gt;数组对象不可能添加默认方法，&lt;code&gt;Stream&lt;/code&gt; 接口中提供了静态方法 &lt;code&gt;of&lt;/code&gt;，用于生成数组的 &lt;code&gt;stream&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void arrayStreamDemo() {
    String[] array = {&amp;quot;张三&amp;quot;, &amp;quot;李四&amp;quot;, &amp;quot;王五&amp;quot;, &amp;quot;赵六&amp;quot;};
    Stream&amp;lt;String&amp;gt; arrayStream = Stream.of(array);
    arrayStream.forEach(System.out::println);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;stream-常用方法&#34;&gt;Stream 常用方法&lt;/h3&gt;
&lt;h4 id=&#34;逐一处理foreach&#34;&gt;逐一处理：forEach&lt;/h4&gt;
&lt;p&gt;接收一个 &lt;code&gt;Consumer&lt;/code&gt; 接口函数，会将每一个流元素交给该函数处理。&lt;/p&gt;
&lt;h4 id=&#34;过滤filter&#34;&gt;过滤：filter&lt;/h4&gt;
&lt;p&gt;将一个流转换成另一个子集流&lt;/p&gt;
&lt;h4 id=&#34;映射map&#34;&gt;映射：map&lt;/h4&gt;
&lt;p&gt;将流中的元素映射到另一个流中&lt;/p&gt;
&lt;h4 id=&#34;统计个数count&#34;&gt;统计个数：count&lt;/h4&gt;
&lt;p&gt;获取流中的元素个数&lt;/p&gt;
&lt;h4 id=&#34;提取前几个limit&#34;&gt;提取前几个：limit&lt;/h4&gt;
&lt;p&gt;对流进行截取，只取前 n 个&lt;/p&gt;
&lt;h4 id=&#34;跳过前几个skip&#34;&gt;跳过前几个：skip&lt;/h4&gt;
&lt;p&gt;跳过流中的前 n 个元素&lt;/p&gt;
&lt;h4 id=&#34;组合concat&#34;&gt;组合：concat&lt;/h4&gt;
&lt;p&gt;将两个流合并成为一个流&lt;/p&gt;
">Java - 基础语法二</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/java-ji-chu-yu-fa-yi/"" data-c="
          &lt;h1 id=&#34;java-基础语法一&#34;&gt;Java - 基础语法一&lt;/h1&gt;
&lt;h2 id=&#34;1-基础语法&#34;&gt;① 基础语法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JVM（Java Virtual Machine）: Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 程序，都运行在 JVM 之上。&lt;/li&gt;
&lt;li&gt;JRE（Java Runtime Environment）：Java 程序的运行环境，包含 JVM 和运行时所需要的核心类库。&lt;/li&gt;
&lt;li&gt;JDK（Java Development Environment）：Java 程序开发工具包，包含 JRE 和开发人员使用的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.03.28.15854041867234.15827280446149.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;修饰符 返回值类型 方法名（参数列表）
{
    // 代码
    return 结果;// 如果返回值类型不为 void
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法重载多个方法的名称一样但是参数列表不一样&#34;&gt;方法重载：多个方法的名称一样，但是参数列表不一样&lt;/h3&gt;
&lt;h4 id=&#34;方法重载与以下因素有关&#34;&gt;方法重载与以下因素有关：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;参数个数不同&lt;/li&gt;
&lt;li&gt;参数类型不同&lt;/li&gt;
&lt;li&gt;参数的多类型顺序不同&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;方法重载与以下因素无关&#34;&gt;方法重载与以下因素无关：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;与参数的名称无关&lt;/li&gt;
&lt;li&gt;与方法的返回值类型无关&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数组一种容器可以同时存放多个数据源&#34;&gt;数组：一种容器，可以同时存放多个数据源&lt;/h3&gt;
&lt;h4 id=&#34;数组特点&#34;&gt;数组特点：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;数组是一种引用数据类型&lt;/li&gt;
&lt;li&gt;数组当中的多个数据，类型必须统一&lt;/li&gt;
&lt;li&gt;数组的长度在程序运行期间不可改变&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;动态初始化在创建数组的时候直接指定数组当中的数据元素个数&#34;&gt;动态初始化：在创建数组的时候，直接指定数组当中的数据元素个数&lt;/h4&gt;
&lt;p&gt;格式：&lt;code&gt;数据类型[] 数组名称 = new 数据类型[数组长度]&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;静态初始化在创建数组的时候不直接指定数据个数多少而是直接将具体的数据内容进行指定&#34;&gt;静态初始化：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定&lt;/h4&gt;
&lt;p&gt;标准格式：&lt;code&gt;数据类型[] 数组名称 = new 数据类型[] {元素 1、元素 2、...}&lt;/code&gt;&lt;br&gt;
省略格式：&lt;code&gt;数据类型[] 数组名称 = {元素 1、元素 2、...}&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;注意事项&#34;&gt;注意事项&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;静态初始化没有直接指定长度，但是仍然会自动推算得到长度 &lt;code&gt;int[] arrayA = {10, 20, 30};&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;静态初始化标准格式可以拆分成两个步骤  &lt;code&gt;int[] arrayB; arrayB = new int[5];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;动态初始化也可以拆分成两个步骤 &lt;code&gt;int arrayC; arrayC = new int [] {1, 2, 3 };&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;静态初始化一旦使用省略格式，就不能拆分成为两个步骤了&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;java-的内存需要划分成为-5-个部分&#34;&gt;Java 的内存需要划分成为 5 个部分：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;栈（Srack）：存放的都是方法中的局部变量，&lt;strong&gt;方法的运行一定在栈中&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;局部变量：方法的参数，或者是方法{} 内部的变量。&lt;/li&gt;
&lt;li&gt;作用域：一旦超出作用域，立刻从栈内存当中消失。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆（Heap）：凡是 new 出来的东西，都在堆当中&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;堆内存里面的东西都有一个地址值：16 进制&lt;/li&gt;
&lt;li&gt;堆内存里面的数据，都有默认值&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;方法区（Method Area）：存储 .class 相关信息，包含方法的信息。&lt;/li&gt;
&lt;li&gt;本地方法栈（Native Method Stack）：与操作系统相关&lt;/li&gt;
&lt;li&gt;寄存器（pc Register）：与 CPU 相关&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-面向对象&#34;&gt;② 面向对象&lt;/h2&gt;
&lt;h3 id=&#34;局部变量和成员变量&#34;&gt;局部变量和成员变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义的位置不同
&lt;ul&gt;
&lt;li&gt;局部变量：在方法内部&lt;/li&gt;
&lt;li&gt;成员变量：在方法外部，直接写在类中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用范围不同
&lt;ul&gt;
&lt;li&gt;局部变量：只有在方法中才可以使用，出了方法就不能用&lt;/li&gt;
&lt;li&gt;成员变量：整个类全都可以通用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;默认值不同
&lt;ul&gt;
&lt;li&gt;局部变量：没有默认值，如果想使用，必须手动进行赋值&lt;/li&gt;
&lt;li&gt;成员变量：如果没有赋值，会有默认值，规则和数组一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存位置不一样
&lt;ul&gt;
&lt;li&gt;局部变量：位于栈内存&lt;/li&gt;
&lt;li&gt;成员变量：位于堆内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生命周期不一样
&lt;ul&gt;
&lt;li&gt;局部变量：随方法进栈而诞生，随着方法出栈而消失&lt;/li&gt;
&lt;li&gt;成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;面向对象三大特性封装-继承-多态&#34;&gt;面向对象三大特性：封装、继承、多态&lt;/h3&gt;
&lt;p&gt;封装性在 Java 体现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法就是封装&lt;/li&gt;
&lt;li&gt;Private 关键字也是封装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于基本数据类型当中的 boolean 值，Getter 方法一定要写成 isXxx 的形式，而 setXxx 规则不变&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;构造方法是专门用来创建对象的方法，当我们通过关键字 new 来创建对象时，其实就是在调用构造方法&lt;/p&gt;
&lt;h4 id=&#34;格式&#34;&gt;格式：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public 类名称(参数类型 参数名称) 
{
    方法体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;构造方法使用注意事项&#34;&gt;构造方法使用注意事项：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样&lt;/li&gt;
&lt;li&gt;构造方法不要写返回值类型，连 Void 都不写&lt;/li&gt;
&lt;li&gt;构造方法不能 return 一个具体返回值&lt;/li&gt;
&lt;li&gt;如果没有编写任何构造方法，编译器会默认生成一个构造方法，无参数、无方法体&lt;/li&gt;
&lt;li&gt;一旦编写了至少一个构造方法，编译器便不再自动生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;标准的类&#34;&gt;标准的类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;所有的成员变量都要用 private 关键字修饰&lt;/li&gt;
&lt;li&gt;为每一个成员变量编写一对儿 Getter/Setter 方法&lt;/li&gt;
&lt;li&gt;编写一个无参数的构造方法&lt;/li&gt;
&lt;li&gt;编写一个全参数的构造方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-常用-api&#34;&gt;③ 常用 API&lt;/h2&gt;
&lt;h3 id=&#34;random&#34;&gt;Random&lt;/h3&gt;
&lt;p&gt;用于生成随机数&lt;br&gt;
&lt;code&gt;public int nextInt(int n)&lt;/code&gt; 返回一个 [0,n) 之间的随机数。&lt;/p&gt;
&lt;h3 id=&#34;arraylist&#34;&gt;ArrayList&lt;/h3&gt;
&lt;p&gt;数组的长度不可以发生变化，ArrayList 集合的长度是可以随意变化的。&lt;br&gt;
如果希望向 ArrayList 当中存储基本类型数据，必须使用基本类型对应的“包装类”&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本类型&lt;/th&gt;
&lt;th&gt;包装类（引用类型）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;p&gt;程序中所有双引号字符串，都是 String 类的对象&lt;/p&gt;
&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;字符串的内容永不改变&lt;/li&gt;
&lt;li&gt;正是因为字符串不可改变，所以字符串是可以共享使用的&lt;/li&gt;
&lt;li&gt;字符串效果上相当于是 char[] 字符数组，底层原理是 byte[] 字节数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串常量池，在堆中开辟的一块空间。 使用 &amp;quot;&amp;quot; 直接创建的字符串都存放在字符串常量池中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于引用类型来说，“==” 进行的是地址值的比较，基本数据类型是对值的比较；&lt;/li&gt;
&lt;li&gt;双引号直接创建的字符串在常量池中，new 的不在池中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果需要对字符串的内容进行比较，可以使用如下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean equals(Object obj); // 严格区分大小写
public boolean equalsIgnoreCase(Object obj); // 忽略大小写
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;split&lt;/code&gt; 方法的参数其实是一个正则表达式，如果要按照英文 . 进行切分，必须写 &amp;quot;\\.&amp;quot; (两个反斜杠)&lt;/p&gt;
&lt;h3 id=&#34;static-关键字&#34;&gt;Static 关键字&lt;/h3&gt;
&lt;p&gt;用来修饰成员变量和成员方法，被修饰的成员属于类的，而不是单单是属于某个对象的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;static&lt;/code&gt; 修饰成员变量，该变量称为类变量，该类的每个对象都共享同一个类变量的值。&lt;br&gt;
格式：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;static 数据类型 变量名;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;static&lt;/code&gt; 修饰成员方法时，该方法称为类方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态代码块：定义在成员位置，使用 &lt;code&gt;static&lt;/code&gt; 修饰的代码块 {}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位置：类中方法之外&lt;/li&gt;
&lt;li&gt;执行：随着类的加载而执行且只执行一次，优先于 main 方法和构造方法的执行。&lt;/li&gt;
&lt;li&gt;作用：类类变量进行初始化赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class className 
{
    static {
        /// 执行语句    
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.util.Arrays&lt;/code&gt; 是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组常见操作。&lt;br&gt;
&lt;code&gt;toString(数组)&lt;/code&gt; 将参数数组变成字符串&lt;br&gt;
&lt;code&gt;sort(数组)&lt;/code&gt; 按照默认升序对数组的元素进行排序：注意 如果数组内是自定义类型，那么这个自定义类需要有 &lt;code&gt;Comparable&lt;/code&gt; 或者 &lt;code&gt;Comparator&lt;/code&gt; 接口的支持。&lt;/p&gt;
&lt;h3 id=&#34;math&#34;&gt;Math&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;abs(double num)&lt;/code&gt; 绝对值&lt;br&gt;
&lt;code&gt;ceil(double num)&lt;/code&gt; 向上取整&lt;br&gt;
&lt;code&gt;floor(double num)&lt;/code&gt; 向下取整&lt;br&gt;
&lt;code&gt;round(double num)&lt;/code&gt; 四舍五入&lt;br&gt;
&lt;code&gt;Math.PI&lt;/code&gt; 圆周率&lt;/p&gt;
&lt;h2 id=&#34;4-继承&#34;&gt;④ 继承&lt;/h2&gt;
&lt;h3 id=&#34;继承&#34;&gt;继承&lt;/h3&gt;
&lt;p&gt;子类继承父类的属性和行为，使得子类对象具有父类相同的属性、相同的行为，子类可以直接访问父类中的非私有的属性和行为。&lt;br&gt;
优点：&lt;br&gt;
1、提高代码的复用性&lt;br&gt;
2、类与类之间产生了关系，是多态的前提。&lt;/p&gt;
&lt;p&gt;子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有变量时，需要使用 &lt;code&gt;super&lt;/code&gt; 关键字修饰父类成员变量。&lt;/p&gt;
&lt;p&gt;如果子父类中出现了同名的成员方法，这是的访问是一种特殊情况-称之为&lt;strong&gt;方法重写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 中指支持单继承，不支持多继承。&lt;/p&gt;
&lt;h3 id=&#34;抽象类&#34;&gt;抽象类&lt;/h3&gt;
&lt;p&gt;父类中的方法，被他的子类们重写，子类各自的实现都不尽相同，那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了，我们把没有方法主体的方法称为抽象方法。包含抽象方法的类就是抽象类。&lt;/p&gt;
&lt;h3 id=&#34;抽象方法&#34;&gt;抽象方法&lt;/h3&gt;
&lt;p&gt;抽象方法，方法前加 &lt;code&gt;abstract&lt;/code&gt; 关键字,去掉关键字，直接分号结束。&lt;br&gt;
定义格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;修饰符 abstract 返回值类型 方法名(参数列表);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;抽象类-2&#34;&gt;抽象类&lt;/h3&gt;
&lt;p&gt;抽象类：抽象方法所在的类，必须是抽象类才行，在 class 之前写上 &lt;code&gt;abstract&lt;/code&gt; 即可。抽象类可以定义正常方法。&lt;br&gt;
定义格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;abstract class 类名字
{
    ///xxx
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类不能实例化，必须用子类继承抽象父类，子类必须覆盖重写抽象类的所有抽象方法。&lt;/li&gt;
&lt;li&gt;抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。&lt;/li&gt;
&lt;li&gt;抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。&lt;/li&gt;
&lt;li&gt;抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错，除非子类也是抽象类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-接口&#34;&gt;⑤ 接口&lt;/h2&gt;
&lt;p&gt;接口是 Java 中的一种引用类型，是方法的集合，如果类的内部封装了成员变量，构造方法和成员方法，那么接口的内部主要就是封装了方法。接口不是类，是一种引用数据类型，其他的引用数据类型还包括：数组、类。&lt;br&gt;
接口可包含五部分：常量、抽象方法、默认方法、静态方法、私有方法&lt;br&gt;
定义格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public interface 接口名称
{
    // 抽象方法,继承类必须全部实现
    // 默认方法,default 修饰符修饰，可以继承可以重写，必须通过实现类来调用
    // 静态方法,只能通过接口名调用，不可通过实现类名或者实现类对象调用
    // 私有方法,私有成员方法只有默认方法可以调用、私有静态方法只有默认方法和静态方法可以调用
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口使用步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口不能直接使用，必须有一个“实现类”来“实现”该接口；格式：&lt;code&gt;public class 实现类名称 implement 接口名称&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接口的实现类必须覆盖重写接口中所有的抽象方法。&lt;/li&gt;
&lt;li&gt;创建实现类的对象，进行使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果实现类并没有覆盖重写接口的所有抽象方法，那么这个实现类自己就必须是抽象类。&lt;/li&gt;
&lt;li&gt;接口没有静态代码块或者构造方法&lt;/li&gt;
&lt;li&gt;一个类的直接父类是唯一的，但是一个类可以用时实现多个接口。格式：&lt;code&gt;public class 类名称 implements 接口 A, 接口 B {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多个接口存在相同名称抽象方法，实现类只需覆盖重写一次即可。&lt;/li&gt;
&lt;li&gt;如果实现类没有覆盖重写所有接口中定义的所有抽象方法，那么实现类就必须是一个抽象类。&lt;/li&gt;
&lt;li&gt;如果多个接口中存在相同名称的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。&lt;/li&gt;
&lt;li&gt;一个类如果直接父类中的方法和接口当中的默认方法产生了冲突，优先用父类中的方法。（Java 继承优先级高于接口）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接口中的方法默认是抽象方法&#34;&gt;接口中的方法默认是抽象方法&lt;/h3&gt;
&lt;p&gt;格式： &lt;code&gt;public abstract 返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;br&gt;
实现类必须覆盖重写接口所有抽象方法，除非实现类是抽象类。&lt;/p&gt;
&lt;h3 id=&#34;接口中的默认方法&#34;&gt;接口中的默认方法&lt;/h3&gt;
&lt;p&gt;接口中的默认方法可以解决接口升级的问题。&lt;br&gt;
格式：&lt;code&gt;public default 返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;接口中静态方法&#34;&gt;接口中静态方法&lt;/h3&gt;
&lt;p&gt;不能用接口实现类的对象来调用接口中的静态方法，应该直接使用接口名称直接调用静态方法。&lt;br&gt;
格式：&lt;code&gt;public static 返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;接口中的私有方法&#34;&gt;接口中的私有方法&lt;/h3&gt;
&lt;p&gt;抽取公共方法用来解决多个默认方法之间重复代码的问题，但这个共有方法不应该让实现类使用，应该是私有化的。&lt;br&gt;
格式：&lt;code&gt;private default  返回值类型 方法名称(参数列表);&lt;/code&gt;、&lt;code&gt;private static  返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;接口中的成员变量-即-常量&#34;&gt;接口中的“成员变量” 即 “常量”&lt;/h3&gt;
&lt;p&gt;接口中可以定义“成员变量”，但必须使用 &lt;code&gt;public static final&lt;/code&gt; 三个关键字进行修饰（可省略）。从效果上看，这其实就是接口的“常量”。一旦使用 &lt;code&gt;final&lt;/code&gt; 关键字，说明不可变&lt;br&gt;
格式：&lt;code&gt;public static final 数据类型 名称 = 数据值;&lt;/code&gt;&lt;br&gt;
注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口中的常量，可以省略 &lt;code&gt;public static final&lt;/code&gt; 关键字。含义不变。&lt;/li&gt;
&lt;li&gt;接口中的常量，必须进行赋值，不能不赋值。&lt;/li&gt;
&lt;li&gt;建议常量名称大写。多个单词用 _ 分割。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接口中的多继承&#34;&gt;接口中的多继承&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类与类之间是单继承的，直接父类只有一个&lt;/li&gt;
&lt;li&gt;类与接口之间是多继承的，一个类可以实现多个接口&lt;/li&gt;
&lt;li&gt;接口与接口之间是多继承的
&lt;ul&gt;
&lt;li&gt;多个父接口中的抽象方法可以重复&lt;/li&gt;
&lt;li&gt;多个父接口中的默认方法如果重复，必须在子接口进行覆盖重写，并带 &lt;code&gt;default&lt;/code&gt; 关键字。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接口其他特性&#34;&gt;接口其他特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;接口中，无法定义成员变量，但可以定义常量，其值不可改变，默认使用 &lt;code&gt;public static final&lt;/code&gt; 修饰，可以省略、&lt;/li&gt;
&lt;li&gt;接口中，没有构造方法，不能创建对象&lt;/li&gt;
&lt;li&gt;接口中，没有静态代码块&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-多态&#34;&gt;⑥ 多态&lt;/h2&gt;
&lt;p&gt;对象具有多个形态&lt;br&gt;
代码中体现多态性，父类引用指向子类对象。格式：&lt;code&gt;父类名称 对象名 = new 子类名称();&lt;/code&gt; 或 &lt;code&gt;接口名称 对象名 = new 实现类名称();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;多态访问成员变量的两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。（成员变量无法进行覆盖重写）&lt;/li&gt;
&lt;li&gt;间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多态访问成员方法：&lt;br&gt;
看 new 的是谁，就优先用谁，没有则向上找。&lt;/p&gt;
&lt;p&gt;口诀：&lt;br&gt;
多态访问成员变量：编译看左边，运行也看左边&lt;br&gt;
多态访问成员方法：编译看左边，运行看右边。&lt;/p&gt;
&lt;p&gt;多态的好处：无论右边 new 的是哪个子类对象，左边声明的类和调用的方法可以保持一致。&lt;/p&gt;
&lt;h3 id=&#34;对象的向上转型&#34;&gt;对象的向上转型&lt;/h3&gt;
&lt;p&gt;其实就是多态的写法：&lt;code&gt;父类名称 对象名 = new 子类名称();&lt;/code&gt;&lt;br&gt;
含义：右侧创建一个子类对象，把它当做父类看待使用。&lt;br&gt;
注意事项：向上转型一定是安全的。类似于基本数据类型的类型转换 （float -&amp;gt; double）&lt;br&gt;
弊端：一旦向上转型为父类，那么就无法调用子类原本特有的内容。（解决方案-使用向下转型）&lt;/p&gt;
&lt;h3 id=&#34;对象的向下转型&#34;&gt;对象的向下转型&lt;/h3&gt;
&lt;p&gt;其实是一个还原的动作。格式：&lt;code&gt;子类名称 对象名 = (子类名称)父类对象;&lt;/code&gt;&lt;br&gt;
含义：将父类对象，&lt;strong&gt;还原&lt;/strong&gt;为本来的子类对象&lt;br&gt;
注意事项：&lt;br&gt;
必须保证对象创建的时候就是向下转型的类型。&lt;/p&gt;
&lt;h3 id=&#34;instanceof-关键字&#34;&gt;&lt;code&gt;instanceof&lt;/code&gt; 关键字&lt;/h3&gt;
&lt;p&gt;返回一个 boolean 值，判断前面的对象能不能当做后面类型的实例。&lt;br&gt;
格式：&lt;code&gt;对象名 instanceof 类名&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-其他&#34;&gt;⑦ 其他&lt;/h2&gt;
&lt;h3 id=&#34;final-关键字&#34;&gt;&lt;code&gt;final&lt;/code&gt; 关键字&lt;/h3&gt;
&lt;p&gt;用于修饰&lt;strong&gt;不可改变&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h4 id=&#34;final-用法&#34;&gt;&lt;code&gt;final&lt;/code&gt; 用法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;修饰类：不能有任何子类，而且一个类如果是 &lt;code&gt;final&lt;/code&gt; 的，那么其中所有的成员方法都无法对其进行覆盖重写&lt;/li&gt;
&lt;li&gt;修饰方法：这个方法不能被覆盖重写，对于类和方法而言，&lt;code&gt;abstract&lt;/code&gt; 关键字和 &lt;code&gt;final&lt;/code&gt; 关键字不能同时使用，因为矛盾。&lt;/li&gt;
&lt;li&gt;修饰局部变量：这个变量只能被赋值一次，不能再次被修改。“一次赋值，终生不变”。对于基本数据类型，不可变值得是变量中的数据不可变；对于引用类型，不可变指的是变量中的地址值不可变。&lt;/li&gt;
&lt;li&gt;修饰成员变量：这个变量只能而且必须被赋值一次，不能再次被修改。而且不再有默认值。
&lt;ol&gt;
&lt;li&gt;由于成员变量具有默认值，所以用了 &lt;code&gt;final&lt;/code&gt; 之后必须手动赋值，不会再有默认值。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;final&lt;/code&gt; 的成员变量，要么使用直接赋值，要么使用构造方法赋值，两者取其一。&lt;/li&gt;
&lt;li&gt;如果使用构造方法对 &lt;code&gt;final&lt;/code&gt; 修饰的成员变量赋值，必须保证类中所有重载的构造方法，都最终会对 &lt;code&gt;final&lt;/code&gt; 的成员变量进行赋值。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;被 &lt;code&gt;final&lt;/code&gt; 修饰的常量名称，一般有书写规范，所有字母均大写。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;java-中的四种权限修饰符&#34;&gt;Java 中的四种权限修饰符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public &amp;gt; protected (专门给不同包子类用的) &amp;gt; (default) &amp;gt; private&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;public&lt;/th&gt;
&lt;th&gt;protected&lt;/th&gt;
&lt;th&gt;（default）&lt;/th&gt;
&lt;th&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同一个类（我自己）&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用一个包（我邻居）&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不同包子类（我儿子）&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不同包非子类（陌生人）&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;内部类&#34;&gt;内部类&lt;/h3&gt;
&lt;h4 id=&#34;分类&#34;&gt;分类：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;成员内部类&lt;/li&gt;
&lt;li&gt;局部内部类（包含匿名内部类）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;成员内部类&#34;&gt;成员内部类&lt;/h4&gt;
&lt;p&gt;格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;修饰符 class 外部类名称 
{
    修饰符 class 内部类名称
    {
        xxx
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部类可以直接访问外部类的成员，包括私有成员。&lt;br&gt;
外部类要访问内部类的成员，必须建立内部类的对象。&lt;br&gt;
即 : 内用外，随意访问。外用内需要借助内部类对象。&lt;/p&gt;
&lt;h4 id=&#34;如何使用成员内部类&#34;&gt;如何使用成员内部类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;间接方式：在外部类的方法中，使用内部类；然后 main 只是调用外部类的方法。&lt;/li&gt;
&lt;li&gt;直接方式：定义格式：&lt;code&gt;外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;内部类使用外部类的成员变量&#34;&gt;内部类使用外部类的成员变量&lt;/h4&gt;
&lt;p&gt;如果出现重名现象，使用格式：&lt;code&gt;外部类名称.this.外部类成员变量名&lt;/code&gt;&lt;br&gt;
实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Outer
{
    int num = 10;
     public class Inner
     {
        int num = 20;
        public void methodInner()
        {
           int num = 30;
           System.out.println(num); // 局部变量，就近原则
           System.out.println(this.num); // 内部类的成员变量
           System.out.println(Outer.this.num); // 外部类的成员变量
        }
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;局部内部类&#34;&gt;局部内部类&lt;/h4&gt;
&lt;p&gt;如果一个类定义在一个方法内部，那么就是局部内部类。&lt;br&gt;
“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。&lt;/p&gt;
&lt;p&gt;局部内部类如果要访问所在方法的局部变量，那么这个局部变量必须是【有效 final 的】即 用 final 声明的变量或者事实上只赋值一次的变量。&lt;br&gt;
原因：new 出来的对象在堆内存中，局部变量跟着方法走，在栈内存中。方法运行结束立刻出栈，局部变量立即消失。但是 new 出来的对象会在堆中持续存在，直到垃圾回收消失。&lt;/p&gt;
&lt;h4 id=&#34;定义类的权限修饰符&#34;&gt;定义类的权限修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;外部类：&lt;code&gt;public 或 (default)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;成员内部类：都可以&lt;/li&gt;
&lt;li&gt;局部内部类：什么都不能写&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;匿名内部类&#34;&gt;匿名内部类&lt;/h4&gt;
&lt;p&gt;如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用&lt;strong&gt;匿名内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;接口名称 对象名 = new 接口名称()
{
    /// 覆盖重写接口中所有的抽象方法。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对格式 &amp;quot;new 接口名称(){...}&amp;quot; 进行解析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;new 代表创建对象的动作&lt;/li&gt;
&lt;li&gt;接口名称就是匿名内部类需要实现哪个接口&lt;/li&gt;
&lt;li&gt;{...} 这才是匿名内部类的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;匿名内部类，在【创建对象】的时候只能使用唯一一次，如果希望多次创建对象，那么就必须使用单独定义的实现类。&lt;/li&gt;
&lt;li&gt;匿名对象，在【调用方法】的时候只能调用唯一一次，如果希望同一个对象调用多次方法，那么必须给对象起个名字。&lt;/li&gt;
&lt;li&gt;匿名内部类是省略了【实现类/子类名称】，但是匿名对象时省略了【对象名称】，匿名内部类和匿名对象不是一回事！！&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;interface-作为成员变量&#34;&gt;&lt;code&gt;interface&lt;/code&gt; 作为成员变量&lt;/h3&gt;
&lt;p&gt;使用接口作为成员变量以便随时更换实现方式，这种设计更为灵活，增强了程序的扩展性。&lt;br&gt;
接口作为成员变量时，对他进行复制的操作，实际上是赋给他接口的一个子类实现对象。&lt;/p&gt;
&lt;p&gt;接口作为参数数，传递它的子类对象；&lt;br&gt;
接口作为返回值类型是，也是返回它的子类对象。&lt;/p&gt;
">Java - 基础语法一</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/ios-lei-yu-dui-xiang/"" data-c="
          &lt;h1 id=&#34;ios-类与对象&#34;&gt;iOS - 类与对象&lt;/h1&gt;
&lt;h3 id=&#34;类方法&#34;&gt;类方法&lt;/h3&gt;
&lt;p&gt;OC 中类的方法只有实例方法和静态方法两种：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;@interface Controller: NSObject
/// 静态方法
+ (void)thisIsAStaticMethod;

/// 实例方法
- (void)thisIsAnInstanceMethod;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OC 中的方法只要声明在 @interface 里，就可以认为是公有的。实际上，OC 没有像 Java，C++ 中的那种绝对的 私有及保护 的成员方法，仅仅可以对调用者隐藏某些方法。&lt;/p&gt;
&lt;p&gt;声明和实现都写在 @implementation 里的方法，类的外部是看不到的。&lt;/p&gt;
&lt;p&gt;可以使用 分类（Category） 和 类扩展（Extension）来实现私有方法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;// AClass.h
@interface AClass: NSObject
- (void)sayHello;
@end

// AClass.m
@interface AClass (private)
- (void)privateSayHello1;
@end

@interface AClass ()
- (void)privateSayHello2;
@end

@implementation AClass
- (void)sayHello 
{
    [self privateSayHello];
}

- (void)privateSayHello1
{
    NSLog(@&amp;quot;privateSayHello1&amp;quot;);
}

- (void)privateSayHello2
{
    NSLog(@&amp;quot;privateSayHello2&amp;quot;);
}

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用这种方法外部就不能直接调用到 &lt;code&gt;privateSayHello1&lt;/code&gt; 和 &lt;code&gt;privateSayHello2&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&#34;类变量&#34;&gt;类变量&lt;/h3&gt;
&lt;p&gt;Apple 推荐现代的 Objective-C 中使用 &lt;code&gt;@property&lt;/code&gt; 来实现成员变量，使用 &lt;code&gt;@property&lt;/code&gt; 声明的变量可以使用 &lt;code&gt;实例名.变量名&lt;/code&gt; 来获取和修改。&lt;br&gt;
&lt;code&gt;@property&lt;/code&gt; 可以看做一种语法糖，使用 &lt;code&gt;@property&lt;/code&gt; 此声明&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;@interface AClass: NSObject
@property (nonatomic, copy) NSString *name;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可等价于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;@interface AClass: NSObject
{
    NSString *_name;
}
- (NSString *)name;
- (void)setName:(NSString *)name;
@end

@implementation AClass
- (NSString *)name
{
    return _name;
}
- (void)setName:(NSString *)name
{
    _name = name;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;@property&lt;/code&gt; 会自动生成 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法，同时进行自动内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@property&lt;/code&gt; 可声明的属性修饰符有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;readwrite&lt;/code&gt; 可读写，需要生成 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readonly&lt;/code&gt; 只读，只会生成 &lt;code&gt;getter&lt;/code&gt; 方法，不会生成 &lt;code&gt;setter&lt;/code&gt; 方法，不希望属性在类外改变时使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assign&lt;/code&gt; 赋值属性，&lt;code&gt;setter&lt;/code&gt; 方法将传入的参数赋值给实例变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strong&lt;/code&gt; 持有特性，&lt;code&gt;setter&lt;/code&gt; 方法将传入的参数先保留，再赋值，传入参数的引用计数会 +1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy&lt;/code&gt; 拷贝特性，&lt;code&gt;setter&lt;/code&gt; 方法将传入对象复制一份；需要完全一份新的变量时使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nonatomic&lt;/code&gt; 和 &lt;code&gt;atomic&lt;/code&gt; ，决定编译器生成的 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法是否是原子操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;默认的 &lt;code&gt;@property&lt;/code&gt; 是&lt;br&gt;
基本数据类型： &lt;code&gt;readwrite&lt;/code&gt;、&lt;code&gt;assign&lt;/code&gt;、&lt;code&gt;atomic&lt;/code&gt;；&lt;br&gt;
对象： &lt;code&gt;readwrite&lt;/code&gt;、&lt;code&gt;strong&lt;/code&gt;、&lt;code&gt;atomic&lt;/code&gt;；&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;protocol&#34;&gt;Protocol&lt;/h3&gt;
&lt;p&gt;OC 是单继承的，OC 中的类可以实现多个 &lt;code&gt;protocol&lt;/code&gt; 来实现类似 C++ 中多重继承的效果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;protocol&lt;/code&gt; 类似 JAVA 中的 &lt;code&gt;interface&lt;/code&gt;，定义了一个方法列表，这个方法列表中的方法可以使用 &lt;code&gt;@required&lt;/code&gt; &lt;code&gt;@optional&lt;/code&gt; 标注，以表示该方法是否客户类必须要实现的方法。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;protocol&lt;/code&gt; 中含有 &lt;code&gt;property&lt;/code&gt; 时，编译器不会进行自动 &lt;code&gt;synthesize&lt;/code&gt; 的，需要手动处理：在实现这个 &lt;code&gt;protocol&lt;/code&gt; 的时候要么再次声明 &lt;code&gt;property&lt;/code&gt; 要么手动 &lt;code&gt;synthesize&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;category&#34;&gt;Category&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Category&lt;/code&gt; 是一种很灵活的扩展原有类的机制，使用 &lt;code&gt;Category&lt;/code&gt; 不需要访问原有类的代码，也无需集成，&lt;code&gt;Category&lt;/code&gt; 提供了一种简单的方式，来实现类的相关方法的模块化，把不同的方法分配到不同的类文件中。&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;Category&lt;/code&gt; 时需要注意的是，如果有多个 &lt;code&gt;Category&lt;/code&gt; 均实现了同一个方法，那么这些方法在运行时只有一个会被调用，具体哪个会被调用是不确定的，因此建议在使用 &lt;code&gt;Category&lt;/code&gt; 时在函数命名方法加上前缀。&lt;/p&gt;
&lt;h3 id=&#34;extension&#34;&gt;Extension&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Extension&lt;/code&gt; 可以认为是一种匿名的 &lt;code&gt;Category&lt;/code&gt; ，&lt;code&gt;Extension&lt;/code&gt; 与 &lt;code&gt;Category&lt;/code&gt; 有如下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;Extension&lt;/code&gt; 必须有原有类的源码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Extension&lt;/code&gt; 声明的方法必须在类的主 &lt;code&gt;@implementation&lt;/code&gt; 区间内实现，可以避免使用有名 &lt;code&gt;Category&lt;/code&gt; 带来的多个不必要的&lt;code&gt;@implementation&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Extension&lt;/code&gt; 可以在类中添加新的属性和实例变量，&lt;code&gt;Category&lt;/code&gt; 不可以。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Extension&lt;/code&gt; 和 &lt;code&gt;Category&lt;/code&gt; 里添加的方法必须要有实现。（没有实现编译器会给出警告）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Category&lt;/code&gt; 一般用来给类添加私有的变量和方法，在类的内部使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如果在类中添加全局变量&#34;&gt;如果在类中添加全局变量&lt;/h3&gt;
&lt;p&gt;一个简单直接的做法是在 .m 文件中使用 &lt;code&gt;static&lt;/code&gt; 变量。由于 &lt;code&gt;static&lt;/code&gt; 变量在编译器就是确定的，因此对于 &lt;code&gt;NSObject&lt;/code&gt; 对象来说，初始化的值只能是 nil, 如何进行类似 init 的初始化呢? 可以通过重载 &lt;code&gt;initialize&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;static NSOperationQueue *_queue = nil;
@implementation XWPerson
- (void)initialize
{
    if (!_queue) {
        _queue = [[NSOperationQueue alloc] init];
    }
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么这里要判断是否为 &lt;code&gt;nil&lt;/code&gt; 呢？因为 &lt;code&gt;initialize&lt;/code&gt; 方法可能会调用多次。&lt;/p&gt;
&lt;p&gt;有一种方法是声明 &lt;code&gt;static&lt;/code&gt; 函数，下面代码来自 &lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m&#34;&gt;AFNetworking&lt;/a&gt;，声明了一个当前文件范围可用的队列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;static dispatch_queue_t url_session_manager_creation_queue() {
    static dispatch_queue_t af_url_session_manager_creation_queue;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        af_url_session_manager_creation_queue = dispatch_queue_create(&amp;quot;com.alamofire.networking.session.manager.creation&amp;quot;, DISPATCH_QUEUE_SERIAL);
    });

    return af_url_session_manager_creation_queue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此以外，还可以通过编译器的 &lt;code&gt;__attribute_&lt;/code&gt; 特性来实现初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;__attribute__((constructor))
static void initialize_Queue() {
    _personOperationQueue = [[NSOperationQueue alloc] init];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;类的初始化&#34;&gt;类的初始化&lt;/h3&gt;
&lt;p&gt;Objective-C 是建立在 Runtime 基础上的语言，类也不例外。OC 中类的初始化也是动态的，在 OC 中绝大部分类都继承自 &lt;code&gt;NSObject&lt;/code&gt; ，它有两个非常特殊的类方法 &lt;code&gt;+load&lt;/code&gt; 和 &lt;code&gt;+initialize&lt;/code&gt;，用于类的初始化。&lt;/p&gt;
&lt;h4 id=&#34;load&#34;&gt;&lt;code&gt;+load&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;+load&lt;/code&gt; 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 &lt;code&gt;+load&lt;/code&gt; 方法会在它所有的父类的 &lt;code&gt;+load&lt;/code&gt; 方法之后执行，而分类的 &lt;code&gt;+load&lt;/code&gt; 方法会在它的主类 &lt;code&gt;+load&lt;/code&gt; 方法之后执行。&lt;/p&gt;
&lt;h4 id=&#34;initialize&#34;&gt;&lt;code&gt;+initialize&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;+initialize&lt;/code&gt; 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 &lt;code&gt;+initialize&lt;/code&gt; 方法是以懒加载的方式被调用的。如果程序一直没有给某各类或它的子类发送消息，那么这个类的 &lt;code&gt;+initialize&lt;/code&gt; 方法是永远不会被调用的。&lt;/p&gt;
&lt;p&gt;如果一个分类实现了 &lt;code&gt;+initialize&lt;/code&gt; 方法，那么就会对这个类中的实现造成覆盖。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;更多干货文章&#34;&gt;更多干货文章&lt;/h3&gt;
&lt;h5 id=&#34;博客wwwqiuxueweicom&#34;&gt;博客：&lt;a href=&#34;http://www.qiuxuewei.com&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;微信公众号开发者成长之路&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;img src=&#34;http://blog.image.jkxuewei.com/sou_wechat.png&#34; alt=&#34;公众号二维码&#34; loading=&#34;lazy&#34;&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
">iOS - 类与对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/nei-cun-guan-li-ci-pan-he-wen-jian-shi-yi/"" data-c="
          &lt;h1 id=&#34;内存管理-磁盘和文件拾遗&#34;&gt;内存管理、磁盘和文件拾遗&lt;/h1&gt;
&lt;h2 id=&#34;part1-内存管理&#34;&gt;Part1. 内存管理&lt;/h2&gt;
&lt;p&gt;一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。&lt;br&gt;
可读写部分（变量）大致可分为下面几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：初始化了的全局变量和静态变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：即 &lt;code&gt;Block Started by Symbol&lt;/code&gt;，未初始化的全局变量和静态变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap&lt;/code&gt;：堆，使用 &lt;code&gt;malloc&lt;/code&gt;、&lt;code&gt;realloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack&lt;/code&gt;：栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-data-和-bss-区&#34;&gt;1. &lt;code&gt;.data&lt;/code&gt; 和 &lt;code&gt;.bss&lt;/code&gt; 区&lt;/h3&gt;
&lt;p&gt;这两个经常放在一起说，因为他们都是用来存储全局变量和静态变量的，区别在于 &lt;code&gt;.data&lt;/code&gt; 区存放的初始化过的，&lt;code&gt;.bss&lt;/code&gt;区存放的是没有初始化过的。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int val = 3;
char string[] = &#39;Hello World&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个变量的值会在一开始被存储在 &lt;code&gt;.text&lt;/code&gt; 中，因为值是写在代码里面的，在程序启动时会拷贝到 &lt;code&gt;.data&lt;/code&gt; 区中。&lt;br&gt;
若不初始化，类似:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个变量就会被放在 &lt;code&gt;.bss&lt;/code&gt; 区中。&lt;/p&gt;
&lt;h4 id=&#34;静态变量和全局变量&#34;&gt;静态变量和全局变量&lt;/h4&gt;
&lt;h5 id=&#34;全局变量&#34;&gt;全局变量&lt;/h5&gt;
&lt;p&gt;在一个代码文件中，一个变量要么定义在函数中，要么定义在函数外。当定义在函数外时，这个变量就有了全局作用域，成为了全局变量。&lt;br&gt;
全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫 &lt;code&gt;external linkage&lt;/code&gt;）。&lt;br&gt;
当有如下两个文件时：&lt;br&gt;
A.c&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int a;
int compute(void);
int main()
{
    a = 1;
    printf(&amp;quot;%d %d&amp;quot;, a, compute());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B.c&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a;
int compute(void)
{
    a = 0;
    return a;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编译过程中会产生重复定义的错误！因为有两个全局的 a 变量，编译器不知道应该使用哪一个，为了避免这种问题，就需要引入 &lt;code&gt;static&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&#34;静态变量&#34;&gt;静态变量&lt;/h5&gt;
&lt;p&gt;使用 &lt;code&gt;static&lt;/code&gt; 关键字修饰的变量，&lt;code&gt;static&lt;/code&gt; 关键字对变量的作用域进行了限制，具体的限制如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）。&lt;/li&gt;
&lt;li&gt;在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C++&lt;/code&gt; 在类中定义：全局变量，但是只在此类中可见&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用 &lt;code&gt;static&lt;/code&gt;，另一个不使用，这样使用 &lt;code&gt;static&lt;/code&gt; 的就会使用自己的 a 变量，而没有用 &lt;code&gt;static&lt;/code&gt; 的会使用全局的 a 变量。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：&lt;code&gt;静态&lt;/code&gt;这个中文翻译有点莫名其妙，给人的感觉像是不可改变的，实际上&lt;code&gt;static&lt;/code&gt; 跟不可改变没有关系，不可改变的变量使用 &lt;code&gt;const&lt;/code&gt; 关键字修饰！！！&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&#34;extern&#34;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;extern&lt;/code&gt; 是 C 语言的另一个关键字，用来指示变量或函数的定义在别的文件中，使用 &lt;code&gt;extern&lt;/code&gt; 可以在多个源文件中共享某个变量。&lt;/p&gt;
&lt;h4 id=&#34;程序在内存和硬盘上不同的存在形式&#34;&gt;程序在内存和硬盘上不同的存在形式&lt;/h4&gt;
&lt;p&gt;这里提到的四个区，是指程序在&lt;strong&gt;内存&lt;/strong&gt;中存在的形式，和程序在&lt;strong&gt;硬盘&lt;/strong&gt;上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考：&lt;a href=&#34;https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats&#34;&gt;wikipedia&lt;/a&gt;。&lt;br&gt;
一个明显的例子区分这个差别：&lt;br&gt;
之前提到的未定义的全局变量存储在 &lt;code&gt;.bss&lt;/code&gt; 区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储他们的值，在程序启动过程中，他们的值会被初始化成 0，存储在内存中。&lt;/p&gt;
&lt;h3 id=&#34;2-栈&#34;&gt;2. 栈&lt;/h3&gt;
&lt;p&gt;栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。&lt;br&gt;
栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示：&lt;code&gt;stackoverflow&lt;/code&gt;。&lt;br&gt;
栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈、出栈都有专门的指令执行，这就决定了栈的效率比较高。&lt;/p&gt;
&lt;h3 id=&#34;3-堆&#34;&gt;3. 堆&lt;/h3&gt;
&lt;p&gt;堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;free&lt;/code&gt; 时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生 &lt;code&gt;memory leak&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;堆是向高地址扩展的数据结构，是不连续的内存区域。这里由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。&lt;/p&gt;
&lt;p&gt;对于堆而言，频繁的 &lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt; 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈而言，则不会出现这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。&lt;/p&gt;
&lt;p&gt;堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 &lt;code&gt;alloca&lt;/code&gt; 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。&lt;/p&gt;
&lt;p&gt;计算机底层并没有对堆的支持，堆则是 C/C++ 函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。&lt;/p&gt;
&lt;h2 id=&#34;part2-内存分配&#34;&gt;Part.2 内存分配&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虚拟地址：用户编译时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址。&lt;/li&gt;
&lt;li&gt;逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址。&lt;/li&gt;
&lt;li&gt;物理地址：实际物理内存中所看到的存储地址称为物理地址。&lt;/li&gt;
&lt;li&gt;逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加以区分，通称为逻辑地址，逻辑地址的几个称为逻辑地址空间。&lt;/li&gt;
&lt;li&gt;线性地址空间：CPU 地址总线可以访问的所有地址合称为线性地址空间。&lt;/li&gt;
&lt;li&gt;物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间。&lt;/li&gt;
&lt;li&gt;MMU（Memery Management Unit）内存管理单元：实现将用户程序的虚拟地址（逻辑地址）-&amp;gt; 物理地址映射的 CPU 中的硬件电路。&lt;/li&gt;
&lt;li&gt;基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算。&lt;/li&gt;
&lt;li&gt;偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。&lt;/p&gt;
&lt;h2 id=&#34;part3-虚拟内存&#34;&gt;Part.3 虚拟内存&lt;/h2&gt;
&lt;h3 id=&#34;请求调页&#34;&gt;请求调页&lt;/h3&gt;
&lt;p&gt;也成为按需调页，即对不在内存中的“页”，当进程执行时才调入，否则有可能到程序结束时也不会调入。&lt;/p&gt;
&lt;h3 id=&#34;页面置换算法&#34;&gt;页面置换算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FIFO 算法&lt;br&gt;
先入先出，即淘汰最早调入的页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OPT（MIN） 算法&lt;br&gt;
选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。&lt;br&gt;
可惜，MIN 需要知道将来发生的事，只能在理论中存在，实际不可应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LRU（Least-Recently-Used） 算法&lt;br&gt;
用过去的历史预测将来，选最近最长时间没有使用的页淘汰（也称最近最少使用）。LRU 准确实现：计数器法，页码栈法。由于代价较高，通常不使用准确实现，而是采用近似实现，例如 &lt;code&gt;Clock&lt;/code&gt; 算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存抖动&#34;&gt;内存抖动&lt;/h3&gt;
&lt;p&gt;页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。&lt;br&gt;
抖动一般是内存分配算法不好，内存太小引起或者程序的算法不佳引起的。&lt;/p&gt;
&lt;h3 id=&#34;belady-现象&#34;&gt;&lt;code&gt;Belady&lt;/code&gt; 现象&lt;/h3&gt;
&lt;p&gt;对有的页面置换算法，页错误率可能会随着分配帧数的增加而增加。&lt;br&gt;
FIFO 会产生 &lt;code&gt;Belady&lt;/code&gt; 异常。&lt;br&gt;
栈式算法无 &lt;code&gt;Belady&lt;/code&gt; 异常，LRU、LFU（最不经常使用）、OPT 都属于栈式算法。&lt;/p&gt;
&lt;h2 id=&#34;part4-磁盘调度&#34;&gt;Part.4 磁盘调度&lt;/h2&gt;
&lt;p&gt;磁盘访问延迟 = 队列时间 + 控制器时间 + 寻道时间 + 旋转时间 + 传输时间。&lt;br&gt;
磁盘调度的目的是减小延迟，其中前两项可以忽略，寻道时间是主要矛盾。&lt;/p&gt;
&lt;h3 id=&#34;磁盘调度算法&#34;&gt;磁盘调度算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FCFS&lt;br&gt;
先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSTF（Shortest-seek-time 最短寻道时间优先）&lt;br&gt;
选择使磁头从当前位置开始移动最少的磁盘 I/O 请求，所以 SSTF 总是选择导致最小寻道时间的请求。&lt;br&gt;
总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS 算法更好的性能，会存在饥饿现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SCAN&lt;br&gt;
SSTF + 中途不回折，每个请求都有处理机会。&lt;br&gt;
SCAN 要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止。&lt;br&gt;
由于磁头移动规律与电梯运行相似，SCAN 也被称为电梯算法。&lt;br&gt;
SCAN 算法对最近扫描过的区域不公平，因此，它的访问局部性方面不如 FCFS 算法和 SSTF 算法好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C-SCAN&lt;br&gt;
SCAN + 直接移到另一端，两端请求都能很快处理。&lt;br&gt;
把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描。&lt;br&gt;
其中 “C” 是 &lt;code&gt;Circular(环)&lt;/code&gt;的意思。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LOOK 和 C-LOOK&lt;br&gt;
采用 SCAN 算法和 C-SCAN 算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的 SCAN 算法和 C-SCAN 算法称为 LOOK 和 C-LOOK 调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part5-文件系统&#34;&gt;Part5. 文件系统&lt;/h2&gt;
&lt;h3 id=&#34;分区表&#34;&gt;分区表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MBR：支持最大卷为 2TB（Terabytes），并且每个磁盘最多有 4 个主分区（或 3 个主分区、1 个扩展分区和无限制的逻辑驱动器）&lt;/li&gt;
&lt;li&gt;GPT：支持最大卷为 18EB（Exabytes），并且每磁盘的分区数没有上限，只受到操作系统限制，由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64版 Windows 限制最多有 128 个分区，这也是 EFI 标准规定的分区表的最小尺寸。另外 GPT 分区磁盘有备份分区表来提高分区数据结构的完整性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;raid-技术&#34;&gt;RAID 技术&lt;/h3&gt;
&lt;p&gt;独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks），旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。&lt;/p&gt;
&lt;p&gt;在运作中，取决于 RAID 层级不同，数据会以多种模式分散于各个硬盘，RAID 层级的命名会以 RAID 开头并带数字，例如：RAID 0、RAID 1、RAID 5、RAID 6、RAID 7、RAID 01、RAID 10、RAID 50、RAID 60。每种等级都有其理论上的优缺点，不同的等级在两个目标间获取平衡，分别是增加数据可靠性以及增加存储器（群）读写性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RAID 0&lt;br&gt;
RAID 0 是最早出现的 RAID 模式，需要两块以上的硬盘，可以提高整个磁盘的性能和吞吐量。&lt;br&gt;
RAID 0 没有提供冗余或错误修复能力，其中一块硬盘损坏，所有的数据将遗失。&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221775.15778853893740.jpg&#34; alt=&#34;-w183&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAID 1&lt;br&gt;
RAID 1 就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据，当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以 RAID 1 的数据安全性在所有 RAID 级别上来说是最好的。&lt;br&gt;
但无论用多少磁盘做 RAID 1，仅算一个磁盘的容量，是所有 RAID 中磁盘利用率最低的。&lt;br&gt;
实际容量：&lt;code&gt;Size = min(S1, S2, S3 ... Sn)&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221788.15778854865641.jpg&#34; alt=&#34;-w175&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAID 2&lt;br&gt;
这是 RAID 0 的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID 2 至少需要三台磁盘驱动器方能运作。&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221801.15778855454481.jpg&#34; alt=&#34;-w348&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAID 3&lt;br&gt;
采用 Bit-interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在磁盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适用于读取大量数据时使用。&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221815.15778855779280.jpg&#34; alt=&#34;-w258&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAID 4&lt;br&gt;
它与 RAID 3 不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（快交织技术，Block interleaving）。&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221828.15778855992090.jpg&#34; alt=&#34;-w256&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RAID 2、3、4 在实际应用中很少使用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAID 5&lt;br&gt;
RAID Level 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案，他使用的是 Disk Striping（硬盘分区）技术。&lt;br&gt;
RAID 5 至少需要三块硬盘，RAID 5 不是对存储的数据进行备份，而是把数据和相对应的数据分别存储于不同的磁盘上。&lt;br&gt;
RAID 5 允许一块硬盘损坏。&lt;br&gt;
实际容量：&lt;code&gt;Size = (N - 1) * min(S1, S2, S3... SN)&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221842.15778856469979.jpg&#34; alt=&#34;-w263&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAID 6&lt;br&gt;
与 RAID 5 相比，RAID 6 增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。&lt;br&gt;
RAID 6 至少需要 4 块硬盘。&lt;br&gt;
实际容量：&lt;code&gt;Size = (N - 2) * min(S1, S2, S3 ... SN)&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221858.15778857093463.jpg&#34; alt=&#34;-w304&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAID 10/01 (RAID 1 + 0, RAID 0 + 1)&lt;br&gt;
RAID 10 是先镜射再分区数据，再将所有硬盘分为两组，视为是 RAID 0 的最低组合，然后将这两组各自视为 RAID 1 运作。&lt;br&gt;
RAID 01 则是跟 RAID 10 的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成 RAID 1 的最低组合，而将两组硬盘各自视为 RAID 0 运作。&lt;br&gt;
当 RAID 10 有一个硬盘受损，其余硬盘会继续运作，RAID 01 只要有一个硬盘受损，同组 RAID 0 的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。&lt;br&gt;
如果以 6 个硬盘建 RAID 01，镜射再用三个建 RAID 0，那么坏一个硬盘便会有三个硬盘脱机，因此，RAID 10 远比 RAID 01 常用，零售主板绝大多数支持 RAID 0/1/5/10, 但不支持 RAID 01.&lt;br&gt;
RAID 10 至少需要 4 块硬盘，且硬盘数量必须为偶数。&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221874.15778861611396.jpg&#34; alt=&#34;-w271&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见的文件系统&#34;&gt;常见的文件系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Windows：FAT，FAT16，FAT32，NTFS&lt;/li&gt;
&lt;li&gt;Linux：ext2/3/4，btrfs，ZFS&lt;/li&gt;
&lt;li&gt;Mac OS X：HFS+&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;更多干货文章&#34;&gt;更多干货文章&lt;/h3&gt;
&lt;h5 id=&#34;博客wwwqiuxueweicom&#34;&gt;博客：&lt;a href=&#34;http://www.qiuxuewei.com&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;微信公众号开发者成长之路&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;img src=&#34;http://blog.image.jkxuewei.com/sou_wechat.png&#34; alt=&#34;公众号二维码&#34; loading=&#34;lazy&#34;&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
">内存管理、磁盘和文件拾遗</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/bing-fa-ji-zhu-jin-cheng-xian-cheng-he-suo-shi-yi/"" data-c="
          &lt;h1 id=&#34;并发技术-进程-线程和锁拾遗&#34;&gt;并发技术、进程、线程和锁拾遗&lt;/h1&gt;
&lt;h2 id=&#34;part1-多任务&#34;&gt;Part1. 多任务&lt;/h2&gt;
&lt;p&gt;计算机发展起初，CPU 资源十分昂贵，如果让 CPU 只能运行一个程序那么当 CPU 空闲下来（例如等待 I/O 时），CPU 资源就会被浪费，为了使 CPU 资源得到更好的利用，先驱编写了一个监控程序，如果发现某个程序暂时无需使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动起来，以充分利用 CPU资源。这种方法称为 - &lt;strong&gt;多道程序（Multiprogramming）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于多道程序，最大的弊端是各程序之间不区分轻重缓急，对于用户交互式的程序来说，对 CPU 计算时间的需求并不多，但是对于响应速度却有比较高的要求。而对于计算类程序来说则相反，对响应速度要求低，但需要长时间的 CPU 计算。想象一个场景：我在同时在浏览网页和听音乐，我们希望浏览器能够快速响应，同时也希望音乐不停，这时候&lt;strong&gt;多道程序&lt;/strong&gt;就没法达到我们的要求了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;于是人们改进了&lt;strong&gt;多道程序&lt;/strong&gt;，使得每个程序运行一段时间之后，都主动让出 CPU 资源，这样每个程序在一段时间内都有机会运行一小段时间。这样像浏览器这样的交互式程序就能够快速地被处理，同时计算类程序也不会受到很大影响。这种程序协作方式被称为 &lt;strong&gt;分时系统（Time-Sharing System）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在分时系统的帮助下，我们可以边用浏览器边听歌了。&lt;strong&gt;但是&lt;/strong&gt;如果某个程序出现了错误，导致了死循环，不仅仅是这个程序会出错，整个系统都会死机，为了避免这种情况，一个更为先进的操作系统模式被发明处理，也就是我们现在熟悉的&lt;strong&gt;多任务系统（Multi-tasking System）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;操作系统从最底层接管了所有硬件资源。所有的应用程序在操作系统上以 &lt;strong&gt;进程（Process）&lt;/strong&gt; 的方式运行，每个进程都有自己独立的地址空间，相互隔离。CPU 由操作系统统一统一进行分配。每个进程都有机会得到 CPU，同时在操作系统控制下，如果一个进程运行超过了一定时间，就会被暂停掉，失去 CPU 资源。这样就避免了一个程序的错误导致整个系统死机。如果操作系统分配给各个进程的运行时间都很短，CPU 可以在多个进程间快速切断，就像很多进程都同时在运行的样子。几乎所有现代操作系统都是采用这样的方式支持多任务。&lt;/p&gt;
&lt;h2 id=&#34;part2-进程&#34;&gt;Part2. 进程&lt;/h2&gt;
&lt;p&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。它可以申请和拥有系统资源，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理递存器的内容来表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程是一个实体，每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。&lt;/li&gt;
&lt;li&gt;进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-进程的基本状态&#34;&gt;1. 进程的基本状态&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;等待态：等待某个事件的完成；&lt;/li&gt;
&lt;li&gt;就绪态：等待系统分配处理器以便运行；&lt;/li&gt;
&lt;li&gt;运行态：占有处理器正在运行；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;几种状态的切换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行态 -&amp;gt; 等待态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。&lt;/li&gt;
&lt;li&gt;等待态 -&amp;gt; 就绪态：则是等待的条件已满足，只需分配到处理器后就能运行。&lt;/li&gt;
&lt;li&gt;运行态 -&amp;gt; 就绪态：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时就变成就绪态。例如：时间片用完，或有更高优先级的进程来抢占处理器等&lt;/li&gt;
&lt;li&gt;就绪态 -&amp;gt; 运行态：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-进程调度&#34;&gt;2. 进程调度&lt;/h3&gt;
&lt;h4 id=&#34;调度种类&#34;&gt;调度种类&lt;/h4&gt;
&lt;p&gt;高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高级调度（High-Level Scheduling）:又称为作业调度，它决定把后备作业调入内存运行；&lt;/li&gt;
&lt;li&gt;中级调度（Intermediate-Level Scheduling）:又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。&lt;/li&gt;
&lt;li&gt;低级调度（Low-Level Scheduling）:又称为进程调度，它决定把就绪队列的某进程获得 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;非抢占式调度与抢占式调度&#34;&gt;非抢占式调度与抢占式调度&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式&lt;br&gt;
分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或者发生进程调度某事件而阻塞时，才把处理机分配给另一个进程。&lt;/li&gt;
&lt;li&gt;抢占式&lt;br&gt;
操作系统将正在运行的进程强行暂停，由调度程序将 CPU 分配给其他就绪进程的调度方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调度策略的设计&#34;&gt;调度策略的设计&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;响应时间：从用户输入到产生反应的时间&lt;/li&gt;
&lt;li&gt;周转时间：从任务开始到任务结束的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU 任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用 CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。&lt;/p&gt;
&lt;h4 id=&#34;调度算法&#34;&gt;调度算法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FIFO 或 First Come，First Served（FCFS）&lt;br&gt;
调度的顺序就是任务到达就绪队列的顺序。&lt;br&gt;
公平、简单（FIFO 队列）、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shortest Job First（SJF）&lt;br&gt;
最短的作业（CPU 区间长度最小）优先调度&lt;br&gt;
可以证明，SJF 可以保证最小的平均等待时间&lt;br&gt;
Shortest Job First （SRJF）： SJF 的可抢占版本，比 SJF 更有优势&lt;br&gt;
SJF、SRJF 如何知道下一 CPU 区间大小？根据历史进行预测：指数平均法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先权调度&lt;br&gt;
每个任务关联一个优先权、调度优先权最高的任务。&lt;br&gt;
注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。&lt;br&gt;
FCFS 是 RR 的特例，SJF 是优先权调度的特例，这些调度算法都不适合于交互式系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round-Robin（RR）&lt;br&gt;
设置一个时间片，按时间片来轮转调度（“轮叫”算法）&lt;br&gt;
优点：定时有响应，等待时间较短；缺点：上下文切换次数较多；&lt;br&gt;
如何确定时间片？时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为 FCFS。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级队列调度&lt;br&gt;
按照一定的规则建立多个进程队列&lt;br&gt;
不同的队列有固定的优先级（高优先级有抢占权）&lt;br&gt;
不同的队列可以给不同的时间片和采用不同的调度方法&lt;br&gt;
存在问题 1：没法区分 I/O bound 和 CPU bound；&lt;br&gt;
存在问题 2：也存在一定程度的“饥饿”现象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级反馈队列&lt;br&gt;
在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。&lt;br&gt;
可以根据“享用”CPU 时间多少来移动队列，阻止“饥饿”。&lt;br&gt;
最通用的调度算法，多数 OS 都使用该方法或其变形，如 UNIX、Windows 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-进程同步&#34;&gt;3. 进程同步&lt;/h3&gt;
&lt;h4 id=&#34;临界资源与临界区&#34;&gt;临界资源与临界区&lt;/h4&gt;
&lt;p&gt;在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。&lt;br&gt;
典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等（如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题）。&lt;br&gt;
对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被称为临界区。&lt;/p&gt;
&lt;p&gt;解决临界区问题可能的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般软件方法&lt;/li&gt;
&lt;li&gt;关中断方法&lt;/li&gt;
&lt;li&gt;硬件原子指令方法&lt;/li&gt;
&lt;li&gt;信号量方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;信号量&#34;&gt;信号量&lt;/h4&gt;
&lt;p&gt;信号量是一个确定的二元组（s，q），其中 s 是一个具有非负初值的整型变量，q 是一个初始状态为空的队列，整型变量 s 表示系统中某类资源的数目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 s ≥ 0 时，表示系统中当前可用资源的数目&lt;/li&gt;
&lt;li&gt;当 s &amp;lt; 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除信号量的初值外，信号量的值仅能由 P 操作和 V 操作更改，操作系统利用它的状态对进程和资源进行管理。&lt;/p&gt;
&lt;p&gt;P 操作：P 操作记为 P(s)，其中 s 为一信号量，它执行时主要完成以下动作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 可理解为占用一个资源，若原来就没有则记账“欠”1 个
s.value = s.value - 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若 &lt;code&gt;s.value ≥ 0&lt;/code&gt;，则进程继续执行，否则（即&lt;code&gt;s.value &amp;lt; 0&lt;/code&gt;），则进程被阻塞，并将该进程插入到信号量 s 的等待队列 s.queue 中。&lt;br&gt;
&lt;em&gt;实际上，P 操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;V 操作：V 操作记为 V(s)，其中 s 为一信号量，它执行时，主要完成以下动作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 可理解为归还一个资源，若原来就没有则意义是用此资源还 1 个欠账
s.value = s.value + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若 &lt;code&gt;s.value &amp;gt; 0&lt;/code&gt;，则进程继续执行，否则（即 &lt;code&gt;s.value ≤ 0&lt;/code&gt;），则从信号量 s 的等待队列 s.queue 中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行。&lt;br&gt;
&lt;em&gt;实际上，V 操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;信号量方法实现：生产者 - 消费者互斥与同步控制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;semaphore fullBuffers = 0;//仓库中已填满的货架个数
semaphore emptyBuffers = BUFFER_SIZE;//仓库货架空闲个数
semaphore mutex = 1;//生产 - 消费互斥信号

Producer() 
{ 
    while(True)
    {  
       /*生产产品item*/
       emptyBuffers.P(); 
       mutex.P(); 
       /*item存入仓库buffer*/
       mutex.V();
       fullBuffers.V();
    }
}
 
Consumer() 
{
    while(True)
    {
        fullBuffers.P(); 
        mutex.P();	
        /*从仓库buffer中取产品item*/
        mutex.V();
        emptyBuffers.V();
        /*消费产品item*/
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;死锁&#34;&gt;死锁&lt;/h4&gt;
&lt;p&gt;死锁：多个进程因循环等待而造成的无法执行的现象&lt;br&gt;
死锁会造成进程无法执行，同时会造成系统资源的极大浪费（资源无法释放）。&lt;br&gt;
死锁产生的 4 个必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥使用（Mutual exclusion）
&lt;ul&gt;
&lt;li&gt;指进程对所有分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可抢占（No preemption）
&lt;ul&gt;
&lt;li&gt;指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;请求和保持（Hold and wait）
&lt;ul&gt;
&lt;li&gt;指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得其他资源保持不放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环等待（Circular wait）
&lt;ul&gt;
&lt;li&gt;指在发生死锁时，必然存在一个进程-资源的环形链，即进程集合{P0, P1, P2, P3, P4, ..., Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，...，Pn 正在等待已被 P0 占用的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;死锁的避免：银行家算法&lt;br&gt;
思想：判断此次请求是否造成死锁，若会造成死锁，则拒绝该请求。&lt;/p&gt;
&lt;h3 id=&#34;4-进程间通信&#34;&gt;4. 进程间通信&lt;/h3&gt;
&lt;p&gt;本地进程间通信的方式有很多，可以总结为下面四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息传递（管道、FIFO、消息队列）&lt;/li&gt;
&lt;li&gt;同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）&lt;/li&gt;
&lt;li&gt;共享内存（匿名的和具名的）&lt;/li&gt;
&lt;li&gt;远程过程调用（Solaris门 和 Sun RPC）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part3-线程&#34;&gt;Part3. 线程&lt;/h2&gt;
&lt;p&gt;多线程解决了前面提到的多任务问题。然而很多时候不同的程序需要共享同样的资源（文件，信号量等），如果全都使用进程的话会导致切换的成本很高，造成 CPU 资源的浪费。于是出现了线程的概念。&lt;br&gt;
线程，有时被称为轻量级进程（Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程 ID，当前指令指针（PC），寄存器集合和堆栈组成。&lt;br&gt;
线程具有以下属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;轻型实体&lt;br&gt;
线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括：程序、数据和 TCB（Thread Control Block）。线程是动态概念，它的动态特性由线程控制块 TCB 描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立调度和分派的基本单位&lt;br&gt;
在多线程 OS 中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本的单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可并发执行&lt;br&gt;
在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享进程资源&lt;br&gt;
在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问改地址空间的每一个虚拟地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。&lt;br&gt;
线程共享的环境包括：进程代码段、进程的公有数据（利用这些共享的数据，线程很容易的实现相互之前的通讯）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户 ID 与进程组 ID。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;part4-锁&#34;&gt;Part4. 锁&lt;/h2&gt;
&lt;p&gt;锁要解决的是线程之间争夺资源的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源是否是独占（独占锁 - 共享锁）&lt;/li&gt;
&lt;li&gt;抢占不到资源怎么办（互斥锁 - 自旋锁）&lt;/li&gt;
&lt;li&gt;自己能不能重复抢（重入锁 - 不可重入锁）&lt;/li&gt;
&lt;li&gt;竞争读的情况比较多，读可不可以不加锁（读写锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面几个角度并非相互独立，在实际场景中需要将他们集合起来才能构造出一个合适的锁。&lt;/p&gt;
&lt;h3 id=&#34;独占锁-共享锁&#34;&gt;独占锁 - 共享锁&lt;/h3&gt;
&lt;p&gt;当一个共享资源只有一份的时候，通常我们使用独占锁，常见的即各个语言中的 &lt;code&gt;Mutex&lt;/code&gt;。当共享资源有多份时，可以使用信号量（Semaphere）。&lt;/p&gt;
&lt;h3 id=&#34;互斥锁-自旋锁&#34;&gt;互斥锁 - 自旋锁&lt;/h3&gt;
&lt;p&gt;对于互斥锁来说，如果一个线程已经锁定了一个互斥锁，第二个线程又试图去获取这个互斥锁，则第二个线程将会被挂起（即休眠、不占用 CPU 资源）。&lt;/p&gt;
&lt;p&gt;在计算机系统中，频繁的挂起和切换线程，也是有成本的。自旋锁就是解决这个问题的。&lt;/p&gt;
&lt;p&gt;自旋锁：指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。&lt;/p&gt;
&lt;p&gt;容易看出，当资源等待的时间较长，用互斥锁让线程休眠，会消耗更少的资源，当资源等待的时间较短时，使用自旋锁将减少线程的切换，获得更高的性能。&lt;/p&gt;
&lt;p&gt;Java 中的 &lt;code&gt;synchornized&lt;/code&gt; 和 .NET 中的 &lt;code&gt;lock&lt;/code&gt;（&lt;code&gt;Monitor&lt;/code&gt;）的实现，是结合了两种锁的特点。简单说，它们在发现资源被抢占之后，会先试着自旋等待一段时间，如果等待时间太长，则会进入挂起状态。通过这样的实现，可以较大程度上挖掘出锁的性能。&lt;/p&gt;
&lt;h3 id=&#34;重入锁-不可重入锁&#34;&gt;重入锁 - 不可重入锁&lt;/h3&gt;
&lt;p&gt;可重入锁（ReetrantLock），也叫作递归锁，指的是同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。&lt;br&gt;
换而言之：同一线程再次进入同步代码时，可以使用自己已获取到的锁。&lt;/p&gt;
&lt;p&gt;使用可重入锁时，在同一线程中多次获取锁，不会导致死锁。使用不可重入锁，则会导致死锁发生。&lt;/p&gt;
&lt;p&gt;Java 中的 &lt;code&gt;synchornized&lt;/code&gt; 和 .NET 中的 &lt;code&gt;lock&lt;/code&gt;（&lt;code&gt;Monitor&lt;/code&gt;） 都是可重入的。&lt;/p&gt;
&lt;h3 id=&#34;读写锁&#34;&gt;读写锁&lt;/h3&gt;
&lt;p&gt;有些情况下，对于共享资源读竞争的情况远远多于写竞争，这种情况下，对读操作每次都进行加锁，是得不偿失的。读写锁就是为了解决这个问题。&lt;/p&gt;
&lt;p&gt;读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有读线程和其他的写线程都会被阻塞。简单可以总结为，读读不互斥，读写互斥，谢谢互斥。&lt;/p&gt;
&lt;p&gt;对读写锁来说，有一个升级和降级的概念，即当前获得了读锁，想把当前的锁变成写锁，成为升级，反之称为降级。锁的升降级本身也是为了提升性能，通过改变当前锁的性质，避免重复获取锁。&lt;/p&gt;
&lt;h2 id=&#34;part5-协程&#34;&gt;Part.5 协程&lt;/h2&gt;
&lt;p&gt;协程，又称为微线程，纤程。英文名： Coroutine&lt;br&gt;
协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多 CPU 的能力。&lt;/p&gt;
&lt;h2 id=&#34;part6-io多路复用&#34;&gt;Part.6 IO多路复用&lt;/h2&gt;
&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，他就通知该进程。IO 多路复用适用于如下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用 I/O 复用。&lt;/li&gt;
&lt;li&gt;当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。&lt;/li&gt;
&lt;li&gt;如果一个 TCP 服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到 I/O 复用。&lt;/li&gt;
&lt;li&gt;如果一个度武器既要处理 TCP，又要处理 UDP，一般要使用 I/O 复用。&lt;/li&gt;
&lt;li&gt;如果一个服务器要处理多个服务或多个协议，一般要使用 I/O 复用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建 进程/线程，也不必维护这些 进程/线程，从而大大减小了系统的开销。&lt;/p&gt;
&lt;h3 id=&#34;常见的-io-复用实现&#34;&gt;常见的 IO 复用实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select （Linux/Windows/BSD）&lt;/li&gt;
&lt;li&gt;epoll （Linux）&lt;/li&gt;
&lt;li&gt;kqueue （BSD/Mac OS）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;更多干货文章&#34;&gt;更多干货文章&lt;/h3&gt;
&lt;h5 id=&#34;博客wwwqiuxueweicom&#34;&gt;博客：&lt;a href=&#34;http://www.qiuxuewei.com&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;微信公众号开发者成长之路&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;img src=&#34;http://blog.image.jkxuewei.com/sou_wechat.png&#34; alt=&#34;公众号二维码&#34; loading=&#34;lazy&#34;&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
">并发技术、进程、线程和锁拾遗</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/ru-he-cheng-wei-you-xiao-xue-xi-de-gao-shou/"" data-c="
          &lt;h1 id=&#34;如何成为有效学习的高手&#34;&gt;《如何成为有效学习的高手》&lt;/h1&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;高效学习的定义是找到适合自己的学习方法,在最短的时间里能够集中注意力,以解决生活或工作中的一个任务为目的着手学习. 需要勤加练习,必要的时候要向名师求助!&lt;/p&gt;
&lt;p&gt;这其中有七个关键点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;适合自己&lt;/li&gt;
&lt;li&gt;学习方法&lt;/li&gt;
&lt;li&gt;最短时间&lt;/li&gt;
&lt;li&gt;注意力&lt;/li&gt;
&lt;li&gt;解决任务&lt;/li&gt;
&lt;li&gt;设定目标&lt;/li&gt;
&lt;li&gt;名师&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1找到适合自己的学习方法&#34;&gt;1.找到适合自己的学习方法&lt;/h2&gt;
&lt;h4 id=&#34;自然主义和结构主义&#34;&gt;自然主义和结构主义&lt;/h4&gt;
&lt;p&gt;这是两种针对不同知识门类需采用的两种不同的学习方法. 学语言, 学乐器演奏. 如果你采用从最基础的语法,字母,音符开始学. 虽然能学成, 但是这不是最合适的学习方法. 咱所说的话从来没有从语法开始学起, 照样能说的好. 何况是世界上最难学习的语言之一的中文. 如果从基础开始学, 相对低效. 并且是用需要用自然主义的学习方法用了结构主义去学. 这样只会事倍功半.&lt;/p&gt;
&lt;p&gt;自然主义的学习方法简单来说是模仿,结构主义为的是创新&lt;/p&gt;
&lt;p&gt;像语言,乐器,书法这类知识适合用自然主义学习. 像医药,艺术,经济学,程序这类需要创新的要用结构主义去学.&lt;/p&gt;
&lt;p&gt;选对学习方法能够做到有效的学习, 如何使其升级为高效这就需要一些学习方法. 最简单是把目标拆碎. 针对每一个细节反复练习, 不要一开始就顾全大局. 成年人很难把一大段时间空闲出来全神贯注专注一个技能的学习, 碎片化学习变得尤为重要. 在碎片化的时间里做到高效也有技巧, 就是带着问题和困惑去执行碎片化学习, 并且多使用搜索这个功能. 要注意的一点有一种假的碎片化学习叫做收藏, 这里看到一篇好文章想到的不是马上阅读而是收藏到收藏夹里! 等以后有时间再看, 这里要告诉你, 很难, 非常难! 即便你以后有时间了, 也不会来学这篇文章. 所以收藏夹我建议只有一天或者两天的有效期, 不要超过两天! 否则收藏夹没有存在的意义! 在地铁上看到一篇很棒的文章首选立即去读它,读完, 实在看不完可以收藏起来晚上回家继续看完. 需要敲代码的地方如果不方便马上敲出来可以晚上回去敲. 这样的话你偶遇的这篇文章会彻底成为你的知识积累, 而不是收藏夹里那些无用的东西.&lt;/p&gt;
&lt;h2 id=&#34;2不谈兴趣-用任务驱动学习&#34;&gt;2.不谈兴趣, 用任务驱动学习&lt;/h2&gt;
&lt;p&gt;都说兴趣是最好的老师, 但对于一个陌生的领域,何谈兴趣. 兴趣可以是最好的老师, 这是你了解他并发现他的美之后产生的兴趣.  成年人是不需要兴趣驱动学习的, 应该用任务来驱动. 工作中的职业强迫, 生活中的任务驱动, 以教为学 都是兴趣.&lt;/p&gt;
&lt;p&gt;在学习, 工作中经常给自己布置任务, 每一个任务作为学习的一个小阶段, 任务驱动自己这样效率会大大提升. 除此之外还可以以教为学, 通过想把这个知识传授给别人为目标, 去掌握此项技能, 自己掌握了才能教育别人, 写博客就是以教为学的典型示例. 每一个人都能成为一个很好的老师!&lt;/p&gt;
&lt;h2 id=&#34;3拖延症的-确诊和治疗&#34;&gt;3.拖延症的 &amp;quot;确诊和治疗&amp;quot;&lt;/h2&gt;
&lt;p&gt;任何人都有拖延症, 只不过有选择性的拖延, 没人会在地震的时候拖延着逃生. 所以拖延是所制定的目标不够紧迫,不够重视. 所以把所定的目标足够重视, 在心底把他作为人生不可不做的一件事. 拖延自然会消失. 将任务 &amp;quot;严峻化&amp;quot; !&lt;br&gt;
成年人在读书的时候也要讲究方法, 不能跟学生时代一样每本书都精读, 精读的意思就一字一句读到尾. 要学会速读, 拿起一本书先看目录, 如果对自己职业技能和道德品质没有多大作用果断扔掉.&lt;/p&gt;
&lt;h2 id=&#34;4在衣食住行上训练专注力&#34;&gt;4.在衣食住行上训练专注力&lt;/h2&gt;
&lt;p&gt;拖延症的本质是做事缺乏专注力.&lt;br&gt;
一段时间内, 专注做一件事. 平常的生活并不能训练人的专注力, 但是在生活中营造仪式感, 就会提升注意力. 比如: 购买昂贵的学习工具. 如果你学习某一项技能时需要工具时, 购买最贵的. 这样好的开始会是成功的一半. 学习工具昂贵你自然不会耽搁, 试想练书法有人用旧报纸, 有人用20块钱一张的宣纸, 自然后者在每写一笔都会郑重其事, 技能自然能得到突飞猛进的提升. 再者是一个人好好吃饭, 吃饭的时候点点好的, 或是做点好的, 不要吃自助. 自助不会让你吃好, 只能让你吃撑! 使用射灯, 把灯光会聚集到一处, 其他的地方时黑的, 这很好的营造一种仪式感. 进入高质量的睡眠.&lt;/p&gt;
&lt;h2 id=&#34;5直奔大师-不必从基础开始&#34;&gt;5.直奔大师, 不必从基础开始&lt;/h2&gt;
&lt;p&gt;学英语很多人都想着是从基础学起, 比如从新概念四册厚厚的教材开始学起, 很多人在看到第一册就会坚持不下去, 甚至在第一册的前几章就坚持不下去, 这很正常,因为没有一个学习英语的明确的目标, 自然没有强大的动力. 有了明确的目标之后, 也不应该是从基础学起, 而是要直奔大师! 不必从基础开始.&lt;br&gt;
要去哪里, 就从哪里开始. 比如学吉他, 如果从一个个音符学起相信很多人会觉得枯燥无味. 如果一开始学着弹一首自己喜欢的完整的吉他曲, 进而再对基础乐理知识查漏补缺, 这样学习效果会事半功倍! 怯场是最糟糕的自觉吗一个人单子变得比之前大一点, 能走的路可能就会长一点.&lt;/p&gt;
&lt;h2 id=&#34;6给自己制造反馈&#34;&gt;6.给自己制造反馈&lt;/h2&gt;
&lt;p&gt;学习要真正有效, 一定更要有反馈. 学完一项技能一定要输出, 比如掌握了一项编程知识, 要把它写成博客记录下来, 学唱了一首歌要把它录下来, 这样在输出的时候会发现掌握的情况, 也会对自己更自信, 看到一本书或是一篇文章之后, 一定要写个摘要或是笔记, 再或是发篇微博, 总之一定要有一个反馈,没人看不重要, 这是记录给自己看的! 写摘要不要脱稿写, 因为那是考研你的记忆力, 要照着文本用自己的语言进行总结输出, 另外两种反馈一是给自己录音, 给自己录像. 针对不一样的情景给自己制造不一样的反馈.&lt;/p&gt;
&lt;h2 id=&#34;7怎样突破学习瓶颈&#34;&gt;7.怎样突破学习瓶颈&lt;/h2&gt;
&lt;p&gt;首先要有一个认知, 瓶颈不是极限. 学习过程中遇到瓶颈需要调整的不是方法, 而是心态. 遇到瓶颈很可能是对自己不自信造成的. 所以解决心态问题. 把注意力放在每一件小事上, 而不要过多去想最后的结果. 这样会不知不觉的达到你想要的高度. 扩大涉猎范围, 想要突破它需要不断积累, 比如吉他弹奏遇到瓶颈之后多听一些顶级大师的吉他演奏, 会从中找到突破的. 更加专注,请教名师.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;更多干货文章&#34;&gt;更多干货文章&lt;/h3&gt;
&lt;h5 id=&#34;博客wwwqiuxueweicom&#34;&gt;博客：&lt;a href=&#34;http://www.qiuxuewei.com&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;微信公众号开发者成长之路&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;img src=&#34;http://blog.image.jkxuewei.com/sou_wechat.png&#34; alt=&#34;公众号二维码&#34; loading=&#34;lazy&#34;&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
">如何成为有效学习的高手</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/ti-xi-jie-gou-yu-cao-zuo-xi-tong-shi-yi/"" data-c="
          &lt;h1 id=&#34;体系结构与操作系统拾遗&#34;&gt;体系结构与操作系统拾遗&lt;/h1&gt;
&lt;h2 id=&#34;part1-体系结构基础&#34;&gt;Part1. 体系结构基础&lt;/h2&gt;
&lt;h3 id=&#34;1-冯诺依曼体系结构&#34;&gt;1. 冯·诺依曼体系结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;计算机处理的数据和指令一律用二进制数表示&lt;/li&gt;
&lt;li&gt;顺序执行程序
&lt;ol&gt;
&lt;li&gt;计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序从主存储器中取出指令一条一条地执行，这一概念称作顺序执行程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;2-数据的机内表示&#34;&gt;2. 数据的机内表示&lt;/h3&gt;
&lt;h4 id=&#34;二进制表示&#34;&gt;二进制表示&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;机器数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于计算机中符号和数字是一样的，都必须用二进制数串来表示，因此，正负号也必须用 0、1 来表示。&lt;/li&gt;
&lt;li&gt;用最高位 0 表示正、1 表示负，这种正负号数字化的机内表示形式就称为 “机器数”，而相应的机器外部用正负号表示的数称为“真值”，将一个真值表示成二进制字串的机器数的过程就称为编码。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原码&lt;br&gt;
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值，比如如果是 8 位二进制:&lt;br&gt;
[+1]原 = 0000 0001&lt;br&gt;
[-1]原 = 1000 0001&lt;br&gt;
第一位是符号位，因为第一位是符号位，所以 8 位二进制的取值范围就是：&lt;br&gt;
[1111 1111, 0111, 1111] 即 [-127, +127]&lt;br&gt;
原码是人脑最容易理解和计算表达方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反码&lt;br&gt;
反码的表示方法是：正数的反码就是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。&lt;br&gt;
[+1] = 原码:[0000 0001] = 反码:[0000 0001]&lt;br&gt;
[-1] = 原码:[1000 0001] = 反码:[1111 1110]&lt;br&gt;
可见如果一个反码表示负数，人脑无法直观的看出它的数值，通常要将其转换成原码再计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码&lt;br&gt;
补码的表示方法是：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1。（即在反码的基础上 +1）&lt;br&gt;
[+1] = 原码:[0000 0001] = 补码:[0000 0001]&lt;br&gt;
[-1] = 原码:[1000 0001] = 补码:[1111 1111]&lt;br&gt;
对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码再计算其数值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定点数与浮点数&lt;br&gt;
定点数是小数点固定的数。在计算机中没有专门表示小数点的位，小数点的位置是约定默认的。一般固定在机器数的最低位之后，或是固定在符号位之后。前者称为定点纯整数，后者称为定点纯小数。&lt;br&gt;
定点数表示法简单直观，但是数值表示的范围太小，运算时容易产生溢出。&lt;/p&gt;
&lt;p&gt;浮点数是小数点的位置可以变动的数。为增大数值表示范围，防止溢出，采用浮点数表示法。浮点表示法类似于十进制中的科学计数法。&lt;/p&gt;
&lt;p&gt;在计算机中，通常把浮点数分成阶码和尾数两部分来表示，其中阶码一般用补码定点整数表示，尾数一般用补码或原码定点小数表示。为保证不损失有效数字，对尾数进行格式化处理，也就是平时所说的科学计数法，即保证尾数的最高位为 1，实际数值通过阶码进行调整。&lt;br&gt;
阶符表示指数的符号位、阶码表示幂次、数符表示尾数的符号位、尾数表示格式化后的小数值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;N = 尾数 x 基数阶码（指数）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;位bit-字节byte-字word&#34;&gt;位（Bit）、字节（Byte）、字（Word）&lt;/h4&gt;
&lt;p&gt;位（Bit）：是电子计算机中最小的数据单位，每一位的状态只能是 0 或 1.&lt;/p&gt;
&lt;p&gt;字节（Byte）：8 个二进制构成 1 个字节（Byte），它是存储空间的基本计量单位。1 个字节（Byte）可以存储一个英文字母或半个汉字，换而言之：1 个汉字占据 2 个字节（Byte）的存储空间。&lt;/p&gt;
&lt;p&gt;字（Word）：由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。例如：一台 8 位机，它的 1 个字就等于 1 个字节。如果是一台 16 位机，那么它的 1 个字就由 2 个字节构成，字长为 16 位。字是计算机进行数据处理和运算的单位。&lt;/p&gt;
&lt;h4 id=&#34;字节序&#34;&gt;字节序&lt;/h4&gt;
&lt;p&gt;字节序（字节顺序）是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。&lt;/p&gt;
&lt;p&gt;小端字节序（Little Endian）：指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；&lt;br&gt;
大端字节序（Big Endian）：指高字节数据存放在低地址处，低字节数据存放在高地址处。&lt;/p&gt;
&lt;p&gt;基于 X86 平台的 PC 机是小端字节序的，而有的嵌入式平台则是大端字节序的。所有网络协议也都是采用大端字节序的方式来传输数据的，所以有时我们也会把大端字节序称之为：网络字节序。&lt;/p&gt;
&lt;p&gt;比如数字 0x12345678 在两种不同字节序 CPU 中的存储顺序如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大端字节序（Big Endian）
低地址                                            高地址
----------------------------------------------------&amp;gt;
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     12     |      34    |     56      |     78    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

小端字节序（Little Endian）
低地址                                            高地址
----------------------------------------------------&amp;gt;
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     78     |      56    |     34      |     12    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;联合体 &lt;code&gt;union&lt;/code&gt; 的存放顺序是所有成员都从低地址开始存放，利用该特性，就能判断 CPU 对内存采用 Little-Endian 还是 Big-Endian 模式读写。&lt;br&gt;
示例代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;union test {
    short value;
    char str[sizeof(short)];
}example

void main()
{
    example.value = 0x0102;
    if (sizeof(short) == 2) {
        if (example.str[0] == 1 &amp;amp;&amp;amp; example.str[1] == 2) {
            printf(&amp;quot;大端字节序&amp;quot;);
        } else if (example.str[0] == 2 &amp;amp;&amp;amp; example.str[1] == 1) {
            printf(&amp;quot;小端字节序&amp;quot;);        
        } else {
            printf(&amp;quot;结果未知&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;字节对齐&#34;&gt;字节对齐&lt;/h4&gt;
&lt;p&gt;现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。&lt;/p&gt;
&lt;h5 id=&#34;为什么要进行字节对齐&#34;&gt;为什么要进行字节对齐？&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;最根本的原因是效率问题，字节对齐能提高存取数据的速度。&lt;/li&gt;
&lt;li&gt;某些平台只能在特定的地址处访问特定类型的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如有的平台每次都是从偶地址处读取数据，对于一个 int 型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量，但是若从奇地址单元处存放，则需要 2 个读取周期读取该变量。&lt;/p&gt;
&lt;h5 id=&#34;字节对齐的原则&#34;&gt;字节对齐的原则&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;数据成员对齐规则：结构（struct）或联合（union）的数据成员，第一个数据成员放在 &lt;code&gt;offset&lt;/code&gt; 为 0 的地方，以后每个数据成员存储的起初位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组、结构体等）的整数倍开始，比如 int 在 32 位机为 4 字节，则要从 4 的整数倍地址开始存储。&lt;/li&gt;
&lt;li&gt;结构体作为成员：如果一个结构体里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。（&lt;code&gt;struct a&lt;/code&gt; 里存有 &lt;code&gt;struct b&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt; 里有 &lt;code&gt;char&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt; 等元素，那么 &lt;code&gt;b&lt;/code&gt; 应该从 8 的整数倍开始存储。）&lt;/li&gt;
&lt;li&gt;结构体的总大小，也就是 &lt;code&gt;sizeof&lt;/code&gt; 的结果，必须使其内部最大成员的整数倍，不足的要补齐。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part2-操作系统基础&#34;&gt;Part2. 操作系统基础&lt;/h2&gt;
&lt;h3 id=&#34;1-操作系统提供的服务&#34;&gt;1. 操作系统提供的服务&lt;/h3&gt;
&lt;p&gt;操作系统五大功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作业管理&lt;/li&gt;
&lt;li&gt;文件管理&lt;/li&gt;
&lt;li&gt;存储管理&lt;/li&gt;
&lt;li&gt;输入输出设备管理&lt;/li&gt;
&lt;li&gt;进程及处理机管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-中断与系统调用&#34;&gt;2. 中断与系统调用&lt;/h3&gt;
&lt;h4 id=&#34;中断&#34;&gt;中断&lt;/h4&gt;
&lt;p&gt;中断：计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序，等这些特殊事情处理完之后再回去执行之前的程序。&lt;br&gt;
中断分三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由计算机硬件异常或故障引起的中断，称为内部异常中断；&lt;/li&gt;
&lt;li&gt;由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）&lt;/li&gt;
&lt;li&gt;由外部设备请求引起的中断，称为外部中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单说，对中断的理解就是对一些特殊事情的处理。&lt;/p&gt;
&lt;p&gt;与中断紧密相连的一个概念就是中断处理程序，当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序。&lt;/p&gt;
&lt;p&gt;另一个与中断紧密相连的概念是中断的优先级，中断的优先级说明的是当一个中断正在被处理的时候，处理器能接收的中断的级别。中断的优先级表明了中断需要被处理的紧急程度，每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。&lt;br&gt;
中断优先级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;机器错误 &amp;gt; 时钟 &amp;gt; 磁盘 &amp;gt; 网络设备 &amp;gt; 终端 &amp;gt; 软件中断
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当发现软件中断时，其他所有的中断都可能发生并被处理；但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了。&lt;/p&gt;
&lt;h4 id=&#34;系统调用&#34;&gt;系统调用&lt;/h4&gt;
&lt;p&gt;进程的执行在系统上的两个级别：用户级（用户态）和核心级（系统态）。&lt;/p&gt;
&lt;p&gt;程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发生调用服务的请求，这就是系统调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口，当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。&lt;/p&gt;
&lt;p&gt;系统调用和中断的关系在于：当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。&lt;/p&gt;
&lt;p&gt;用户态和核心态区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户态的进程能存取他们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据），然而，核心态下的进程能够存取内核和用户地址。&lt;/li&gt;
&lt;li&gt;某些机器指令是特权指令，在用户态下执行特权指令会引起错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在系统中内核并不是作为一个与用户进程平行的进程的集合，内核是为用户进程运行的。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;更多干货文章&#34;&gt;更多干货文章&lt;/h3&gt;
&lt;h5 id=&#34;博客wwwqiuxueweicom&#34;&gt;博客：&lt;a href=&#34;http://www.qiuxuewei.com&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;微信公众号开发者成长之路&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;img src=&#34;http://blog.image.jkxuewei.com/sou_wechat.png&#34; alt=&#34;公众号二维码&#34; loading=&#34;lazy&#34;&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
">体系结构与操作系统拾遗</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/wang-luo-shi-yi/"" data-c="
          &lt;h1 id=&#34;网络拾遗&#34;&gt;网络拾遗&lt;/h1&gt;
&lt;h2 id=&#34;part1-http-协议&#34;&gt;Part.1 - HTTP 协议&lt;/h2&gt;
&lt;h3 id=&#34;1-http-特性&#34;&gt;1. HTTP 特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80。&lt;/li&gt;
&lt;li&gt;HTTP 是无连接无状态的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-http-报文&#34;&gt;2. HTTP 报文&lt;/h3&gt;
&lt;p&gt;HTTP 协议是以 ASCII 码进行传输的，建立在 TCP/IP 协议上的应用层规范。规范把 HTTP 分为三个部分：状态行、请求头、请求主体。HTTP 定义了与服务器交互的不同方法，常用的有如下四种：&lt;code&gt;GET&lt;/code&gt; 、&lt;code&gt;POST&lt;/code&gt; 、&lt;code&gt;DELETE&lt;/code&gt; 、&lt;code&gt;PUT&lt;/code&gt;。&lt;br&gt;
URL 全称是资源描述符，一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 &lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;、&lt;code&gt;GET&lt;/code&gt; 就对应着对这个资源的 增、删、改、查 四个操作。其他请求方式还有：&lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;OPTIONS&lt;/code&gt; 、 &lt;code&gt;TRACE&lt;/code&gt; 、 &lt;code&gt;PATCH&lt;/code&gt; 。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt; 用于信息的获取。（安全和幂等）注：安全意味着该操作用于获取信息而非修改信息。幂等意味着对同一 URL 的多个请求应返回同样的结果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; 表示可能修改服务器上的资源的请求。(非安全、非幂等)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt; 与 &lt;code&gt;GET&lt;/code&gt; 方法类似，但不返回 message body内容，仅仅是获得获取资源的部分信息（content-type、content-length）(安全和幂等)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt; 用于创建、更新资源。（非安全、幂等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt; 删除资源。（非安全、幂等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPTIONS&lt;/code&gt; 用于 URL 验证，验证接口服务是否正常。（安全、幂等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TEACE&lt;/code&gt; 回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现.（安全、幂等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATCH&lt;/code&gt; 用于创建、更新资源，于PUT类似，区别在于PATCH代表部分更新；&lt;br&gt;
后来提出的接口方法，使用时可能去要验证客户端和服务端是否支持；（非安全、幂等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GET 提交的数据量受 URL 长度的限制，HTTP 协议没有对 URL 长度进行限制，这个限制是浏览器和服务器对他的限制；理论上 POST 也是没有大小限制的，HTTP 协议也没有进行大小限制，出于安全考虑，服务器会做一定的限制。&lt;/p&gt;
&lt;h3 id=&#34;3-post-提交数据的方式&#34;&gt;3. POST 提交数据的方式&lt;/h3&gt;
&lt;p&gt;HTTP 协议中规定 POST 提交的数据必须在 Body 部分中，但协议并未规定数据需要采用何种数据格式或编码方式，服务端通常通过请求头中的 &lt;code&gt;Content-Type&lt;/code&gt; 字段来获知请求中的消息主体是以何种方式编码，再对主体进行解析。&lt;br&gt;
POST 提交数据的方案，包含：Content-Type 和消息主体编码方式两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;：最常见的 POST 数据提交方式，浏览器的原生 &lt;form&gt; 表单，如果不设置 &lt;code&gt;enctype&lt;/code&gt; 属性，最终就会以&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 方式提交数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipart/form-data&lt;/code&gt; ：使用表单上传文件时，必须让表单的 &lt;code&gt;enctype&lt;/code&gt; 等于 &lt;code&gt;multipart/form-data&lt;/code&gt; 。这种方式一般用于上传文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application/json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text/xml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application/x-protobuf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要服务器可以根据 Content-Type 和 Content-Encoding 正确解析出请求即可。&lt;/p&gt;
&lt;h3 id=&#34;4-响应报文&#34;&gt;4. 响应报文&lt;/h3&gt;
&lt;p&gt;HTTP 响应跟 HTTP 请求类似，也是由三部分构成：状态行、响应头、响应正文。&lt;br&gt;
状态行由协议版本、数字形式的状态代码、响应的状态描述构成，各元素以空格分割。常见的状态码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;200 OK&lt;/code&gt; 客户端请求成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;301 Moved Permanently&lt;/code&gt; 请求永久重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;302 Moved Temporarily&lt;/code&gt; 请求临时重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;304 Not Modified&lt;/code&gt; 文件未修改，可以直接使用缓存文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 Bad Request&lt;/code&gt; 由于客户端请求有语法错误，无法被服务器所理解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;401 Unauthorized&lt;/code&gt; 请求未经授权（状态代码必须和WWW-Authenticate报头域一起使用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;403 Forbidden&lt;/code&gt; 服务器收到请求，但拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404 Not Found&lt;/code&gt; 请求的资源不存在。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt; 服务器发生不可预知的错误，导致无法完成客户端的请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;503 Service Unavailable&lt;/code&gt; 服务器当前不可处理客户端的请求，在一段时间后服务器可能会恢复正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-条件-get&#34;&gt;5. 条件 GET&lt;/h3&gt;
&lt;p&gt;HTTP 条件 GET 是HTTP 协议为了减少不必要的宽带浪费，提出的一种方案。&lt;br&gt;
使用时机：客户端之前已经访问过该网站，并想再次访问。&lt;br&gt;
使用方法：客户端向服务端发送一个包询问是否在上次访问网站后的时间后更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只需要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。&lt;/p&gt;
&lt;h3 id=&#34;6-持久连接&#34;&gt;6. 持久连接&lt;/h3&gt;
&lt;p&gt;一般情况下，HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接。&lt;br&gt;
在 HTTP 1.0 中： 如果客户端浏览器支持 Keep-Alive，那么就在 HTTP 请求头中添加一个字段 &lt;code&gt;Connection-Keep-Alive&lt;/code&gt;。&lt;br&gt;
在 HTTP 1.1 中：默认所有连接都被保持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Keep-Alive 简单来说就是保持当前 TCP 连接，避免重新建立连接。&lt;/li&gt;
&lt;li&gt;HTTP 长连接不可能一直保持，例如 &lt;code&gt;Keep-Alive: timeout=5, max=100&lt;/code&gt;，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开.&lt;/li&gt;
&lt;li&gt;HTTP 是一个无状态协议，这意味着每个请求都是独立的，&lt;code&gt;Keep-Alive&lt;/code&gt; 没有改变这个结果，&lt;code&gt;Keep-Alive&lt;/code&gt; 无法保证客户端和服务端的连接一定是活跃的，唯一能保证的是当连接被断开时将会收到一个通知。&lt;/li&gt;
&lt;li&gt;使用长连接之后，客户端、服务端怎么知道本次传输结束呢？1. 判断传输数据是否达到了 &lt;code&gt;Content-Length&lt;/code&gt; 指示的大小,2.动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-transform-encoding&#34;&gt;7. Transform-Encoding&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Transform-Encoding&lt;/code&gt; 是一个用来标明 HTTP 报文传输格式的头部值，当前的 HTTP 规范里只定义了一种传输格式 - &lt;code&gt;chunked&lt;/code&gt;.&lt;br&gt;
如果一个 HTTP 消息请求或应答消息的 &lt;code&gt;Transform-Encoding&lt;/code&gt; 消息头的值是 chunked ，那么消息体由数量未定的块组成，并以最后一个大小为 0 的块为结束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chunked&lt;/code&gt; 和 &lt;code&gt;multipart&lt;/code&gt; 两个名词在意义上有类似的地方，不过在 HTTP 协议当中这两个概念则不是一个类别的。multipart 是一种 &lt;code&gt;Content-Type&lt;/code&gt;，标示 HTTP 报文内容的类型，而 &lt;code&gt;chunked&lt;/code&gt; 是一种传输格式，标示报头将以何种方式进行传输。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chunked&lt;/code&gt; 传输不能事先知道传输内容的大小，只能靠最后的空 &lt;code&gt;chunked&lt;/code&gt; 块来判断结束，所以对于下载请求，是无法知道下载进度的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chunked&lt;/code&gt; 优势在于服务端可以边生成内容边发送，无需事先知道全部内容。HTTP/2 是不支持 &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; 的，因为 HTTP/2 有自己的 streaming 传输方式：&lt;code&gt;Source：MDN - Transfer-Encoding&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8-http-pipelining-http-管线化&#34;&gt;8. HTTP Pipelining (HTTP 管线化)&lt;/h3&gt;
&lt;p&gt;默认情况下，HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于： &lt;code&gt;请求1 -&amp;gt; 响应1 -&amp;gt; 请求2 -&amp;gt; 响应2 -&amp;gt; 请求3 -&amp;gt; 响应3&lt;/code&gt;。&lt;br&gt;
使用 HTTP Pipelining 是将多个 HTTP 请求打包传递的技术，在传送过程中无需等待服务端的回应，某个连接上消息的传递类似于：&lt;code&gt;请求1 -&amp;gt; 请求2 -&amp;gt; 请求3 -&amp;gt; 响应1 -&amp;gt; 响应2 -&amp;gt; 响应3&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0不支持）&lt;/li&gt;
&lt;li&gt;只有 GET 和 HEAD 请求可以实现管线化，POST 则有所限制。&lt;/li&gt;
&lt;li&gt;初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。&lt;/li&gt;
&lt;li&gt;管线化不会影响响应到来的顺序。&lt;/li&gt;
&lt;li&gt;HTTP 1.1 要求服务端实现管线化，不要求服务端也对响应进行管线化处理，只要求对管线化请求不失败即可。&lt;/li&gt;
&lt;li&gt;由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9-会话跟踪&#34;&gt;9. 会话跟踪&lt;/h3&gt;
&lt;h4 id=&#34;会话&#34;&gt;会话&lt;/h4&gt;
&lt;p&gt;客户端打开与服务端的连接发送请求到服务端响应客户端请求的全过程称之为会话。&lt;/p&gt;
&lt;h4 id=&#34;会话跟踪&#34;&gt;会话跟踪&lt;/h4&gt;
&lt;p&gt;会话跟踪是对同一个用户对服务器的连续的请求和接收响应的监视。&lt;/p&gt;
&lt;h4 id=&#34;为何需要会话跟踪&#34;&gt;为何需要会话跟踪&lt;/h4&gt;
&lt;p&gt;客户端跟服务端的通信如果是采用 HTTP 协议通信，而 HTTP 协议是无状态的，它无法保存用户的状态（信息），即一次响应后就断开了，下次请求需要重新连接，此时需要判断是否为同一个用户，所以需要会话跟踪技术实现这种需求。&lt;/p&gt;
&lt;h4 id=&#34;会话跟踪常用技术&#34;&gt;会话跟踪常用技术&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;URL 重写
&lt;ul&gt;
&lt;li&gt;URL（统一资源定位符）是Web 上特定界面的地址，URL 重写技术就是在 URL 结尾添加一个附加数据来标识该会话，把会话的 ID 通过 URL 传输给服务端，以便在服务端区分不同用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隐藏表单域
&lt;ul&gt;
&lt;li&gt;将会话 ID 添加到HTTP表单元素中提交到服务器，此表单元素客户端不可见&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cookie
&lt;ul&gt;
&lt;li&gt;Cookie 是服务端发送给客户端的一小段信息，客户端请求时可读取该信息发送到服务端，进而进行用户识别，对于客户端的每次请求，服务器会将Cookie 下发到客户端，在客户端可以进行保存以便下一次使用。&lt;/li&gt;
&lt;li&gt;Cookie 可存放在客户端内存中，称为临时Cookie，客户端关闭即清除；另外可存放在磁盘中，成为永久 Cookie。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Session
&lt;ul&gt;
&lt;li&gt;每一个用户都有一个特定的 Session，各个用户之间不可共享，是每个用户独享的，在 Session 中可以存放信息。&lt;/li&gt;
&lt;li&gt;在服务端会创建一个 Session 对象，产生一个 SessionID 来标示这个Session对象，然后将这个 SessionID 放入 Cookie 中发送给客户端，下一次访问时，SessionID 会再次发送给服务端，在服务端进行识别不同用户&lt;/li&gt;
&lt;li&gt;Session 的实现依赖于 Cookie，若 Cookie 被禁用，那么 Session 也将失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10跨站攻击&#34;&gt;10.跨站攻击&lt;/h3&gt;
&lt;h4 id=&#34;csrf-cross-site-request-forgery-伪造请求冒充用户在站内的正常操作&#34;&gt;CSRF （Cross-Site request forgery）- 伪造请求，冒充用户在站内的正常操作。&lt;/h4&gt;
&lt;p&gt;如何防止 &lt;code&gt;CSRF&lt;/code&gt; 跨站攻击：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键操作只接受 POST 请求&lt;/li&gt;
&lt;li&gt;验证码
&lt;ul&gt;
&lt;li&gt;使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检测 &lt;code&gt;Referer&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 &lt;code&gt;Referer&lt;/code&gt; 中, 通过检查 &lt;code&gt;Referer&lt;/code&gt; 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 &lt;code&gt;Referer&lt;/code&gt; 的值，所以 &lt;code&gt;Referer Check&lt;/code&gt; 一般用于监控 &lt;code&gt;CSRF&lt;/code&gt; 攻击的发生，而不用来抵御攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Token
&lt;ul&gt;
&lt;li&gt;对参数进行加密预防 &lt;code&gt;CSRF&lt;/code&gt; 攻击。&lt;/li&gt;
&lt;li&gt;添加一个新参数 Token，不知道 Token 是无法构造出合法的请求进行攻击的。&lt;/li&gt;
&lt;li&gt;Token 使用时机：
&lt;ul&gt;
&lt;li&gt;Token 要足够随机&lt;/li&gt;
&lt;li&gt;Token 是一次性的，即每次请求成功后都要更新 Token&lt;/li&gt;
&lt;li&gt;Token 要注意保密性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;xss-cross-site-scripting跨站脚本攻击-是注入攻击的一种&#34;&gt;XSS (Cross Site Scripting，跨站脚本攻击) - 是注入攻击的一种&lt;/h4&gt;
&lt;p&gt;如果防御 XSS：&lt;br&gt;
将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。&lt;/p&gt;
&lt;h2 id=&#34;part2-http-over-ssltls&#34;&gt;Part.2 - HTTP over SSL/TLS&lt;/h2&gt;
&lt;h3 id=&#34;1-https-基本过程&#34;&gt;1. HTTPS 基本过程&lt;/h3&gt;
&lt;p&gt;HTTPS 即 HTTP over SSL/TLS ，是一种在加密通道进行 HTTP 内容传输的协议。&lt;/p&gt;
&lt;h4 id=&#34;tls-基本过程&#34;&gt;TLS 基本过程：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一个 &lt;code&gt;ClientHello&lt;/code&gt; 消息到服务端，消息中包含了它的 TLS （Transport Layer Security） 的版本、可用的加密算法和压缩算法。&lt;/li&gt;
&lt;li&gt;服务端向客户端发送一个 &lt;code&gt;ServerHello&lt;/code&gt; 消息，消息中包含了服务端 TLS 的版本，服务端所选择的加密算法和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥来加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。&lt;/li&gt;
&lt;li&gt;客户端根据自己信任的 CA 列表验证服务端的证书是否可信，如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密他，这串随机数会被用于生成新的对称密钥。&lt;/li&gt;
&lt;li&gt;服务端使用自己的私钥解密上面的随机数，然后使用这串随机数生成自己的对称主密钥。&lt;/li&gt;
&lt;li&gt;客户端发送一个 &lt;code&gt;finished&lt;/code&gt; 消息给服务端，使用对称密钥加密这次通信的一个散列值。&lt;/li&gt;
&lt;li&gt;服务器生成自己的 Hash 值，然后解密客户端发来的信息，检查这两个值是否对应，如果对应就向客户端发送一个 &lt;code&gt;finished&lt;/code&gt; 消息，也使用协商好的对称密钥加密。&lt;/li&gt;
&lt;li&gt;从现在开始，接下来整个 TLS 会话都使用对称密钥加密，传输应用层（HTTP）内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TLS 的完整过程需要三个算法（协议），密钥交互算法、对称加密算法、消息认证算法&lt;/p&gt;
&lt;h3 id=&#34;2-tls-证书机制&#34;&gt;2. TLS 证书机制&lt;/h3&gt;
&lt;p&gt;HTTPS 过程中有一个很重要的步骤，就是服务器要有 CA 证书机构颁发的证书，客户端根据自己信任的 CA 列表验证服务器的身份。&lt;br&gt;
现代浏览器中，证书的验证过程依赖于证书信任链：即一个证书需要依靠上一个证书来证明自己的可信的，最顶层的证书是根证书，拥有根证书的机构被称为 根 CA（一般操作系统自带）。&lt;/p&gt;
&lt;h3 id=&#34;3-中间人攻击&#34;&gt;3. 中间人攻击&lt;/h3&gt;
&lt;p&gt;所谓中间人攻击，指攻击者与通信的两端都建立独立的联系，并交换其所接受到的数据，使通信的双方都认为他们正在通过私密的连接直接与对方进行通话，事实上整个会话都会被攻击者完全控制。在中间人攻击中，攻击者可以拦截双方的通信并插入新的内容。&lt;/p&gt;
&lt;h4 id=&#34;ssl-剥离-问题&#34;&gt;SSL 剥离 问题&lt;/h4&gt;
&lt;p&gt;SSL 剥离即阻止用户使用 HTTPS 访问网站。由于并不是所有网站都只支持 HTTPS，大部分网站会同时支持 HTTP 和 HTTPS 两种协议。用户在访问网站时，也可能会在地址栏中输入 &lt;code&gt;http://&lt;/code&gt; 的地址，第一次的访问完全是明文的，这就给了攻击者可乘之机。通过攻击 DNS 响应，攻击者可以将自己变成中间人。&lt;/p&gt;
&lt;h4 id=&#34;hsts&#34;&gt;HSTS&lt;/h4&gt;
&lt;p&gt;用于强制浏览器使用 HTTPS 访问网站的一种机制。它的基本机制是在服务器返回的响应中，加上一个特殊的头部，指示浏览器对于此网站，强制使用 HTTPS 进行访问。&lt;br&gt;
HSTS 有一个很明显的缺点，是需要等待第一个服务器的影响中的头部才能生效，但如果第一次访问该网站就被攻击呢？为了解决这个问题，浏览器中会带上一些网站的域名，被称为 HSTS preload list。对于在这个 list 的网站来说，直接强制使用 HTTPS。&lt;/p&gt;
&lt;h4 id=&#34;伪造证书攻击&#34;&gt;伪造证书攻击&lt;/h4&gt;
&lt;p&gt;HSTS 只解决了 SSL 剥离的问题，然而即使在全程使用 HTTPS 的情况下，我们仍然有可能被监听。&lt;br&gt;
第一步是需要攻击 DNS 服务器。第二步是攻击者自己的证书需要被用户信任，这一步对于用户来说是很难控制的，需要证书颁发机构能够控制自己不滥发证书。&lt;/p&gt;
&lt;h4 id=&#34;hpkp&#34;&gt;HPKP&lt;/h4&gt;
&lt;p&gt;HPKP 技术是为了解决伪造证书攻击而诞生的。&lt;br&gt;
HPKP（Public Key Pinning Extension for HTTP）在 HSTS 上更进一步，HPKP 直接在返回头中存储服务器的公钥指纹信息，一旦发现指纹和实际接受到的公钥有差异，浏览器就可以认为正在被攻击。&lt;br&gt;
和 HSTS 类似，HPKP 也依赖于服务器的头部返回，不能解决第一次访问的问题，浏览器本身也会内置一些 HPKP 列表。&lt;/p&gt;
&lt;h2 id=&#34;part3-tcp-协议&#34;&gt;Part.3 - TCP 协议&lt;/h2&gt;
&lt;h3 id=&#34;1-tcp-的特征&#34;&gt;1. TCP 的特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TCP 提供一种面向连接的、可靠的字节流服务。&lt;/li&gt;
&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信，广播和多播不能用于 TCP。&lt;/li&gt;
&lt;li&gt;TCP 使用校验、确认和重传机制来保证可靠传输。&lt;/li&gt;
&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认和保证数据的顺序不变和非重复。&lt;/li&gt;
&lt;li&gt;TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能做到的是：如果有可能就把数据递送给对方，否则就通知用户（使用放弃重传并中断连接这一方式实现）。因此准确说 TCP 也不是 100% 可靠的协议，他所能提供的是数据的可靠递送或故障的可靠通知。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-三次握手与四次挥手&#34;&gt;2. 三次握手与四次挥手&lt;/h3&gt;
&lt;h4 id=&#34;三次握手&#34;&gt;三次握手&lt;/h4&gt;
&lt;p&gt;所谓三次握手，是指建立一个 &lt;code&gt;TCP&lt;/code&gt; 连接，客户端和服务端需要传送三个包。&lt;br&gt;
三次握手的目的是连接服务器指定端口，建立 &lt;code&gt;TCP&lt;/code&gt; 连接，并同步连接双方的序列号和确认号，交换 &lt;code&gt;TCP&lt;/code&gt; 窗口大小信息，在 &lt;code&gt;socket&lt;/code&gt; 编程中，客户端执行 &lt;code&gt;connect()&lt;/code&gt; 触发三次握手。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次握手：（SYN = 1，seq = x）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一个 &lt;code&gt;TCP&lt;/code&gt; 的 &lt;code&gt;SYN&lt;/code&gt; 标志位置 1 的包，指明客户端需要连接的端口和初始序号 X, 保存在包头的序列号(Sequence Number)字段里。&lt;/li&gt;
&lt;li&gt;发送完毕后，客户端进入 &lt;code&gt;SYN_SEND&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次握手：（SYN = 1，ACK = 1，seq = y，ACKnum = x + 1）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端发回确认包（ACK）应答，即 &lt;code&gt;SYN&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 均为 1，服务端选择自己的 &lt;code&gt;ISN&lt;/code&gt; 序号，放到 &lt;code&gt;seq&lt;/code&gt; 域里，同时将确认序号(Acknowledgement Number)设置为客户的 &lt;code&gt;ISN&lt;/code&gt; 加1，即 &lt;code&gt;X+1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;发送完毕后，服务端进入 &lt;code&gt;SYN_RCVD&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次握手：（ACK = 1，ACKnum = y + 1）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端再次发送确认包（ACK），&lt;code&gt;SYN&lt;/code&gt; 标志位为 0，&lt;code&gt;ACK&lt;/code&gt; 标志位为 1，并且把服务端发送的 &lt;code&gt;ACK&lt;/code&gt; 的序号字段 + 1。&lt;/li&gt;
&lt;li&gt;发送完毕后，客户端进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，当服务器端接收到这个包时，也进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，&lt;code&gt;TCP&lt;/code&gt; 握手结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三次握手示意图：&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2019.12.24.15771959898620.15771898418684.jpg&#34; alt=&#34;-w810&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt; 的拆除需要发送四个包，因此称为四次挥手，也叫改进的三次握手。客户端和服务端均可主动发起挥手动作，在 &lt;code&gt;socket&lt;/code&gt; 编程中，任意一端执行 &lt;code&gt;close()&lt;/code&gt; 即可产生挥手操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次挥手：（FIN = 1，seq = x）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设客户端想要关闭连接，客户端发送一个 &lt;code&gt;FIN&lt;/code&gt; 标志位为 1 的包，表示自己没有数据可发送了，但仍可以接收数据。&lt;/li&gt;
&lt;li&gt;发送完毕后，客户端进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次挥手：（ACK = 1，ACKnum = x + 1）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端确认客户端的 &lt;code&gt;FIN&lt;/code&gt; 包，并发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。&lt;/li&gt;
&lt;li&gt;发送完毕后，服务端进入 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; 状态，客户端接收到这个确认包后，进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 状态，等待服务端关闭连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次挥手：（FIN = 1，seq = y）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端准备好关闭连接时，向客户端发送结束连接请求，&lt;code&gt;FIN&lt;/code&gt; 置为 1。&lt;/li&gt;
&lt;li&gt;发送完毕后，服务端进入 &lt;code&gt;LAST_ACK&lt;/code&gt; 状态，等待来自客户端的最后一个 &lt;code&gt;ACK&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四次挥手：（ACK = 1，ACKnum = y + 1）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端接收到来自服务端的关闭请求，发送一个确认包，并进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态。等待可能出现的要求重传的 &lt;code&gt;ACK&lt;/code&gt; 包.&lt;/li&gt;
&lt;li&gt;服务端接收到这个确认包之后，关闭连接，进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;客户端等待了某个固定时间（两个最大段声明周期）之后，没有收到服务器端的 &lt;code&gt;ACK&lt;/code&gt;，以为服务端已经正常关闭连接，于是自己也关闭连接，进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四次挥手示意图：&lt;br&gt;
&lt;img src=&#34;http://blog.image.jkxuewei.com/mweb/2019.12.24.15771959898660.15771930493721.jpg&#34; alt=&#34;-w705&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-syn-攻击&#34;&gt;3. SYN 攻击&lt;/h3&gt;
&lt;h4 id=&#34;什么是-syn-攻击&#34;&gt;什么是 &lt;code&gt;SYN&lt;/code&gt; 攻击？&lt;/h4&gt;
&lt;p&gt;在三次握手过程中的第二次握手时，服务器发送 &lt;code&gt;SYN_ACK&lt;/code&gt; 之后，收到客户端的 &lt;code&gt;ACK&lt;/code&gt; 之前的 &lt;code&gt;TCP&lt;/code&gt; 连接称为半连接。此时服务器处于 &lt;code&gt;SYN_RCVD&lt;/code&gt; 状态，当收到 &lt;code&gt;ACK&lt;/code&gt; 后，服务器才能转入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;br&gt;
&lt;code&gt;SYN&lt;/code&gt; 攻击指的是，&amp;quot;攻击客户端&amp;quot; 在短时间内伪造大量不存在的 IP 地址，向服务端不断地发送 &lt;code&gt;SYN&lt;/code&gt; 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 &lt;code&gt;SYN&lt;/code&gt; 包将长时间占用未连接队列，正常的 &lt;code&gt;SYN&lt;/code&gt; 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。&lt;br&gt;
&lt;strong&gt;&lt;code&gt;SYN&lt;/code&gt; 攻击是一种典型的 &lt;code&gt;Dos/DDos&lt;/code&gt; 攻击&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;如何检测-syn-攻击&#34;&gt;如何检测 &lt;code&gt;SYN&lt;/code&gt; 攻击？&lt;/h4&gt;
&lt;p&gt;当服务器出现大量的半连接状态时，特别是源 IP 地址是随机的，基本可以断定这是一次 &lt;code&gt;SYN&lt;/code&gt; 攻击。在 &lt;code&gt;Linux/Unix&lt;/code&gt; 上可以使用系统自带的 &lt;code&gt;netstats&lt;/code&gt; 命令来检测 &lt;code&gt;SYN&lt;/code&gt; 攻击。&lt;/p&gt;
&lt;h4 id=&#34;如何防御-syn-攻击&#34;&gt;如何防御 &lt;code&gt;SYN&lt;/code&gt; 攻击?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SYN&lt;/code&gt; 攻击不能完全被阻止，除非将 &lt;code&gt;TCP&lt;/code&gt; 协议重新设计。可以尽可能减轻 &lt;code&gt;SYN&lt;/code&gt; 攻击的危害：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缩短超时（SYN Timeout）时间&lt;/li&gt;
&lt;li&gt;增加最大半连接数&lt;/li&gt;
&lt;li&gt;过滤网关防护&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYN cookie&lt;/code&gt; 技术&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-tcp-keepalive&#34;&gt;4. TCP KeepAlive&lt;/h3&gt;
&lt;p&gt;TCP 的连接，实际上是一种纯软件层面的概念，在物理层并没有“连接”这种概念。如果出现一些意外导致某端出现异常而另一端无法感知，一直维护着这个连接，长时间会导致非常多的半连接状态的 TCP 连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制来避免。&lt;/p&gt;
&lt;p&gt;TCP KeepAlive 的基本原理：隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。&lt;/p&gt;
&lt;p&gt;TCP KeepAlive 的局限：首先 TCP KeepAlive 检测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能再内核层级检测连接的存活与否，而连接的存活不一定代表服务可用，例如当一个服务器 CPU 占用 100% 已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。&lt;/p&gt;
&lt;h2 id=&#34;part4-udp-协议&#34;&gt;Part.4 - UDP 协议&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt; 是一个简单的传输层协议，和 &lt;code&gt;TCP&lt;/code&gt; 相比，&lt;code&gt;UDP&lt;/code&gt; 有如下几个显著的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 缺乏可靠性。&lt;code&gt;UDP&lt;/code&gt; 本身不提供确认序列号、超时重传等机制。&lt;code&gt;UDP&lt;/code&gt; 数据报可能在网络中被复制，被重新排序。即 &lt;code&gt;UDP&lt;/code&gt; 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 数据报是有长度的。每个 &lt;code&gt;UDP&lt;/code&gt; 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 &lt;code&gt;TCP&lt;/code&gt; 是一个字节流协议，没有任何协议上的记录边界。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 是无连接的。&lt;code&gt;UDP&lt;/code&gt; 客户端和服务器之间不存在长期的关系，&lt;code&gt;UDP&lt;/code&gt; 发送数据报之前也不需要经过握手创建连接的过程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 支持多播和广播。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part5-ip-协议&#34;&gt;Part.5 - IP 协议&lt;/h2&gt;
&lt;p&gt;IP 协议位于 TCP/IP 协议的第三层 - 网络层。与传输层协议相比，网络层的责任是提供点到点的服务，而传输层（TCP/UDP）则提供端到端的服务。&lt;/p&gt;
&lt;h3 id=&#34;1-网络-osi-的七层协议&#34;&gt;1. 网络 OSI 的七层协议&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;-&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;-&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会话层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据链路层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;物理层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-ip-地址的分类&#34;&gt;2. IP 地址的分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A 类地址&lt;/li&gt;
&lt;li&gt;B 类地址&lt;/li&gt;
&lt;li&gt;C 类地址&lt;/li&gt;
&lt;li&gt;D 类地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-广播与多播&#34;&gt;3. 广播与多播&lt;/h3&gt;
&lt;p&gt;广播与多播仅用于 UDP（TCP 是面向连接的）&lt;/p&gt;
&lt;h4 id=&#34;广播&#34;&gt;广播&lt;/h4&gt;
&lt;p&gt;一共有四种广播地址：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;受限的广播：受限的广播地址为 &lt;code&gt;255.255.255.255&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;指向网络的广播：主机号为全 1 的地址&lt;/li&gt;
&lt;li&gt;指向子网的广播&lt;/li&gt;
&lt;li&gt;指向所有子网的广播&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;多播&#34;&gt;多播&lt;/h4&gt;
&lt;p&gt;又称组播，使用 D 类地址，D类地址分配的 28bit 均用作多播组号而不再表示其他&lt;/p&gt;
&lt;h4 id=&#34;bgp&#34;&gt;BGP&lt;/h4&gt;
&lt;p&gt;边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议&lt;/p&gt;
&lt;h2 id=&#34;part6-socket-编程&#34;&gt;Part.6 - Socket 编程&lt;/h2&gt;
&lt;h3 id=&#34;1-socket-基本概念&#34;&gt;1. Socket 基本概念&lt;/h3&gt;
&lt;p&gt;Socket 是对 TCP/IP 协议族的一种封装，是应用层与 TCP/IP 协议族通信的中间软件抽象层。从设计模式的角度看，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。&lt;br&gt;
Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（IP 地址、协议、端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其他进程进行交互。&lt;br&gt;
Socket 起源于 Unix，Unix/Linux 基本哲学之一就是：一切皆文件，都可以用“打开（open）-&amp;gt; 读写（write/read）-&amp;gt; 关闭（close）”模式来进行操作，因此 Socket 也被处理为一种特殊的文件。&lt;/p&gt;
&lt;h3 id=&#34;2-写一个简单的-webserver&#34;&gt;2. 写一个简单的 WebServer&lt;/h3&gt;
&lt;p&gt;一个简单的 Server 的流程包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立连接，接受一个客户端连接。&lt;/li&gt;
&lt;li&gt;接受请求，从网络中读取一条 HTTP 请求报文。&lt;/li&gt;
&lt;li&gt;处理请求，访问资源。&lt;/li&gt;
&lt;li&gt;构建响应，创建带有 header 的 HTTP 响应报文。&lt;/li&gt;
&lt;li&gt;发送响应，传给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大体的程序与调用的函数逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;socket()&lt;/code&gt; 创建套接字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind()&lt;/code&gt; 分配套接字地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen()&lt;/code&gt; 等待连接请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accept()&lt;/code&gt; 允许连接请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read()/write()&lt;/code&gt; 数据交换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close()&lt;/code&gt; 关闭连接&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;更多干货文章&#34;&gt;更多干货文章&lt;/h3&gt;
&lt;h5 id=&#34;博客wwwqiuxueweicom&#34;&gt;博客：&lt;a href=&#34;http://www.qiuxuewei.com&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;微信公众号开发者成长之路&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&#34;&#34;&gt;&lt;img src=&#34;http://blog.image.jkxuewei.com/sou_wechat.png&#34; alt=&#34;公众号二维码&#34; loading=&#34;lazy&#34;&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
">网络拾遗</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://qxuewei.github.io/post/about/"" data-c="
          &lt;h2 id=&#34;关于我&#34;&gt;关于我 👇🏻&lt;/h2&gt;
&lt;p&gt;👨🏻‍💻全职独立开发者👨🏻‍💻&lt;br&gt;
作品：学伟扫描、加一&lt;br&gt;
前BAT高级iOS研发工程师~&lt;br&gt;
旅行、篮球、阅读、电影、摄影爱好者~&lt;br&gt;
在公众号「极客学伟」记录创业日常~&lt;/p&gt;
&lt;h5 id=&#34;微信公众号极客学伟&#34;&gt;🤗 微信公众号：极客学伟&lt;/h5&gt;
&lt;h5 id=&#34;️-e-mail-jkxueweigmailcom-换成&#34;&gt;✉️ E-mail： &amp;lt;jkxuewei#gmail.com&amp;gt; (&#39;#&#39;换成&#39;@&#39;)&lt;/h5&gt;
&lt;h5 id=&#34;微博极客学伟&#34;&gt;📜 微博：&lt;a href=&#34;https://weibo.com/qxuewei&#34;&gt;@极客学伟&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;githubgithub主页&#34;&gt;🤖 GitHub：&lt;a href=&#34;https://github.com/qxuewei&#34;&gt;GitHub主页&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;csdn-极客学伟的技术分享社区&#34;&gt;👨🏻‍🏫 CSDN: &lt;a href=&#34;https://xuewei.blog.csdn.net/&#34;&gt;极客学伟的技术分享社区&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&#34;独立开发作品学伟扫描&#34;&gt;🌽 独立开发作品：学伟扫描...&lt;/h5&gt;
">关于</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记36gap-year\&#34;&gt;程序员自由创业周记#36：Gap Year&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/307008/pexels-photo-307008.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;一整年\&#34;&gt;一整年&lt;/h3&gt;\n&lt;p&gt;刚过去的一周，度过了我31周岁的生日，距离结束上一份工作，刚好一年。一年过得好快，犹记得刚失业那会的迷茫，第一个月的纠结，是继续打工还是自己当“老板”。好在只纠结了一个月，就坚定的开始创业了，如果再既想又想，可能什么都做不好。起初就是把这次旅程当做Gap Year 看待的，西方的Gap Year是毕业后上班之前休整一年，用这一年去做自己喜欢的事，明确自己的人生方向。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;国内盛行的卷文化很少遇到Gap的，大多数是从没毕业就开始工作，一直到退休，也正如30岁之前的我。但我知道那不是我想要的生活。在之前工作的时候，架构师非常敬业，经常是组里走得最晚的那一个，遇到问题也是优先解决，极其敬业，有时凌晨也会在工作群里发消息，似乎把自己全部贡献了给了工作。后来我想，按照职场的晋升之路，若干年以后我也可能会走到那一步，但那肯定不是我想要的。就那么一瞬间，我发现职场不适合我。&lt;/p&gt;\n&lt;p&gt;后来有机会体验一次Gap Year，去做我真正喜欢，想做的事。&lt;/p&gt;\n&lt;h3 id=\&#34;有意思的一年\&#34;&gt;有意思的一年&lt;/h3&gt;\n&lt;p&gt;起初的焦虑几乎每天都萦绕在我周边，没收入那段时间，去篮球场打球都提不起兴致。偶尔会看着天空发呆，好在执行力比较强，一直在工作，为自己的产品工作。&lt;/p&gt;\n&lt;p&gt;有时在公园工作，有时在图书馆，有时在咖啡馆，有时在小孩补习课的家长休息区，有时在游乐场边上，在老家，在亲戚家，最多的是在我租住的那个客厅窗户没有阳光还要每个月交4500的出租房里工作。因为在家，我可以用三台显示器。也不需要通勤的哪怕5分钟的时间。&lt;/p&gt;\n&lt;p&gt;后来，去年底的时候楼下开始装修，每天工作的时候耳边萦绕着各种电钻的声音，持续了两个多月，终于声音没那么刺耳后年初又迎来了隔壁邻居的装修，又是熟悉的电钻声，因为是隔壁，还经常听到工友们谈天说地的声音，我戴着耳机对此不以为意，不会动摇我做软件的决心。直到最近几天，我听到了楼上拆墙的声音...&lt;/p&gt;\n&lt;p&gt;这三家肯定不是约好的，他们肯定不知道他们有一位邻居在他们装修的时候一直在家只工作，不上班。&lt;/p&gt;\n&lt;h3 id=\&#34;本周工作\&#34;&gt;本周工作&lt;/h3&gt;\n&lt;p&gt;继续做AI画图的软件，完善灵动岛小组件 &lt;a href=\&#34;https://apps.apple.com/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt;。&lt;/p&gt;\n&lt;p&gt;我美丽的媳妇给我设计了特别棒的Logo。&lt;/p&gt;\n&lt;p&gt;也在小红书请了独立设计师按照我的原型设计了UI，还可以。用AI辅助作图，很多有意思的功能可以做，文字生成图片、AI头像、老照片修复...&lt;/p&gt;\n&lt;p&gt;值得一提的是我的第一个独立软件“&lt;a href=\&#34;https://apps.apple.com/app/id1468603429\&#34;&gt;学伟扫描 - OCR&amp;amp;PDF扫描打印&lt;/a&gt;”是图片转文字。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.06.14.17183266424370.17183258615765.jpg\&#34; alt=\&#34;AI画图王\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;5月收支\&#34;&gt;5月收支&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;支出：14464.96&lt;/li&gt;\n&lt;li&gt;收入：$789.98&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;已经达到一年以前为自己设定的目标，会坚定的一直走下去，不动摇。我也会持续告诉跟我一样的程序员，除了上班，还有其他的路可以走，不用非得是送外卖和跑滴滴。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-36gap-year&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记36gap-year\&#34;&gt;程序员自由创业周记#36：Gap Year&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/307008/pexels-photo-307008.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;一整年\&#34;&gt;一整年&lt;/h3&gt;\n&lt;p&gt;刚过去的一周，度过了我31周岁的生日，距离结束上一份工作，刚好一年。一年过得好快，犹记得刚失业那会的迷茫，第一个月的纠结，是继续打工还是自己当“老板”。好在只纠结了一个月，就坚定的开始创业了，如果再既想又想，可能什么都做不好。起初就是把这次旅程当做Gap Year 看待的，西方的Gap Year是毕业后上班之前休整一年，用这一年去做自己喜欢的事，明确自己的人生方向。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#36：Gap Year&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:58:57&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-36gap-year/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:194000,&#34;words&#34;:945,&#34;minutes&#34;:4},&#34;description&#34;:&#34;程序员自由创业周记#36：Gap Year\n\n一整年\n刚过去的一周，度过了我31周岁的生日，距离结束上一份工作，刚好一年。一年过得好快，犹记得刚失业那会的迷茫，第一个月的纠结，是继续打工还是自己当“老板”。好在只纠结了一个月，就坚定的开始创...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B036gap-year\&#34;&gt;程序员自由创业周记#36：Gap Year&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E6%95%B4%E5%B9%B4\&#34;&gt;一整年&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E5%B9%B4\&#34;&gt;有意思的一年&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E5%B7%A5%E4%BD%9C\&#34;&gt;本周工作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;5月收支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记35外包-技术选型和卖房\&#34;&gt;程序员自由创业周记#35：外包、技术选型和卖房&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8430048/pexels-photo-8430048.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;对待外包的态度\&#34;&gt;对待外包的态度&lt;/h3&gt;\n&lt;p&gt;外包是来钱最快的方式，通过出售自己的时间和技能换取报酬，一定程度上与上班类似。创业后一直在做自己的产品，从习惯打卡软件：&lt;a href=\&#34;https://apps.apple.com/app/id1477743089\&#34;&gt;加一&lt;/a&gt;，到灵动岛软件：&lt;a href=\&#34;https://apps.apple.com/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt;，然后Mac休息提醒软件：&lt;a href=\&#34;https://apps.apple.com/app/id6471501135\&#34;&gt;Nap&lt;/a&gt;，到现在正在开发AI作图软件：AI画图王。做自己的产品最开心的就是自由，设计、交互、功能都是自己定，不需要看任何人的脸色，没有deadline。如果有外包的机会来到面前，该怎么对待呢，说下我的态度。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;上周好朋友有一个不错的iOS私活，横跨半个北京，见了对方的老板，互相了解了下对方，相谈甚欢。后来与对方技术经理聊了下需求细节，最后我给了报价后就一直没下文了。我猜是双方的需求并没有匹配上。作为外包公司，希望能用就行，没有UI按照原型图开发一个App自然预算不会太高。而我写代码又不会将就，即便是外包代码也要写得漂亮，按照上班时期的日薪报的价显然不会让人满意。通过这个小插曲，也坚定了自己不合适做外包，可能以后也不会有类似的机会，即便有，也不准备再为此投入时间。&lt;/p&gt;\n&lt;h3 id=\&#34;技术选型\&#34;&gt;技术选型&lt;/h3&gt;\n&lt;p&gt;准备给AI画图王写代码的时候采用什么语言和使用什么框架费了一点功夫，目前会的技术栈有老古董Objective-C，Swift，Flutter和SwiftUI。OC这门上个世纪的语言是第一需要排除的，在Flutter和SwiftUI之间犹豫了一番，Flutter看起来是最适合的，跨平台，性能也不错。但是，我不擅长，而且性能和开发速度也不如原生，最后选择了继续深耕在Apple原生平台，不同的是这次用的SwiftUI这个Apple近年来强推的新框架。计划下个月上架iOS版本，下下个月上架Mac版本。&lt;/p&gt;\n&lt;h3 id=\&#34;卖房\&#34;&gt;卖房&lt;/h3&gt;\n&lt;p&gt;为了降低每月开销，第一步去掉房贷，而且烟台基本也不会回去了，17年中烟台买的那个距离海边2km的房子没有必要再留了，挂的价格是那个小区三居室单价最便宜的（69W 单价5800），值得一提的是，假如卖出去还完贷款，就没剩了。首付蒸发了，过去有几年的努力付之一炬。有时候，选择比努力更重要。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.31.17171208727546.IMG_0374.PNG\&#34; alt=\&#34;IMG_0374\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;p&gt;摸鱼的一周，学习新技术，开发新产品，打球，看比赛...&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-35wai-bao-ji-zhu-xuan-xing-he-mai-fang&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记35外包-技术选型和卖房\&#34;&gt;程序员自由创业周记#35：外包、技术选型和卖房&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8430048/pexels-photo-8430048.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;对待外包的态度\&#34;&gt;对待外包的态度&lt;/h3&gt;\n&lt;p&gt;外包是来钱最快的方式，通过出售自己的时间和技能换取报酬，一定程度上与上班类似。创业后一直在做自己的产品，从习惯打卡软件：&lt;a href=\&#34;https://apps.apple.com/app/id1477743089\&#34;&gt;加一&lt;/a&gt;，到灵动岛软件：&lt;a href=\&#34;https://apps.apple.com/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt;，然后Mac休息提醒软件：&lt;a href=\&#34;https://apps.apple.com/app/id6471501135\&#34;&gt;Nap&lt;/a&gt;，到现在正在开发AI作图软件：AI画图王。做自己的产品最开心的就是自由，设计、交互、功能都是自己定，不需要看任何人的脸色，没有deadline。如果有外包的机会来到面前，该怎么对待呢，说下我的态度。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#35：外包、技术选型和卖房&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:58:26&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-35wai-bao-ji-zhu-xuan-xing-he-mai-fang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:146000,&#34;words&#34;:710,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#35：外包、技术选型和卖房\n\n对待外包的态度\n外包是来钱最快的方式，通过出售自己的时间和技能换取报酬，一定程度上与上班类似。创业后一直在做自己的产品，从习惯打卡软件：加一，到灵动岛软件：Island Widgets，然后...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B035%E5%A4%96%E5%8C%85-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E5%92%8C%E5%8D%96%E6%88%BF\&#34;&gt;程序员自由创业周记#35：外包、技术选型和卖房&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E5%BE%85%E5%A4%96%E5%8C%85%E7%9A%84%E6%80%81%E5%BA%A6\&#34;&gt;对待外包的态度&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B\&#34;&gt;技术选型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%96%E6%88%BF\&#34;&gt;卖房&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记34直播敲代码\&#34;&gt;程序员自由创业周记#34：直播敲代码&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1181675/pexels-photo-1181675.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;勇于尝试\&#34;&gt;勇于尝试&lt;/h3&gt;\n&lt;p&gt;过去一段时候经常很在意其他人的眼光，会提醒自己要做那个让所有人都满意的好人，随着时间的推移，想法渐渐有所转变，让所有人都满意是不可能的，即便优秀如孔子，也有很多人觉得他不好，被封建统治阶级利用。何况平凡如我这种资质平平的凡人，后来就不再那么在意别人的眼光。&lt;/p&gt;\n&lt;p&gt;“别人怎么看我，关我什么事” - 佚名。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;写创业周记是尝试的一部分，你创业这些破事谁爱看啊，你一个月赔4块钱也有必要写篇周记(#6：劝退)记录一下，“这不是活该吗”，“老老实实找个班上不好吗”... 很多人投来鄙夷的眼光。&lt;/p&gt;\n&lt;p&gt;后来，我又继续写了29篇，包括这篇。&lt;/p&gt;\n&lt;p&gt;除了周记，我甚至开启了直播敲代码，直播画面就是我在家的工位，敲代码、画原型、学新技术、甚至读蹩脚的英语...&lt;/p&gt;\n&lt;p&gt;把 Build In Public 维度又增加了一分。想看一看楼主背影的读者可以移步抖音搜索【极客学伟】这个用户。&lt;/p&gt;\n&lt;h3 id=\&#34;拥抱aigc\&#34;&gt;拥抱AIGC&lt;/h3&gt;\n&lt;p&gt;新产品原本计划做一款个人OKR目标管理的软件，后来因为美丽的媳妇让我给她用AI做一张图的时候，发现没有特别好用的手机App产品，有些网页产品生成的效果也不那么尽如人意。灵机一动，要不要做一款AI软件，AI作图。去年AI火爆，各种ChatGPT套壳软件如雨后春笋般涌现，当时我没有加入，一是觉得有灵动岛这个我更想做的产品，另外就是竞争太过激烈。&lt;/p&gt;\n&lt;p&gt;近期简单调研发现，AI生成图片的软件还没那么多，竞争相对小一点。如果做一款Apple全平台的原生文生图软件，降低人使用AI的门槛...&lt;/p&gt;\n&lt;p&gt;说干就干。&lt;/p&gt;\n&lt;p&gt;AI画图王原型图应运而生。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.17.17159119900769.17159108384181.jpg\&#34; alt=\&#34;AI画图王原型\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;aiphoto\&#34;&gt;AIPhoto&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.17.17159119900795.17159114803318.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;创建代码仓库发现这个名字已经存在了三年，回想起来是当初流行老照片修复的时候也打算做一款同类型的软件，后来因为上班忙和自己懒最终搁浅了。进一步联想，被我搁浅的项目还有好多，有些代码都写了很多了。比如17年抖音刚火的时候打算做一款文字生成抖音视频的软件，那种只播放文字的抖音视频，后来选择做了OCR。然后就是Mac端的截图软件，代码也已经写了好多。基本流程已经跑通，目前依然没有上线。&lt;/p&gt;\n&lt;p&gt;然后就是平时记录的一堆产品想法。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.17.17159119900808.17159116554299.jpg\&#34; alt=\&#34;项目灵感\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这么看我自己写软件创业并不是心血来潮，是很久很久就在心里埋下的种子。&lt;/p&gt;\n&lt;p&gt;只是现在发了个芽。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-34zhi-bo-qiao-dai-ma&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记34直播敲代码\&#34;&gt;程序员自由创业周记#34：直播敲代码&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1181675/pexels-photo-1181675.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;勇于尝试\&#34;&gt;勇于尝试&lt;/h3&gt;\n&lt;p&gt;过去一段时候经常很在意其他人的眼光，会提醒自己要做那个让所有人都满意的好人，随着时间的推移，想法渐渐有所转变，让所有人都满意是不可能的，即便优秀如孔子，也有很多人觉得他不好，被封建统治阶级利用。何况平凡如我这种资质平平的凡人，后来就不再那么在意别人的眼光。&lt;/p&gt;\n&lt;p&gt;“别人怎么看我，关我什么事” - 佚名。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#34：直播敲代码&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:58:04&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-34zhi-bo-qiao-dai-ma/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:159000,&#34;words&#34;:776,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#34：直播敲代码\n\n勇于尝试\n过去一段时候经常很在意其他人的眼光，会提醒自己要做那个让所有人都满意的好人，随着时间的推移，想法渐渐有所转变，让所有人都满意是不可能的，即便优秀如孔子，也有很多人觉得他不好，被封建统治阶级利...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B034%E7%9B%B4%E6%92%AD%E6%95%B2%E4%BB%A3%E7%A0%81\&#34;&gt;程序员自由创业周记#34：直播敲代码&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8B%87%E4%BA%8E%E5%B0%9D%E8%AF%95\&#34;&gt;勇于尝试&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8B%A5%E6%8A%B1aigc\&#34;&gt;拥抱AIGC&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#aiphoto\&#34;&gt;AIPhoto&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记33创业者的一天\&#34;&gt;程序员自由创业周记#33：创业者的一天&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1226398/pexels-photo-1226398.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;一天的安排\&#34;&gt;一天的安排&lt;/h3&gt;\n&lt;p&gt;只工作不上班的日子是非常考验一个人自律能力的，如果顶不住各种诱惑，一天的时间转瞬即逝。尤其对我这种兴趣极其广泛的人。如果不自律，上午一场NBA比赛就过去了；如果不自律，下午一场球就过去了；如果不自律，晚上一场电影又过去了。尤其手机上又有抖音、虎扑、B站这种时间黑洞类型的App，不自律，一天静悄悄的就过去了。&lt;/p&gt;\n&lt;p&gt;怎么才能让自己战胜惰性，即便没人监督也能保持效率呢，我给自己的一些技巧就是：计划、番茄钟；&lt;/p&gt;\n&lt;p&gt;比如我一天的安排：&lt;/p&gt;\n&lt;h4 id=\&#34;在改进之前\&#34;&gt;在改进之前：&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026221.17153061347575.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这其中有几个问题就是，学完英语让自己进入工作状态后时间太晚，另外下午3点开始做饭又结束太早，晚上8点以后的工作时间很难得到保证。每天大概只有5小时真实工作时间，大概8个40分钟番茄钟，而这显然是不够的。&lt;/p&gt;\n&lt;h4 id=\&#34;后来进行了改进\&#34;&gt;后来进行了改进&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026234.17153060115394.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;把英语学习时间提前到起床后，并且在早上做好一天的饭，一般炒两个菜。送完孩子之后就可以进入工作状态，一直到下午接孩子中间不吃饭，即便同样晚上的工作时间不能保证，也能有大概8小时专注时间。对于敲代码来说，持续的心流状态很难得，中间需要尽量少被打断。&lt;/p&gt;\n&lt;p&gt;这是理想的状态，实践下来之后发现，我并没那么自律😄&lt;/p&gt;\n&lt;p&gt;不过好在5点起床的习惯基本已经养成了。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;p&gt;本周 &lt;a href=\&#34;https://apps.apple.com/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 上线了台湾省用户许愿的灵动秒针功能，给他上线了这个功能，在灵动岛显示秒数。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026240.17153075006160.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h5 id=\&#34;效果\&#34;&gt;效果&lt;/h5&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026245.65DF21A6-AEBB-4C18-B5FB-9C7D6033E31B_1_105_c.jpeg\&#34; alt=\&#34;65DF21A6-AEBB-4C18-B5FB-9C7D6033E31B_1_105_c\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;4月收支\&#34;&gt;4月收支&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;支出：24509.56&lt;/li&gt;\n&lt;li&gt;收入：$584.15&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026250.62281632-7D75-468A-B834-D5395A0E1F16_4_5005_c.jpeg\&#34; alt=\&#34;62281632-7D75-468A-B834-D5395A0E1F16_4_5005_c\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;如果不是连续摔坏两部手机，数码的支出原本不该有这么多。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-33chuang-ye-zhe-de-yi-tian&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记33创业者的一天\&#34;&gt;程序员自由创业周记#33：创业者的一天&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1226398/pexels-photo-1226398.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;一天的安排\&#34;&gt;一天的安排&lt;/h3&gt;\n&lt;p&gt;只工作不上班的日子是非常考验一个人自律能力的，如果顶不住各种诱惑，一天的时间转瞬即逝。尤其对我这种兴趣极其广泛的人。如果不自律，上午一场NBA比赛就过去了；如果不自律，下午一场球就过去了；如果不自律，晚上一场电影又过去了。尤其手机上又有抖音、虎扑、B站这种时间黑洞类型的App，不自律，一天静悄悄的就过去了。&lt;/p&gt;\n&lt;p&gt;怎么才能让自己战胜惰性，即便没人监督也能保持效率呢，我给自己的一些技巧就是：计划、番茄钟；&lt;/p&gt;\n&lt;p&gt;比如我一天的安排：&lt;/p&gt;\n&lt;h4 id=\&#34;在改进之前\&#34;&gt;在改进之前：&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026221.17153061347575.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这其中有几个问题就是，学完英语让自己进入工作状态后时间太晚，另外下午3点开始做饭又结束太早，晚上8点以后的工作时间很难得到保证。每天大概只有5小时真实工作时间，大概8个40分钟番茄钟，而这显然是不够的。&lt;/p&gt;\n&lt;h4 id=\&#34;后来进行了改进\&#34;&gt;后来进行了改进&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.05.10.17153090026234.17153060115394.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;把英语学习时间提前到起床后，并且在早上做好一天的饭，一般炒两个菜。送完孩子之后就可以进入工作状态，一直到下午接孩子中间不吃饭，即便同样晚上的工作时间不能保证，也能有大概8小时专注时间。对于敲代码来说，持续的心流状态很难得，中间需要尽量少被打断。&lt;/p&gt;\n&lt;p&gt;这是理想的状态，实践下来之后发现，我并没那么自律😄&lt;/p&gt;\n&lt;p&gt;不过好在5点起床的习惯基本已经养成了。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#33：创业者的一天&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:57:38&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-33chuang-ye-zhe-de-yi-tian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:114000,&#34;words&#34;:560,&#34;minutes&#34;:2},&#34;description&#34;:&#34;程序员自由创业周记#33：创业者的一天\n\n一天的安排\n只工作不上班的日子是非常考验一个人自律能力的，如果顶不住各种诱惑，一天的时间转瞬即逝。尤其对我这种兴趣极其广泛的人。如果不自律，上午一场NBA比赛就过去了；如果不自律，下午一场球就过去了...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B033%E5%88%9B%E4%B8%9A%E8%80%85%E7%9A%84%E4%B8%80%E5%A4%A9\&#34;&gt;程序员自由创业周记#33：创业者的一天&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E5%A4%A9%E7%9A%84%E5%AE%89%E6%8E%92\&#34;&gt;一天的安排&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%89%8D\&#34;&gt;在改进之前：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%BA%86%E6%94%B9%E8%BF%9B\&#34;&gt;后来进行了改进&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%88%E6%9E%9C\&#34;&gt;效果&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;4月收支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记32新产品构思\&#34;&gt;程序员自由创业周记#32：新产品构思&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/3340976/pexels-photo-3340976.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;新作品\&#34;&gt;新作品&lt;/h3&gt;\n&lt;p&gt;我时常把自己看做一位木匠，有点手艺，能做一些作品养活自己。而 加一、Island Widgets、Nap 就是我的作品。&lt;/p&gt;\n&lt;p&gt;接下来在持续维护迭代的同时，要开启下一个作品的创造了。&lt;/p&gt;\n&lt;p&gt;其实早在2022的10月份就已经开始搭建项目的基本框架并做了一些开发了。不过鉴于没有一套完善的UI和原型，进度一拖再拖。&lt;/p&gt;\n&lt;p&gt;创业后发现，如果有一套完善的UI图、在编码和迭代速度方面都很快，然而边开发边自己设计既慢又丑。XWOKR 就是一个典型的例子，项目启动了一年多，依然是个Demo。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;创业这大半年，效率最高的还是拿到加一设计图，两耳不闻窗外事，一个月完成一个完整App的时期。&lt;/p&gt;\n&lt;p&gt;最近也开始了Figma的学习，补足设计的短板。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.04.19.17134909020829.17134875991846.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;okr-的构思\&#34;&gt;OKR 的构思&lt;/h3&gt;\n&lt;p&gt;对于这个产品，脑海中时常会构思他的功能，大概是这样的：&lt;/p&gt;\n&lt;p&gt;这是一个OKR产品，专注于个人目标管理的个人OKR，分不同时间阶段设定不同的目标，每个目标分成不同的可量化指标，每个可量化指标通过待办事项完成进度。（Objective -&amp;gt; KR -&amp;gt; TODO）&lt;/p&gt;\n&lt;p&gt;最终的结果是随着各种待办的完成，所有的可量化指标进而达标，每一项指标的完成进而实现目标。（TODO -&amp;gt; KR -&amp;gt; Objective）。&lt;/p&gt;\n&lt;p&gt;比如：设定目标：提高身体素质，分为指标1：每周至少跑步4次；指标2：每天至少睡8小时；指标3：每天至少步行5000步。&lt;/p&gt;\n&lt;p&gt;每天的待办中完成相应的指标，自动记录进度。&lt;/p&gt;\n&lt;p&gt;其他的特点就是周期性，每年、每个季度、每个月 制定不同的目标。&lt;/p&gt;\n&lt;p&gt;复盘，对于完成有什么奖励、完不成有什么惩罚，在制定目标的时候就设置好。&lt;/p&gt;\n&lt;p&gt;有时候每到年底复盘和年终总结，会觉得自己好像有些碌碌无为，其中很大一部分原因是不知道自己在干什么，为了什么，也没有直观能看到自己目标和理想的一个工具，新产品就是提供这个工具。即是给自己开发，也是为了其他有目标管理的用户。&lt;/p&gt;\n&lt;p&gt;名字还没想好。&lt;/p&gt;\n&lt;h3 id=\&#34;本周进度\&#34;&gt;本周进度&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 新增日历组件，在灵动岛和锁屏显示iPhone自带的日历，提醒您不再忘记各种日程安排&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/app/id6471501135\&#34;&gt;Nap - Break Reminder&lt;/a&gt; 优化内存占用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-32xin-chan-pin-gou-si&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记32新产品构思\&#34;&gt;程序员自由创业周记#32：新产品构思&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/3340976/pexels-photo-3340976.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;新作品\&#34;&gt;新作品&lt;/h3&gt;\n&lt;p&gt;我时常把自己看做一位木匠，有点手艺，能做一些作品养活自己。而 加一、Island Widgets、Nap 就是我的作品。&lt;/p&gt;\n&lt;p&gt;接下来在持续维护迭代的同时，要开启下一个作品的创造了。&lt;/p&gt;\n&lt;p&gt;其实早在2022的10月份就已经开始搭建项目的基本框架并做了一些开发了。不过鉴于没有一套完善的UI和原型，进度一拖再拖。&lt;/p&gt;\n&lt;p&gt;创业后发现，如果有一套完善的UI图、在编码和迭代速度方面都很快，然而边开发边自己设计既慢又丑。XWOKR 就是一个典型的例子，项目启动了一年多，依然是个Demo。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#32：新产品构思&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:57:10&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-32xin-chan-pin-gou-si/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:145000,&#34;words&#34;:698,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#32：新产品构思\n\n新作品\n我时常把自己看做一位木匠，有点手艺，能做一些作品养活自己。而 加一、Island Widgets、Nap 就是我的作品。\n接下来在持续维护迭代的同时，要开启下一个作品的创造了。\n其实早在202...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B032%E6%96%B0%E4%BA%A7%E5%93%81%E6%9E%84%E6%80%9D\&#34;&gt;程序员自由创业周记#32：新产品构思&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E4%BD%9C%E5%93%81\&#34;&gt;新作品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#okr-%E7%9A%84%E6%9E%84%E6%80%9D\&#34;&gt;OKR 的构思&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%BA%A6\&#34;&gt;本周进度&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记31我曾走在崩溃的边缘\&#34;&gt;程序员自由创业周记#31：我曾走在崩溃的边缘&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/18376941/pexels-photo-18376941.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;给大家推荐一本书\&#34;&gt;给大家推荐一本书&lt;/h3&gt;\n&lt;p&gt;《我曾走在崩溃的边缘》讲的是俞敏洪讲述新东方从0到1、从1到N的创业历程。很久以前就看过，虽然书中的内容已经忘得基本差不多了，但是书名仍记忆犹新。因为刚过去的这周，我也走在崩溃的边缘。&lt;/p&gt;\n&lt;p&gt;原因是因为我的大意，导致过去两个月创业的收入付之一炬。本来今天没心情写周记的，但是这种心路历程还是值的记录一下。&lt;/p&gt;\n&lt;p&gt;说是我的原因吧，我又觉得不全是。周二的下午，骑着我的小电动，迎着落日的晚霞在北京三环的辅路机动车道上一路疾驶，耳机里播放着 《一个创业“失败者”的自白》的播客（我还是那么喜欢骑行的时候听播客，就像过去5年骑自行车通勤时那样），突然耳机不响了，我似乎意识到了什么，下意识摸了下口袋，手机没了。随即调转车头回来时的路上找，值得庆幸的是在身后200米的地方找到了手机，不幸的是-碎了。一旁的行人告诉我说是刚才被车碾过去了。我拿着正在掉渣的手机，矗立在北京短暂春天傍晚的冷风中。电动车是用手机启动的，然而电动车锁了，手机无法启动。跟行人借手机打电话求助家人用她的手机给我电动车远程解锁，别人看我一年富力强的小伙手里拿着一个碎手机，纷纷避而远之，即便我坐公交车的时候每次都会给老人让座，但是此时依然没人借给我。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.04.12.17128929537491.17128929322605.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;祸不单行\&#34;&gt;祸不单行&lt;/h3&gt;\n&lt;p&gt;碎的手机是去年4月9号花7359买的iPhone 14 Pro Max，我灵动岛软件 Island Widgets唯一能真机测试灵动岛的主力机。而周二，也是4月9号。当晚拿着这台无法开机去手机店，店员看了直摇头，屏幕碎了、电池弯了、主板断了，三大件，一样没有好的。已经失去了维修的价值，回收的话可以换个脸盆。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;周记2：前期准备中提到我创业伊始买过一台iPhone12的测试机，幸亏有它，我还不至于失联，但是就是在第二天，我刚把手机卡放进去没多会，吃饭的时候从同一个口袋里掉在了地上，也坏了，开不了机了。&lt;/p&gt;\n&lt;p&gt;要知道，现在已经不是上班巅峰的时候了，有工资心里有底，遇事不慌。这两天内失去9k，说走在崩溃的边缘也不为过吧，甚至当天晚上我下载了Boss直聘。奉劝想创业的程序员，在副业超过主业之前，尽量不要冒险全职做。&lt;/p&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;p&gt;上线了在灵动岛显示和处理系统待办的功能，解决的痛点是把Apple提醒事项的各种待办在锁屏或灵动岛显示和处理，无需打开App。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.04.12.17128928849122.17128925815463.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;3月收支\&#34;&gt;3月收支&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;支出：14520.05&lt;/li&gt;\n&lt;li&gt;收入：$597&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-31wo-ceng-zou-zai-beng-kui-de-bian-yuan&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记31我曾走在崩溃的边缘\&#34;&gt;程序员自由创业周记#31：我曾走在崩溃的边缘&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/18376941/pexels-photo-18376941.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;给大家推荐一本书\&#34;&gt;给大家推荐一本书&lt;/h3&gt;\n&lt;p&gt;《我曾走在崩溃的边缘》讲的是俞敏洪讲述新东方从0到1、从1到N的创业历程。很久以前就看过，虽然书中的内容已经忘得基本差不多了，但是书名仍记忆犹新。因为刚过去的这周，我也走在崩溃的边缘。&lt;/p&gt;\n&lt;p&gt;原因是因为我的大意，导致过去两个月创业的收入付之一炬。本来今天没心情写周记的，但是这种心路历程还是值的记录一下。&lt;/p&gt;\n&lt;p&gt;说是我的原因吧，我又觉得不全是。周二的下午，骑着我的小电动，迎着落日的晚霞在北京三环的辅路机动车道上一路疾驶，耳机里播放着 《一个创业“失败者”的自白》的播客（我还是那么喜欢骑行的时候听播客，就像过去5年骑自行车通勤时那样），突然耳机不响了，我似乎意识到了什么，下意识摸了下口袋，手机没了。随即调转车头回来时的路上找，值得庆幸的是在身后200米的地方找到了手机，不幸的是-碎了。一旁的行人告诉我说是刚才被车碾过去了。我拿着正在掉渣的手机，矗立在北京短暂春天傍晚的冷风中。电动车是用手机启动的，然而电动车锁了，手机无法启动。跟行人借手机打电话求助家人用她的手机给我电动车远程解锁，别人看我一年富力强的小伙手里拿着一个碎手机，纷纷避而远之，即便我坐公交车的时候每次都会给老人让座，但是此时依然没人借给我。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.04.12.17128929537491.17128929322605.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;祸不单行\&#34;&gt;祸不单行&lt;/h3&gt;\n&lt;p&gt;碎的手机是去年4月9号花7359买的iPhone 14 Pro Max，我灵动岛软件 Island Widgets唯一能真机测试灵动岛的主力机。而周二，也是4月9号。当晚拿着这台无法开机去手机店，店员看了直摇头，屏幕碎了、电池弯了、主板断了，三大件，一样没有好的。已经失去了维修的价值，回收的话可以换个脸盆。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#31：我曾走在崩溃的边缘&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:56:42&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-31wo-ceng-zou-zai-beng-kui-de-bian-yuan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:170000,&#34;words&#34;:833,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#31：我曾走在崩溃的边缘\n\n给大家推荐一本书\n《我曾走在崩溃的边缘》讲的是俞敏洪讲述新东方从0到1、从1到N的创业历程。很久以前就看过，虽然书中的内容已经忘得基本差不多了，但是书名仍记忆犹新。因为刚过去的这周，我也走在崩...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B031%E6%88%91%E6%9B%BE%E8%B5%B0%E5%9C%A8%E5%B4%A9%E6%BA%83%E7%9A%84%E8%BE%B9%E7%BC%98\&#34;&gt;程序员自由创业周记#31：我曾走在崩溃的边缘&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%8E%A8%E8%8D%90%E4%B8%80%E6%9C%AC%E4%B9%A6\&#34;&gt;给大家推荐一本书&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A5%B8%E4%B8%8D%E5%8D%95%E8%A1%8C\&#34;&gt;祸不单行&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;3月收支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记30两周发布5个版本\&#34;&gt;程序员自由创业周记#30：两周发布5个版本&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6633920/pexels-photo-6633920.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;两周发布5个版本\&#34;&gt;两周发布5个版本&lt;/h3&gt;\n&lt;p&gt;过去两周，Island Widgets 发了5个版本，在灵动岛小组件这个极其细分的领域，我想做到极致，以致于在提到灵动岛上可以使用小组件，第一个想起的就是 Island Widgets。如果做到这个程度，还有很长的路要走，这也迫使我不求多，但求精。所以创业这半年来，主要精力还是在这个产品。五个版本分别上线了5个不同的新功能，有意思的新功能。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;新功能几乎都源于用户反馈，在自己斟酌后开发、测试、上线，这其中的标准就是有用和有趣。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555644.E66C08EB-7343-455B-8C84-0CAD82DE8FCC_1_101_o.jpeg\&#34; alt=\&#34;版本记录\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;灵动岛软件新功能喝水提醒\&#34;&gt;灵动岛软件新功能：喝水提醒&lt;/h3&gt;\n&lt;p&gt;喝水提醒这个领域之前就有耳闻，小众且细分的赛道。毕竟现代人的工作节奏之快，往往会不注重健康，等到渴了再去喝水的时候其实就是身体在抗议了。把每天喝水的数量放在灵动岛，每喝一次在灵动岛做个记录，每隔一段时间提醒，这全程不需要打开App。比起市面上的喝水提醒软件，操作便捷的同时满足了需求。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555664.BB2BB4A8-C539-48B2-991A-64DBBB27AA63_1_105_c.jpeg\&#34; alt=\&#34;喝水提醒\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;灵动岛软件新功能时速\&#34;&gt;灵动岛软件新功能：时速&lt;/h3&gt;\n&lt;p&gt;比如在骑车或者开车的时候，想看到自己当前的速度，也不想下载其他软件，那就可以使用 Island Widgets，把当前时速放在灵动岛上。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555677.BE544817-E7E3-4091-8933-3CA951DA3549_1_105_c.jpeg\&#34; alt=\&#34;灵动时速\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;灵动岛软件新功能一言\&#34;&gt;灵动岛软件新功能：一言&lt;/h3&gt;\n&lt;p&gt;如果每次拿起手机，手机上第一眼看到的是一句名言，会不经意中给自己加油打气。有些话，也能让自己有一些共鸣，&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555688.FED34EFD-8453-40F1-9371-0157FD230041_1_105_c.jpeg\&#34; alt=\&#34;灵动鸡汤\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;灵动岛软件新功能快递进度\&#34;&gt;灵动岛软件新功能：快递进度&lt;/h3&gt;\n&lt;p&gt;这个功能也是在之前发起投票中用户反馈最希望上线的功能，比如买了一个iPhone，不用再打开购物软件，把快递进度放在灵动岛，快递到哪了一目了然。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.29.17116851555699.17116836833244.jpg\&#34; alt=\&#34;软件共建\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;番外\&#34;&gt;番外&lt;/h3&gt;\n&lt;p&gt;分享一次有趣的经历，因为我不上班，所以几乎每个工作日的下午，我都会出现在体育公园的篮球场，那天一个白发苍苍的老爷爷走近我，语重心长的告诫我，年轻的时间是有限的，现在应该干什么，不要等以后老了后悔。我听后若有所思...&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-30liang-zhou-fa-bu-5-ge-ban-ben&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记30两周发布5个版本\&#34;&gt;程序员自由创业周记#30：两周发布5个版本&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6633920/pexels-photo-6633920.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;两周发布5个版本\&#34;&gt;两周发布5个版本&lt;/h3&gt;\n&lt;p&gt;过去两周，Island Widgets 发了5个版本，在灵动岛小组件这个极其细分的领域，我想做到极致，以致于在提到灵动岛上可以使用小组件，第一个想起的就是 Island Widgets。如果做到这个程度，还有很长的路要走，这也迫使我不求多，但求精。所以创业这半年来，主要精力还是在这个产品。五个版本分别上线了5个不同的新功能，有意思的新功能。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#30：两周发布5个版本&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:56:17&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-30liang-zhou-fa-bu-5-ge-ban-ben/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:128000,&#34;words&#34;:633,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#30：两周发布5个版本\n\n两周发布5个版本\n过去两周，Island Widgets 发了5个版本，在灵动岛小组件这个极其细分的领域，我想做到极致，以致于在提到灵动岛上可以使用小组件，第一个想起的就是 Island Wid...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B030%E4%B8%A4%E5%91%A8%E5%8F%91%E5%B8%835%E4%B8%AA%E7%89%88%E6%9C%AC\&#34;&gt;程序员自由创业周记#30：两周发布5个版本&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%A4%E5%91%A8%E5%8F%91%E5%B8%835%E4%B8%AA%E7%89%88%E6%9C%AC\&#34;&gt;两周发布5个版本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%81%B5%E5%8A%A8%E5%B2%9B%E8%BD%AF%E4%BB%B6%E6%96%B0%E5%8A%9F%E8%83%BD%E5%96%9D%E6%B0%B4%E6%8F%90%E9%86%92\&#34;&gt;灵动岛软件新功能：喝水提醒&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%81%B5%E5%8A%A8%E5%B2%9B%E8%BD%AF%E4%BB%B6%E6%96%B0%E5%8A%9F%E8%83%BD%E6%97%B6%E9%80%9F\&#34;&gt;灵动岛软件新功能：时速&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%81%B5%E5%8A%A8%E5%B2%9B%E8%BD%AF%E4%BB%B6%E6%96%B0%E5%8A%9F%E8%83%BD%E4%B8%80%E8%A8%80\&#34;&gt;灵动岛软件新功能：一言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%81%B5%E5%8A%A8%E5%B2%9B%E8%BD%AF%E4%BB%B6%E6%96%B0%E5%8A%9F%E8%83%BD%E5%BF%AB%E9%80%92%E8%BF%9B%E5%BA%A6\&#34;&gt;灵动岛软件新功能：快递进度&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%95%AA%E5%A4%96\&#34;&gt;番外&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记29如果遇到裁员\&#34;&gt;程序员自由创业周记#29：如果遇到裁员&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1029141/pexels-photo-1029141.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;希望\&#34;&gt;希望&lt;/h3&gt;\n&lt;p&gt;希望你们的职业生涯永远不会遇到裁员，希望你们所在的部门善待员工，也希望你们的公司遵纪守法。但是，如果你们不幸遇上这种事，我也希望你们知道该如何对应。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;劳动法\&#34;&gt;&lt;a href=\&#34;https://www.gov.cn/flfg/2007-06/29/content_669394.htm\&#34;&gt;劳动法&lt;/a&gt;&lt;/h3&gt;\n&lt;p&gt;这是劳动法的网址：https://www.gov.cn/flfg/2007-06/29/content_669394.htm 。&lt;/p&gt;\n&lt;p&gt;我觉得这是每位劳动者都需要了解的法律。&lt;/p&gt;\n&lt;p&gt;当企业想裁员可能会无所不用其极，很多人会受不了公司的PUA或各种威逼利诱接受了0赔偿或者N或者N+1的条件离开，在协议解除的离职合同上签了字，当你签了字，法律也不会保护你。&lt;/p&gt;\n&lt;p&gt;当然，如果自己能接受，也未尝不可。&lt;/p&gt;\n&lt;p&gt;但是我想告诉你的是，只要你没有犯特别大的错，法律规定的赔偿标准是2N。一般来说，拿到2N需要走法律途径。而且年终奖，如果走法律途径，大概率也能争取得到。&lt;/p&gt;\n&lt;p&gt;所以你自己计算下省心拿走 N+1 离开 和 走法律途径拿 2N+年终 两者数额的差距，就能知道自己该采取哪种应对措施。所有低于 N+1 方案都是耍流氓。&lt;/p&gt;\n&lt;h3 id=\&#34;什么是犯特别大的错\&#34;&gt;什么是“犯特别大的错”&lt;/h3&gt;\n&lt;p&gt;看劳动法的第39条和第40条。其中容易中圈套的在 &amp;quot;严重违反用人单位的规章制度的&amp;quot; 和 &amp;quot;劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；&amp;quot;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;有些公司会因为员工没按时提交周报说员工“严重违反”了规章制度，那就去找公司的规章制度里哪一条规定了。以此类推。&lt;/li&gt;\n&lt;li&gt;“不胜任工作“，找公司的规章制度，什么标准是不胜任，而不是你的领导说你不胜任。即便真的不胜任了，需要给你培训，再次指定&lt;strong&gt;合理&lt;/strong&gt;标准进行考核。即便二次考核也不幸没达到标准，也是N+1走人。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;如果想走法律途径维权\&#34;&gt;如果想走法律途径维权&lt;/h3&gt;\n&lt;p&gt;下面是我之前在一些律师群里收集到的应对方法，分享给你们。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.15.17104798993901.17104789339698.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;strong&gt;word文件完整版见：https://github.com/qxuewei/Laodongfa&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;当被告知被裁员\&#34;&gt;当被告知被裁员&lt;/h3&gt;\n&lt;p&gt;你在这家公司的生涯已经结束了，不要在抱有任何幻想。专心准备后续的路，记得挺起腰来。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.15.17104798993916.2B6E3095-6519-4719-905A-D3AAAA613BAD_1_105_c.jpeg\&#34; alt=\&#34;精神辞职\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;如果不给离职证明\&#34;&gt;如果不给离职证明&lt;/h3&gt;\n&lt;p&gt;把这段话发给你们的HR。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.15.17104798993928.7480b0436869cc2456773ef3a5335406.jpg\&#34; alt=\&#34;不给离职证明应对\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-29ru-guo-yu-dao-cai-yuan&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记29如果遇到裁员\&#34;&gt;程序员自由创业周记#29：如果遇到裁员&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1029141/pexels-photo-1029141.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;希望\&#34;&gt;希望&lt;/h3&gt;\n&lt;p&gt;希望你们的职业生涯永远不会遇到裁员，希望你们所在的部门善待员工，也希望你们的公司遵纪守法。但是，如果你们不幸遇上这种事，我也希望你们知道该如何对应。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#29：如果遇到裁员&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-06-26 10:55:47&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-29ru-guo-yu-dao-cai-yuan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:139000,&#34;words&#34;:667,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#29：如果遇到裁员\n\n希望\n希望你们的职业生涯永远不会遇到裁员，希望你们所在的部门善待员工，也希望你们的公司遵纪守法。但是，如果你们不幸遇上这种事，我也希望你们知道该如何对应。\n\n劳动法\n这是劳动法的网址：https:/...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B029%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0%E8%A3%81%E5%91%98\&#34;&gt;程序员自由创业周记#29：如果遇到裁员&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%8C%E6%9C%9B\&#34;&gt;希望&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%B3%E5%8A%A8%E6%B3%95\&#34;&gt;劳动法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8A%AF%E7%89%B9%E5%88%AB%E5%A4%A7%E7%9A%84%E9%94%99\&#34;&gt;什么是“犯特别大的错”&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E6%9E%9C%E6%83%B3%E8%B5%B0%E6%B3%95%E5%BE%8B%E9%80%94%E5%BE%84%E7%BB%B4%E6%9D%83\&#34;&gt;如果想走法律途径维权&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93%E8%A2%AB%E5%91%8A%E7%9F%A5%E8%A2%AB%E8%A3%81%E5%91%98\&#34;&gt;当被告知被裁员&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%BB%99%E7%A6%BB%E8%81%8C%E8%AF%81%E6%98%8E\&#34;&gt;如果不给离职证明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记28小憩\&#34;&gt;程序员自由创业周记#28：小憩&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1804035/pexels-photo-1804035.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;专注\&#34;&gt;专注&lt;/h3&gt;\n&lt;p&gt;不知道你会不会有类似的经历：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;周末在家学习，有点累，玩会手机吧，2个小时过去了。。&lt;/li&gt;\n&lt;li&gt;工作或学习效率太低，计划好的任务一改再改。。&lt;/li&gt;\n&lt;li&gt;长时间工作不能自拔，由于一直盯着屏幕，视力一天不如一天。。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;之前的我经常会遇到类似的问题，经过几年的摸索，提高效率达成目标同时能保持健康的方式就是：计划+番茄钟。&lt;br&gt;\n计划不必多说，一步步达成目标必不可少的步骤，我从18年开始列每天计划，这个习惯已经保持了6年。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592675.17092492400553.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;我的今日计划\&#34;&gt;我的今日计划&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592699.17092490674948.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这其中的 F 就是 Fanqie 的 F。每一次番茄专注时间是 40分钟，每完成一次番茄专注，休息2分钟，看看远方、喝杯水、走动一下、活动活动脖子... 不至于一直盯着屏幕视力变差。&lt;/p&gt;\n&lt;h3 id=\&#34;番茄计时工具\&#34;&gt;番茄计时工具&lt;/h3&gt;\n&lt;p&gt;之前用的手机上的App，使用久了有两个问题：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;每次番茄计时需要自己手动开启。&lt;/li&gt;\n&lt;li&gt;需要拿起手机。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;众所周知，只要我们拿起手机，时间就会变得不可控。&lt;/p&gt;\n&lt;p&gt;有没有能不需要我操作的番茄计时器呢、专注时长我能自己配置、休息时长我也能自己配置、每完成几次休息的时间长一点、休息的时候只能休息。&lt;/p&gt;\n&lt;p&gt;没有，那就自己做一个。 &lt;a href=\&#34;https://apps.apple.com/app/id6471501135\&#34;&gt;Nap - Break Reminder&lt;/a&gt; 应运而生。一款在Mac端提醒休息的番茄钟产品。&lt;/p&gt;\n&lt;p&gt;每次开启自动启动，我习惯把状态栏的图标隐藏掉，让他默默地在后台运行。每工作40分钟屏幕即无法使用，强制自己休息几分钟。休息结束会有提示音告诉我，需要开启新一次专注了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592715.96043B6A-0026-4BAF-B59C-B161D1432686_1_105_c.jpeg\&#34; alt=\&#34;休息效果\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.03.01.17092512592729.17085227772565.jpg\&#34; alt=\&#34;核心功能\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;尤其自己创业以后，时间完成自己掌控，更需要这个番茄钟给我提升工作效率，同时缓解疲劳,定时提醒喝水,避免久坐，更好的进行时间管理。&lt;/p&gt;\n&lt;h2 id=\&#34;怎么体验\&#34;&gt;怎么体验&lt;/h2&gt;\n&lt;p&gt;Mac 用户在 AppStore 搜索：&lt;a href=\&#34;https://apps.apple.com/app/id6471501135\&#34;&gt;Nap&lt;/a&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;或者浏览器直接输入：https://apps.apple.com/app/id6471501135&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-28xiao-qi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记28小憩\&#34;&gt;程序员自由创业周记#28：小憩&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1804035/pexels-photo-1804035.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;专注\&#34;&gt;专注&lt;/h3&gt;\n&lt;p&gt;不知道你会不会有类似的经历：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;周末在家学习，有点累，玩会手机吧，2个小时过去了。。&lt;/li&gt;\n&lt;li&gt;工作或学习效率太低，计划好的任务一改再改。。&lt;/li&gt;\n&lt;li&gt;长时间工作不能自拔，由于一直盯着屏幕，视力一天不如一天。。&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#28：小憩&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;作品&#34;,&#34;slug&#34;:&#34;h-bEXLFyD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/h-bEXLFyD/&#34;},{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-03-01 08:45:17&#34;,&#34;dateFormat&#34;:&#34;2024-03-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-28xiao-qi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:119000,&#34;words&#34;:578,&#34;minutes&#34;:2},&#34;description&#34;:&#34;程序员自由创业周记#28：小憩\n\n专注\n不知道你会不会有类似的经历：\n\n周末在家学习，有点累，玩会手机吧，2个小时过去了。。\n工作或学习效率太低，计划好的任务一改再改。。\n长时间工作不能自拔，由于一直盯着屏幕，视力一天不如一天。。\n\n\n之前...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B028%E5%B0%8F%E6%86%A9\&#34;&gt;程序员自由创业周记#28：小憩&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%93%E6%B3%A8\&#34;&gt;专注&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%91%E7%9A%84%E4%BB%8A%E6%97%A5%E8%AE%A1%E5%88%92\&#34;&gt;我的今日计划&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%95%AA%E8%8C%84%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7\&#34;&gt;番茄计时工具&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%8E%E4%B9%88%E4%BD%93%E9%AA%8C\&#34;&gt;怎么体验&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记27新年快乐\&#34;&gt;程序员自由创业周记#27：新年快乐&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://dogefs.s3.ladydaily.com/~/source/unsplash/photo-1486078695445-0497c2f58cfe?q=80&amp;amp;w=3348&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;ixlib=rb-4.0.3&amp;amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%253D%253D\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;新年快乐\&#34;&gt;新年快乐&lt;/h3&gt;\n&lt;p&gt;给我的读者说一句迟来的新年快乐，希望我们在今年都能得偿所愿~&lt;/p&gt;\n&lt;p&gt;回到老家，谈得最多的也是我目前的现状和想法，我自己何尝不是千万次的问自己呢，我创业的做法在很多人看来都是另类和不务正业的。为什么不去踏踏实实找个班上呢，即使是最亲最近的媳妇也想让我去找个班上，一个程序员，一年的Gap，或是更多年的Gap，无异于断送自己的职业生涯，尤其在我们国人的思想观念里。&lt;/p&gt;\n&lt;p&gt;之前计划的13个月的梦已然过半，积蓄越来越少，仲裁的结果也犹如晴天霹雳，为什么还要坚持创业，坚持自己做软件卖呢，在坚持什么呢？&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;我是这么想的\&#34;&gt;我是这么想的：&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;少挣的钱就当买了我的自由，而自由于我而言是无价的。&lt;/li&gt;\n&lt;li&gt;人不能一辈子打工，需要有自己的事业，一份完全属于自己的事业。&lt;/li&gt;\n&lt;li&gt;职场里的我就像温水里的青蛙，一年又一年，一年又一年... 毫无波澜。&lt;/li&gt;\n&lt;li&gt;生命的意义于我而言就是体验，体验不同的经历。&lt;/li&gt;\n&lt;li&gt;目前创业的收入已经超出我之前的预期。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;节点\&#34;&gt;节点&lt;/h3&gt;\n&lt;p&gt;过年期间跟媳妇定了一个节点，如果月收入达不到5k，今年8月份就去找工作。我也欣然答应，毕竟不是单身，还有家庭的责任要负，家里的顶梁柱一个月如果不能给家里带回5K，我也觉得是不称职的。而8月份就是这场13个月梦的最后一个月。按照目前的收入水平，还需多多努力才行。之前计划的是满第一年月收入3K就继续自己干，现在计划有变，不过依然志在必得。&lt;/p&gt;\n&lt;h3 id=\&#34;仲裁判决\&#34;&gt;仲裁判决&lt;/h3&gt;\n&lt;p&gt;之前聊过我开始创业的其中一个原因是被之前公司单方解除劳动合同，而且是无赔偿。仲裁在昨天出了判决书，因为在单方解除合同通知书上我签了字，而通知书上有一行“对通知内容没有异议” 的话，我当时只看到了 “签收页”。就像取快递签字一样签上了自己的名字，而这，是我败诉的原因。而我准备的十几个G的努力工作，解决工作问题，每天写日报汇报工作成果等等的证据，只字未提。希望我的读者不要遇到这种公司、这种部门，如果像我一样运气差，记得不要签字，任何字。&lt;/p&gt;\n&lt;h3 id=\&#34;新产品\&#34;&gt;新产品&lt;/h3&gt;\n&lt;p&gt;继创业后开发了 &lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一 - 自律打卡&lt;/a&gt; 和 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 两款产品后，这周发布了创业的第三个产品，下篇周记带来给大家认识。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-27xin-nian-kuai-le&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记27新年快乐\&#34;&gt;程序员自由创业周记#27：新年快乐&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://dogefs.s3.ladydaily.com/~/source/unsplash/photo-1486078695445-0497c2f58cfe?q=80&amp;amp;w=3348&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;ixlib=rb-4.0.3&amp;amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%253D%253D\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;新年快乐\&#34;&gt;新年快乐&lt;/h3&gt;\n&lt;p&gt;给我的读者说一句迟来的新年快乐，希望我们在今年都能得偿所愿~&lt;/p&gt;\n&lt;p&gt;回到老家，谈得最多的也是我目前的现状和想法，我自己何尝不是千万次的问自己呢，我创业的做法在很多人看来都是另类和不务正业的。为什么不去踏踏实实找个班上呢，即使是最亲最近的媳妇也想让我去找个班上，一个程序员，一年的Gap，或是更多年的Gap，无异于断送自己的职业生涯，尤其在我们国人的思想观念里。&lt;/p&gt;\n&lt;p&gt;之前计划的13个月的梦已然过半，积蓄越来越少，仲裁的结果也犹如晴天霹雳，为什么还要坚持创业，坚持自己做软件卖呢，在坚持什么呢？&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#27：新年快乐&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-02-23 09:44:05&#34;,&#34;dateFormat&#34;:&#34;2024-02-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-27xin-nian-kuai-le/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:156000,&#34;words&#34;:770,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#27：新年快乐\n\n新年快乐\n给我的读者说一句迟来的新年快乐，希望我们在今年都能得偿所愿~\n回到老家，谈得最多的也是我目前的现状和想法，我自己何尝不是千万次的问自己呢，我创业的做法在很多人看来都是另类和不务正业的。为什么不...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B027%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90\&#34;&gt;程序员自由创业周记#27：新年快乐&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90\&#34;&gt;新年快乐&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%91%E6%98%AF%E8%BF%99%E4%B9%88%E6%83%B3%E7%9A%84\&#34;&gt;我是这么想的：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8A%82%E7%82%B9\&#34;&gt;节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%B2%E8%A3%81%E5%88%A4%E5%86%B3\&#34;&gt;仲裁判决&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E4%BA%A7%E5%93%81\&#34;&gt;新产品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记26实习生\&#34;&gt;程序员自由创业周记#26：实习生&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6153354/pexels-photo-6153354.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;不发工资的实习生\&#34;&gt;不发工资的实习生&lt;/h3&gt;\n&lt;p&gt;一个人的力量是有限的，尤其是创业。因为要兼顾很多，需要的做的事也很多，而且时间有限，所以有一个帮手至关重要。不过鉴于创业的启动资金有限，雇人在现阶段是不现实的，所以只能通过其他的办法分担我的压力了，这个实习生就是 - AI。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;一个不用发工资的实习生。&lt;/p&gt;\n&lt;h3 id=\&#34;chatgpt\&#34;&gt;ChatGPT&lt;/h3&gt;\n&lt;p&gt;是ChatGPT但也不全是。&lt;/p&gt;\n&lt;h4 id=\&#34;xcode\&#34;&gt;Xcode&lt;/h4&gt;\n&lt;p&gt;Xcode集成了 &lt;a href=\&#34;https://github.com/intitni/CopilotForXcode\&#34;&gt;CopilotForXcode&lt;/a&gt;，敲代码的时候有一些简单的不太需要费脑的逻辑只要输入注释，基本会生成大致能用的代码，比如：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.02.01.17067991103824.17067965788658.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;目前 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 有大概10% 的代码是 CopilotForXcode 替我写的，以前代码写的漂亮是我的核心竞争力，不过现在不是了，现在核心竞争力是创造和执行力。&lt;/p&gt;\n&lt;h4 id=\&#34;搜索\&#34;&gt;搜索&lt;/h4&gt;\n&lt;p&gt;以前搜索问题只有一个选项，Google。现在是 &lt;a href=\&#34;https://chat.openai.com/\&#34;&gt;chat.openai.com&lt;/a&gt; 。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.02.01.17067991103836.17067970619600.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;除了经常性的宕机不能访问，基本70%的问题都能解决，宕机的时候我会用 &lt;a href=\&#34;https://poe.com/ChatGPT\&#34;&gt;Poe&lt;/a&gt;，他本质上跟上面的网站是一样的，只不过Poe使用的 API 接口。在代码层面的问题，我个人觉得Poe比官方的网站更精确。回答的更令我满意一点。其他代码相关的AI服务也有尝试，不敢恭维。&lt;/p&gt;\n&lt;h4 id=\&#34;其他\&#34;&gt;其他&lt;/h4&gt;\n&lt;p&gt;AI在过去的一年已经渗透到生活的方方面面，列举我曾用过的服务除了敲代码以外，还有写演讲稿、做PPT、App的UI设计、应用商店的描述... 未来还会接触更多场景。毕竟这个“实习生”任劳任怨，除了解决问题别无他求。在各种平台经常有兜售AI教学的课程，给人一种现阶段你如果不马上学就要跟不上时代的错觉，我从来不会为之焦虑。底层还是自己的认知，AI只是个工具。&lt;/p&gt;\n&lt;p&gt;至于未来程序员会不会被AI取代，我觉得大概率是不会的。因为它不会创造。&lt;/p&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;p&gt;依然是在开发 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt;。为每个功能提供悬浮窗功能，除了灵动岛、锁屏再增加一个展现场景。在“做最好的灵动岛应用”的路上砥砺前行。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.02.01.17067991103844.17067990556390.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-26shi-xi-sheng&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记26实习生\&#34;&gt;程序员自由创业周记#26：实习生&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6153354/pexels-photo-6153354.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=800\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;不发工资的实习生\&#34;&gt;不发工资的实习生&lt;/h3&gt;\n&lt;p&gt;一个人的力量是有限的，尤其是创业。因为要兼顾很多，需要的做的事也很多，而且时间有限，所以有一个帮手至关重要。不过鉴于创业的启动资金有限，雇人在现阶段是不现实的，所以只能通过其他的办法分担我的压力了，这个实习生就是 - AI。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#26：实习生&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-02-02 09:51:49&#34;,&#34;dateFormat&#34;:&#34;2024-02-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-26shi-xi-sheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:132000,&#34;words&#34;:635,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#26：实习生\n\n不发工资的实习生\n一个人的力量是有限的，尤其是创业。因为要兼顾很多，需要的做的事也很多，而且时间有限，所以有一个帮手至关重要。不过鉴于创业的启动资金有限，雇人在现阶段是不现实的，所以只能通过其他的办法分担...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B026%E5%AE%9E%E4%B9%A0%E7%94%9F\&#34;&gt;程序员自由创业周记#26：实习生&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E5%8F%91%E5%B7%A5%E8%B5%84%E7%9A%84%E5%AE%9E%E4%B9%A0%E7%94%9F\&#34;&gt;不发工资的实习生&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#chatgpt\&#34;&gt;ChatGPT&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#xcode\&#34;&gt;Xcode&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%90%9C%E7%B4%A2\&#34;&gt;搜索&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96\&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记25一个功能的诞生\&#34;&gt;程序员自由创业周记#25：一个功能的诞生&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/4491918/pexels-photo-4491918.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1200\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;快捷启动\&#34;&gt;快捷启动&lt;/h3&gt;\n&lt;p&gt;记录在创业项目 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt;  中新增一个功能的诞生过程。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;功能名称：快捷启动。&lt;/p&gt;\n&lt;p&gt;具体点：不用回到桌面在锁屏界面或者灵动岛就能打开其他App、网页或快捷指令。&lt;/p&gt;\n&lt;h4 id=\&#34;使用场景1\&#34;&gt;使用场景1：&lt;/h4&gt;\n&lt;p&gt;手机揣兜里从超市里买了一些东西，收银台付款。正常流程：&lt;br&gt;\n点亮屏幕 -&amp;gt; 解锁 -&amp;gt; 上滑屏幕 -&amp;gt; 进入桌面 -&amp;gt; 左滑右滑找到微信所在的屏幕 -&amp;gt; 点击微信 -&amp;gt; 点击右上角加号 -&amp;gt; 找到扫一扫 -&amp;gt; 付款。&lt;/p&gt;\n&lt;p&gt;开启 【快捷启动】 后付款流程：&lt;br&gt;\n点亮屏幕 -&amp;gt; 点击微信扫一扫图标 -&amp;gt; 付款。&lt;/p&gt;\n&lt;h4 id=\&#34;使用场景2\&#34;&gt;使用场景2：&lt;/h4&gt;\n&lt;p&gt;刷微博遇到一个不懂的单词想查一下。正常流程：&lt;br&gt;\n上滑屏幕 -&amp;gt; 进入桌面 -&amp;gt; 左滑右滑找到翻译App所在的屏幕 -&amp;gt; 点击翻译App -&amp;gt; 查&lt;/p&gt;\n&lt;p&gt;开启 【快捷启动】 后查单词流程：&lt;br&gt;\n长按灵动岛 -&amp;gt; 点击翻译App图标 -&amp;gt; 查&lt;/p&gt;\n&lt;h4 id=\&#34;使用场景3\&#34;&gt;使用场景3：&lt;/h4&gt;\n&lt;p&gt;做一道菜想问问ChatGPT怎么做。正常流程：&lt;br&gt;\n点亮屏幕 -&amp;gt; 解锁 -&amp;gt; 上滑屏幕 -&amp;gt; 进入桌面 -&amp;gt; 左滑右滑找到Safari所在的屏幕 -&amp;gt; 点击Safari -&amp;gt; 点击网页输入框 -&amp;gt; 输入 chat.openai.com -&amp;gt; 问&lt;/p&gt;\n&lt;p&gt;开启 【快捷启动】 后打开网页流程：&lt;br&gt;\n点亮屏幕 -&amp;gt; 点击ChatGPT网页图标 -&amp;gt; 问。&lt;/p&gt;\n&lt;p&gt;...&lt;/p&gt;\n&lt;p&gt;把一些常用的App、功能、网页或者快捷指令放在锁屏或是灵动岛上，想用的时候直接点。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.01.26.17062304448149.CE3FE67D-EF24-4CE7-A13C-9032B2375A5E_1_102_o.jpeg\&#34; alt=\&#34;锁屏上的效果\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;功能已发布\&#34;&gt;功能已发布&lt;/h3&gt;\n&lt;p&gt;上周没写周记，一直在做这个让人兴奋以致于沉迷代码不能自拔的功能。从构思、设计、开发、测试、上线、推广所有的流程都自己做：&lt;/p&gt;\n&lt;p&gt;比如可以自定义多个分组，上班时间、下班时间、周末分别使用不同的分组，每个分组用不同的启动项；&lt;/p&gt;\n&lt;p&gt;比如长按灵动岛的时候显示快捷启动的图标，平常的时候灵动岛就可以显示步数和网速、或者帧率，天气等等现有的25个功能中的任何一个；&lt;/p&gt;\n&lt;p&gt;再比如可以配置多行显示最多4行，每行显示最多9个，最多配置36个不同启动项；&lt;/p&gt;\n&lt;p&gt;还有搜索，内置App清单，自定义任意启动项，自定义图标，同样的功能不同的开启形式用什么区分，复制，移动，调整顺序...&lt;/p&gt;\n&lt;p&gt;所有的功能都是边做边想，边开发边设计，对于一个开发App的程序员，这是最大的乐趣，朋友有时问我最近怎么样，我一般都会回复他 “穷并快乐着”。&lt;/p&gt;\n&lt;h2 id=\&#34;怎么体验\&#34;&gt;怎么体验&lt;/h2&gt;\n&lt;p&gt;iPhone 用户在AppStore 搜索：&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;或者浏览器直接输入：https://apps.apple.com/cn/app/id6464542768&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-25yi-ge-gong-neng-de-dan-sheng&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记25一个功能的诞生\&#34;&gt;程序员自由创业周记#25：一个功能的诞生&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/4491918/pexels-photo-4491918.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1200\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;快捷启动\&#34;&gt;快捷启动&lt;/h3&gt;\n&lt;p&gt;记录在创业项目 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt;  中新增一个功能的诞生过程。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#25：一个功能的诞生&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;作品&#34;,&#34;slug&#34;:&#34;h-bEXLFyD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/h-bEXLFyD/&#34;},{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-01-26 09:08:04&#34;,&#34;dateFormat&#34;:&#34;2024-01-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-25yi-ge-gong-neng-de-dan-sheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:161000,&#34;words&#34;:754,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#25：一个功能的诞生\n\n快捷启动\n记录在创业项目 Island Widgets-学伟®灵动岛锁屏小组件  中新增一个功能的诞生过程。\n\n功能名称：快捷启动。\n具体点：不用回到桌面在锁屏界面或者灵动岛就能打开其他App、网...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B025%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E7%9A%84%E8%AF%9E%E7%94%9F\&#34;&gt;程序员自由创业周记#25：一个功能的诞生&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8\&#34;&gt;快捷启动&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF1\&#34;&gt;使用场景1：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF2\&#34;&gt;使用场景2：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF3\&#34;&gt;使用场景3：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%9F%E8%83%BD%E5%B7%B2%E5%8F%91%E5%B8%83\&#34;&gt;功能已发布&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%8E%E4%B9%88%E4%BD%93%E9%AA%8C\&#34;&gt;怎么体验&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记24逃离北上广\&#34;&gt;程序员自由创业周记#24：逃离北上广&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8950929/pexels-photo-8950929.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;有没有这种城市\&#34;&gt;有没有这种城市&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;房价：市区房价均价1W以内&lt;/li&gt;\n&lt;li&gt;工资：每月工资能买一平米及以上的房子&lt;/li&gt;\n&lt;li&gt;交通：路宽不堵车，高铁、高速发达，坐飞机方便&lt;/li&gt;\n&lt;li&gt;快递：方便，包邮，3天内能到&lt;/li&gt;\n&lt;li&gt;气候：四季分明，不潮湿，晴天多，有暖气&lt;/li&gt;\n&lt;li&gt;人口：市区人口低于500万，宁静不嘈杂&lt;/li&gt;\n&lt;li&gt;生活：肉蛋奶菜便宜，购物方便，有大医院&lt;/li&gt;\n&lt;li&gt;教育：教育资源丰富，基础教育好&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;北漂8年\&#34;&gt;北漂8年&lt;/h3&gt;\n&lt;p&gt;我是15年11月份开始北漂，背井离乡每年回家一两次，父亲从四十多岁的小伙子变成了五十多岁的小老头子。这几年换了4份工作，搬了8次家。&lt;br&gt;\n蒲黄榆 -&amp;gt; 花梨坎 -&amp;gt; 花家地 -&amp;gt; 霍营 -&amp;gt; 六里桥 -&amp;gt; 新村 -&amp;gt; 沙河 -&amp;gt; 洋桥。&lt;br&gt;\n绕着北京转了一圈，现在又转回了最初的起点。&lt;br&gt;\n犹记刚来北京那会还是个没毕业的学生，人生地不熟来这找活。下了火车打车去郑王坟人出租车司机不知道那地，但是那时我手里只有这个地址，其他的都不知道。&lt;br&gt;\n也无奈，学的计算机，老家没相关的就业岗位，只能来这个陌生的城市碰碰运气，那也是第一次出省，好在运气还不错，这一路还算顺利。&lt;/p&gt;\n&lt;p&gt;是时候考虑回去了。&lt;/p&gt;\n&lt;h3 id=\&#34;回哪呢\&#34;&gt;回哪呢？&lt;/h3&gt;\n&lt;p&gt;我家距离青岛火车站和潍坊火车站都是1h30min，17年在烟台买了一个小区自带篮球场游泳馆能看海的房子。所以除了长大的那个村，回就是在这三个城市里选。鉴于我之后的职业规划大概率是继续自由创业，自谋生路。下一站的考虑的条件就主要开篇提到的几点，放眼全国，其实能同时满足上面条件的城市也不多。&lt;/p&gt;\n&lt;h4 id=\&#34;三城数据对比\&#34;&gt;三城数据对比&lt;/h4&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;青岛&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;烟台&lt;/th&gt;\n&lt;th&gt;潍坊&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;房价&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;1.5w&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;0.75w&lt;/td&gt;\n&lt;td&gt;0.63w&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;工资&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;13w&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;10w&lt;/td&gt;\n&lt;td&gt;9w&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;交通&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;地铁+高铁+机场&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;高铁+机场&lt;/td&gt;\n&lt;td&gt;高铁+机场&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;快递&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;3天&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;3天&lt;/td&gt;\n&lt;td&gt;3天&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;气候平均气温+空气优良比例&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;12.7℃ - 83.3%&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;12.6℃ (冬季多雪) - 87.8%&lt;/td&gt;\n&lt;td&gt;12.6℃ - 71.1%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;市区人口&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;601w&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;252w&lt;/td&gt;\n&lt;td&gt;251w&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;生活-三甲医院&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;18个&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;10个&lt;/td&gt;\n&lt;td&gt;8个&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;教育-本科率&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;52%&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;52%&lt;/td&gt;\n&lt;td&gt;55%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;以上数据来自搜索引擎，不保真。&lt;/p&gt;\n&lt;p&gt;三座城市各有各的好，青岛最发达但房价最高、烟台房子在那但离家远归属感差、目前倾向于是回潍坊，上面的8条，都能满足。&lt;br&gt;\n除了山东的地狱级别难度的高考，但是他爸能考上烟大，他妈中考全A还能考上北师大，而且都是在村里上的学，我相信他也行。&lt;br&gt;\n即便不行也没事，开心不作恶就行。&lt;/p&gt;\n&lt;p&gt;媳妇的研究生还得再上一年，目前初步计划是过完龙年回。&lt;/p&gt;\n&lt;h3 id=\&#34;12月收支\&#34;&gt;12月收支&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;家庭支出：14045&lt;/li&gt;\n&lt;li&gt;创业收入：$430&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2024.01.11.17049273472393.F29309AC-7F40-4F71-8BB9-31F5659F21B5_1_105_c.jpeg\&#34; alt=\&#34;小里程碑-排名进前400\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets-学伟®灵动岛锁屏小组件&lt;/a&gt; 的创业项目正逐步走向正规，收入目前已经能覆盖我自己的日常开销，相信随着功能的完善，推广的继续，后续新产品的持续问世... 谁知道呢。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-24tao-chi-bei-shang-guang&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记24逃离北上广\&#34;&gt;程序员自由创业周记#24：逃离北上广&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8950929/pexels-photo-8950929.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;有没有这种城市\&#34;&gt;有没有这种城市&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;房价：市区房价均价1W以内&lt;/li&gt;\n&lt;li&gt;工资：每月工资能买一平米及以上的房子&lt;/li&gt;\n&lt;li&gt;交通：路宽不堵车，高铁、高速发达，坐飞机方便&lt;/li&gt;\n&lt;li&gt;快递：方便，包邮，3天内能到&lt;/li&gt;\n&lt;li&gt;气候：四季分明，不潮湿，晴天多，有暖气&lt;/li&gt;\n&lt;li&gt;人口：市区人口低于500万，宁静不嘈杂&lt;/li&gt;\n&lt;li&gt;生活：肉蛋奶菜便宜，购物方便，有大医院&lt;/li&gt;\n&lt;li&gt;教育：教育资源丰富，基础教育好&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#24：逃离北上广&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-01-11 06:56:20&#34;,&#34;dateFormat&#34;:&#34;2024-01-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-24tao-chi-bei-shang-guang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:181000,&#34;words&#34;:857,&#34;minutes&#34;:4},&#34;description&#34;:&#34;程序员自由创业周记#24：逃离北上广\n\n有没有这种城市\n\n房价：市区房价均价1W以内\n工资：每月工资能买一平米及以上的房子\n交通：路宽不堵车，高铁、高速发达，坐飞机方便\n快递：方便，包邮，3天内能到\n气候：四季分明，不潮湿，晴天多，有暖气\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B024%E9%80%83%E7%A6%BB%E5%8C%97%E4%B8%8A%E5%B9%BF\&#34;&gt;程序员自由创业周记#24：逃离北上广&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%89%E6%B2%A1%E6%9C%89%E8%BF%99%E7%A7%8D%E5%9F%8E%E5%B8%82\&#34;&gt;有没有这种城市&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%97%E6%BC%828%E5%B9%B4\&#34;&gt;北漂8年&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9E%E5%93%AA%E5%91%A2\&#34;&gt;回哪呢？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E5%9F%8E%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%AF%94\&#34;&gt;三城数据对比&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#12%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;12月收支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记23年终总结\&#34;&gt;程序员自由创业周记#23：年终总结&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6149084/pexels-photo-6149084.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;身份转变\&#34;&gt;身份转变&lt;/h3&gt;\n&lt;p&gt;2023年最大的转变是从一名职场打工人变成一名创业者，或者称之为个体户，从月入xxxxx变成月入xxx，从卖自己的时间转变为卖自己做的软件，从每天上班如上坟变成每天活力满满精力充沛，从披星戴月到每天看夕阳。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;一些数字\&#34;&gt;一些数字&lt;/h3&gt;\n&lt;h4 id=\&#34;微信读书-136-小时\&#34;&gt;微信读书 - 136 小时&lt;/h4&gt;\n&lt;p&gt;书读的还远远不够，书架上的书还有99%没读完。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031665.042479AA-2F72-4664-9D1B-0FBA4A50D538_4_5005_c.jpeg\&#34; alt=\&#34;微信读书\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;英语-98-天\&#34;&gt;英语 - 98 天&lt;/h4&gt;\n&lt;p&gt;每天学习30分钟满足打卡条件，蹩脚的英语水平一直困扰着我，记得有一次老外问路地铁站咋走，我想了半天就蹦出俩单词：Follow me！&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031691.ED0FD5CE-AB20-4F25-9B58-1464AE30BAD4_1_105_c.jpeg\&#34; alt=\&#34;英语打卡\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;csdn-14275-万访问\&#34;&gt;CSDN - 142.75 万访问&lt;/h4&gt;\n&lt;p&gt;今年大概多了二十几万，写博客分享技术的第11年。&lt;br&gt;\n庆幸自己有这么个博客，有个空间能记录一些代码技巧、学习笔记、读书笔记啥的，简历上写个博客地址面试机会也能稍微多点，记得有一次找活，招聘软件公开了一天简历约了一星期的面试，也不知道是不是因为有个人技术博客的缘故。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031707.17036443813205.jpg\&#34; alt=\&#34;CSDN\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;掘金-679-万阅读\&#34;&gt;掘金 - 6.79 万阅读&lt;/h4&gt;\n&lt;p&gt;技术分享的少了，流水账多了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031721.17038038507370.jpg\&#34; alt=\&#34;掘金\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;公众号-666-订阅\&#34;&gt;公众号 - 666 订阅&lt;/h4&gt;\n&lt;p&gt;其中 90% 是7月公开创业后围观周记的小伙伴。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031733.17038037141505.jpg\&#34; alt=\&#34;公众号\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;twitter-339-粉丝\&#34;&gt;Twitter - 339 粉丝&lt;/h4&gt;\n&lt;p&gt;我的一个观点：粉丝 != 认同；&lt;br&gt;\n无需为别人的认同改变自己；&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.29.17038043031744.C3D82FEC-8257-4E81-BE3F-060B93BB0179_4_5005_c.jpeg\&#34; alt=\&#34;X\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;软件作品-2-个\&#34;&gt;软件作品 - 2 个&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;：灵动岛/锁屏小组件，包含骑行距离/步数/心率/运动热量/跑步距离/运动时间/体温/下班倒计时/照片/待办/天气/热搜/倒计时/手机使用次数/实时网速/CPU/RAM/屏幕帧率等 (iOS)&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一 - 自律打卡&lt;/a&gt;：习惯养成打卡，追踪生活小事，记录日常情绪，计数、统计 (iOS)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;怎么说也是一名有自己作品的程序员，此处叉腰 👯‍♂️。&lt;/p&gt;\n&lt;h3 id=\&#34;展望\&#34;&gt;展望&lt;/h3&gt;\n&lt;p&gt;当然这一年的丰富多彩得程度是这些冰冷数字远远无法代表的。&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0&amp;amp;scene=178&amp;amp;cur_album_id=3044710252514050050#rd\&#34;&gt;周记#1&lt;/a&gt; 里说过的做一场13个月的梦，转眼已经过半了，幸好我还没有放弃，感谢屏幕对面素未谋面的你在百忙之中看我写的流水账。我不轻易许诺，明年能不能坚持写创业周记我也不确定，可以确定的是我还会继续去做我认为正确的事儿。&lt;/p&gt;\n&lt;p&gt;人这一生有多久呢，如果按活到80岁算，也不过&lt;strong&gt;四千周&lt;/strong&gt;而已，马上放假了，祝各位新年快乐~&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-23nian-zhong-zong-jie&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记23年终总结\&#34;&gt;程序员自由创业周记#23：年终总结&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6149084/pexels-photo-6149084.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;身份转变\&#34;&gt;身份转变&lt;/h3&gt;\n&lt;p&gt;2023年最大的转变是从一名职场打工人变成一名创业者，或者称之为个体户，从月入xxxxx变成月入xxx，从卖自己的时间转变为卖自己做的软件，从每天上班如上坟变成每天活力满满精力充沛，从披星戴月到每天看夕阳。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#23：年终总结&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2024-01-01 16:49:53&#34;,&#34;dateFormat&#34;:&#34;2024-01-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-23nian-zhong-zong-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:143000,&#34;words&#34;:690,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#23：年终总结\n\n身份转变\n2023年最大的转变是从一名职场打工人变成一名创业者，或者称之为个体户，从月入xxxxx变成月入xxx，从卖自己的时间转变为卖自己做的软件，从每天上班如上坟变成每天活力满满精力充沛，从披星戴月...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93\&#34;&gt;程序员自由创业周记#23：年终总结&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BA%AB%E4%BB%BD%E8%BD%AC%E5%8F%98\&#34;&gt;身份转变&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%97\&#34;&gt;一些数字&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6-136-%E5%B0%8F%E6%97%B6\&#34;&gt;微信读书 - 136 小时&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8B%B1%E8%AF%AD-98-%E5%A4%A9\&#34;&gt;英语 - 98 天&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#csdn-14275-%E4%B8%87%E8%AE%BF%E9%97%AE\&#34;&gt;CSDN - 142.75 万访问&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%98%E9%87%91-679-%E4%B8%87%E9%98%85%E8%AF%BB\&#34;&gt;掘金 - 6.79 万阅读&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%AC%E4%BC%97%E5%8F%B7-666-%E8%AE%A2%E9%98%85\&#34;&gt;公众号 - 666 订阅&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#twitter-339-%E7%B2%89%E4%B8%9D\&#34;&gt;Twitter - 339 粉丝&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BD%AF%E4%BB%B6%E4%BD%9C%E5%93%81-2-%E4%B8%AA\&#34;&gt;软件作品 - 2 个&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%95%E6%9C%9B\&#34;&gt;展望&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记22出海去\&#34;&gt;程序员自由创业周记#22：出海去&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/240561/pexels-photo-240561.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;出海初体验\&#34;&gt;出海初体验&lt;/h3&gt;\n&lt;p&gt;工具类软件的特性是不用局限于某一个行业、也不用局限于某一个国家，所以出海是必须的选项，对于程序员而言，没有什么比做的软件有更多人用更令人兴奋；不熟悉互联网行业的人可能不了解什么是出海，不是出海打渔，是把软件推向海外市场，简称出海。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;虽然做的产品 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt; 上架第一天就已经在所有国家的应用市场发布，但并没有实际意义上的推广，我不去推广不会有人从数以百万的供过于求的软件市场里找到我做的这个的，如何对海外市场做推广: 第一站：&lt;a href=\&#34;www.producthunt.com/\&#34;&gt;Product Hunt&lt;/a&gt;。这是一个在海外流量比较大的专门用于推荐软件的网站，产品在 &lt;a href=\&#34;www.producthunt.com/\&#34;&gt;Product Hunt&lt;/a&gt; 上发布几乎这是出海必须要做的事。&lt;/p&gt;\n&lt;h3 id=\&#34;island-widgets-在-product-hunt\&#34;&gt;&lt;a href=\&#34;https://www.producthunt.com/products/island-widgets-screen-widgets\&#34;&gt;Island Widgets 在 Product Hunt&lt;/a&gt;&lt;/h3&gt;\n&lt;p&gt;听 &lt;a href=\&#34;https://www.xiaoyuzhoufm.com/episode/64c729f0b3f6c440a87691ad\&#34;&gt;出海去的播客 - Zeabur创始人聊Product Hunt榜一冲榜经验&lt;/a&gt; 和之前了解的，Product Hunt 需要提前准备，还要预热，我比较随性，没准备，直接就发布了，用的应用市场的截图。发布后在3个程序员的微信群里推荐了下，不能干巴巴拉票，我把上个月的收入都用来发了红包。程序员圈子还是比较友好的，很多陌生的朋友都投票表示了支持，甚至有很多几千粉丝的大V都帮我在 Twitter 上转发帮我拉票，感动...&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574709.17032119628852.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574733.17032120304887.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574749.17032120746956.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;出海成绩\&#34;&gt;出海成绩&lt;/h3&gt;\n&lt;p&gt;尽人事，听天命。虽说没有被 Featured (即Product Hunt官方推荐，首页没有我的产品)，但是也收获了 63 个 Upvoted （投票），比我预期的多了六十来个吧。如果想做的更好，需要提前成为 Product Hunt 的用户，勤评论、多给别人投票，像我，一个新用户，权重就很低。&lt;/p&gt;\n&lt;h3 id=\&#34;除此之外\&#34;&gt;除此之外&lt;/h3&gt;\n&lt;p&gt;在 &lt;a href=\&#34;https://www.reddit.com/\&#34;&gt;reddit&lt;/a&gt; 开始用英文版介绍软件的使用场景，虽说被删帖了，但是还是要勇于尝试。创业维艰，砥砺前行。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.22.17032136574763.17032131511178.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-22chu-hai-qu&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记22出海去\&#34;&gt;程序员自由创业周记#22：出海去&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/240561/pexels-photo-240561.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;出海初体验\&#34;&gt;出海初体验&lt;/h3&gt;\n&lt;p&gt;工具类软件的特性是不用局限于某一个行业、也不用局限于某一个国家，所以出海是必须的选项，对于程序员而言，没有什么比做的软件有更多人用更令人兴奋；不熟悉互联网行业的人可能不了解什么是出海，不是出海打渔，是把软件推向海外市场，简称出海。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#22：出海去&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-12-22 12:03:49&#34;,&#34;dateFormat&#34;:&#34;2023-12-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-22chu-hai-qu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:118000,&#34;words&#34;:569,&#34;minutes&#34;:2},&#34;description&#34;:&#34;程序员自由创业周记#22：出海去\n\n出海初体验\n工具类软件的特性是不用局限于某一个行业、也不用局限于某一个国家，所以出海是必须的选项，对于程序员而言，没有什么比做的软件有更多人用更令人兴奋；不熟悉互联网行业的人可能不了解什么是出海，不是出海...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B022%E5%87%BA%E6%B5%B7%E5%8E%BB\&#34;&gt;程序员自由创业周记#22：出海去&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BA%E6%B5%B7%E5%88%9D%E4%BD%93%E9%AA%8C\&#34;&gt;出海初体验&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#island-widgets-%E5%9C%A8-product-hunt\&#34;&gt;Island Widgets 在 Product Hunt&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BA%E6%B5%B7%E6%88%90%E7%BB%A9\&#34;&gt;出海成绩&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%A4%E6%AD%A4%E4%B9%8B%E5%A4%96\&#34;&gt;除此之外&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记21大v的预测\&#34;&gt;程序员自由创业周记#21：大V的预测&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/18355088/pexels-photo-18355088.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;社媒\&#34;&gt;社媒&lt;/h3&gt;\n&lt;p&gt;不得不说，程序员圈子真小，尤其是独立开发相关标签的，周天打开X，推荐的第一条贴子讲的是博主看了一个人的周记，对他的未来很悲观，仔细看了看内容，裁员、北京、小孩上幼儿园、媳妇上研究生、月支出15k，这不说的就是我嘛~ 确实，流水账般的周记不知不觉写了20篇了，等以后再回首这段经历，看这些文字应该就够了。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;看评论，有些人看到过我写的东西，大多数人是不看好的，有说赌博的、有说自不量力的、有说九死一生的... 居然还有说家里有矿的。哭笑不得。我不会去解释什么，他们说的都对，除了家里有矿，家里有三亩地倒是真的。为什么去创业而不去做风险更低的打工，主要原因是我不想打一辈子工，那可以边上班边搞啊，确实，我中间也有好多次想去投简历，但一想公众号里还有几百人等着看我更新，Island Widgets 还有那么多有意思的功能等着我去做，上班以后就没有这么多精力扑在产品上，现在这个行情还能找到工作吗，背那无聊的八股文时间打磨产品不好吗，然后我就把招聘软件关了。等明年再打开吧~&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.15.17026041104888.17025650708310.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;我不是特别擅长经营社交平台，Twitter 从16年注册也就才发了十几篇贴子，最近也是为了让别人知道Island Widgets开始发的多了起来，所以在推上看到有人讨论我确实很意外。另外对创业遇到的困难我之前就有很充分的预期，也已经做好了一年没有收入的准备，在下一次踏入职场之前，我必须得有一份自己的事业，即便他很小。&lt;/p&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;p&gt;这几天北京一直下雪，儿子学校停课，时间大多都在陪孩子，看电视、做饭、读单词、哄睡觉、玩车、捉迷藏、摆积木、收拾玩具、玩雪、打雪仗啥的。还有就是给App - Island Widgets 加组合功能，在一个岛上可以集成四个功能，比如灵动岛左侧显示照片，右侧显示网速，长按显示待办，锁屏显示步数。算是待办清单里一项比较实用的功能。&lt;/p&gt;\n&lt;h3 id=\&#34;启动页\&#34;&gt;启动页&lt;/h3&gt;\n&lt;p&gt;App迭代了8个版本，刚发现启动页还没有内容，打开直接进首页。因为软件启动太快，以至于很难发现启动页的存在。不过为了表明态度，我还是打算在启动页加一句产品slogan，目前在“做最好的灵动岛应用” 和 “让灵动岛更灵动”之间犹豫。前者是目标，后者是使命。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-21da-v-de-yu-ce&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记21大v的预测\&#34;&gt;程序员自由创业周记#21：大V的预测&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/18355088/pexels-photo-18355088.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;社媒\&#34;&gt;社媒&lt;/h3&gt;\n&lt;p&gt;不得不说，程序员圈子真小，尤其是独立开发相关标签的，周天打开X，推荐的第一条贴子讲的是博主看了一个人的周记，对他的未来很悲观，仔细看了看内容，裁员、北京、小孩上幼儿园、媳妇上研究生、月支出15k，这不说的就是我嘛~ 确实，流水账般的周记不知不觉写了20篇了，等以后再回首这段经历，看这些文字应该就够了。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#21：大V的预测&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-12-15 10:05:24&#34;,&#34;dateFormat&#34;:&#34;2023-12-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-21da-v-de-yu-ce/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:155000,&#34;words&#34;:763,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#21：大V的预测\n\n社媒\n不得不说，程序员圈子真小，尤其是独立开发相关标签的，周天打开X，推荐的第一条贴子讲的是博主看了一个人的周记，对他的未来很悲观，仔细看了看内容，裁员、北京、小孩上幼儿园、媳妇上研究生、月支出15k...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B021%E5%A4%A7v%E7%9A%84%E9%A2%84%E6%B5%8B\&#34;&gt;程序员自由创业周记#21：大V的预测&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BE%E5%AA%92\&#34;&gt;社媒&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8%E9%A1%B5\&#34;&gt;启动页&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记20需求从何而来\&#34;&gt;程序员自由创业周记#20：需求从何而来&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/461064/pexels-photo-461064.jpeg\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;之前看过我周记的朋友应该了解我从7月份开始独立创业以来，主要做了两个产品，一个是加一，一个是&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt; ，上班的时候工作内容是上级主管分配，自己只管完成工作；那创业的工作内容谁来安排呢，我又是什么契机做了这两款产品，产品的需求从何而来，在这篇周记里聊一下；&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h4 id=\&#34;加一\&#34;&gt;加一&lt;/h4&gt;\n&lt;p&gt;在今年6月份刚结束上份工作时纠结了很久是不是继续打工找个班上，最终经过2个星期的思想斗争决定听从内心为自己活一次，就决定创业了。创业内容也是我喜欢而且擅长的：做软件给自己也给别人用；&lt;/p&gt;\n&lt;p&gt;一个偶然的契机，在一个微信群里看到一条消息：一个独立开发小团队招合作伙伴；本着向人学习的态度发了自荐邮件希望加入，经过简短的面谈也达成了合作意向；至此，创业第一个项目就诞生了，需求也就是合作伙伴中的产品经理兼设计师出，我只需要负责开发；上线后的收益按比例分成。&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;这是一种程序员独立创业比较常见的方式，也就是与其他人合作。各司其职，发挥自己的优势；&lt;/em&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;island-widgets-灵动岛锁屏小组件\&#34;&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;&lt;/h4&gt;\n&lt;p&gt;经过一个多月的夜以继日的开发，加一如期上线，短暂调整后开启了第二个项目：灵动岛小组件，她的来源是我自身的需求，把我儿子或者媳妇的照片放在灵动岛，因为灵动岛特性，无论在使用任何app，都能看到；其次，最近一年开始逐渐注重work life balance (工作生活平衡)，工作并非生活的全部，所以我想做一个把下班倒计时放在灵动岛的功能，这样能提醒下我的朋友，该下班了，回家陪陪家人吧。后来，我喜欢打球，经常在下班后去球场打两小时篮球再回家，如果那天有风或者下雨，球就不能打了，那如果我把天气预报放在灵动岛上，不需要我一次次打开天气预报软件就知道现在的天气了，然后就有了天气预报功能；&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;这是另外一种程序员独立创业比较常见需求来源，自己需要。&lt;/em&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;迭代\&#34;&gt;迭代&lt;/h4&gt;\n&lt;p&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  最初的需求主要从我自身而来，然后无限延展；在把产品推向市场之后，很多用户表示了对这个产品的喜爱，然后也提了一些他们的需求；我在自己斟酌和调研之后，加到了产品中，比如：&lt;/p&gt;\n&lt;h5 id=\&#34;实时网速\&#34;&gt;实时网速&lt;/h5&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542952.17010709125127.jpg\&#34; alt=\&#34;网速\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;然后我在产品里加了实时网速&lt;br&gt;\n&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669229.17020049156145.jpg\&#34; alt=\&#34;Island Widgets 的网速\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h5 id=\&#34;运行内存-cpu-帧率\&#34;&gt;运行内存、CPU、帧率&lt;/h5&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882616.17013392031306.jpg\&#34; alt=\&#34;用户需求\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;然后我在产品里加了运行内存、CPU、帧率&lt;br&gt;\n&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669249.17020049918698.jpg\&#34; alt=\&#34;Island Widgets 的运行内存、CPU、帧率 \&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h5 id=\&#34;多语言配置\&#34;&gt;多语言配置&lt;/h5&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669261.17020050753328.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;然后我在App里语言可配置，另外适配了31种语言；&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669273.412F28AB-F343-4C94-8609-F2070346FC61_4_5005_c.jpeg\&#34; alt=\&#34;Island Widgets的语言配置\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h5 id=\&#34;standby-和-iwatch适配\&#34;&gt;StandBy 和 iWatch适配&lt;/h5&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669284.17020053306701.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;也加到了待办清单中，除此之外还有很多来自用户的需求：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.12.08.17020059669296.17020054166233.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;em&gt;这是另外一种程序员独立创业需求来源，用户需求。&lt;/em&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;11月收支\&#34;&gt;11月收支&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;支出：13345&lt;/li&gt;\n&lt;li&gt;收入：上班月收入的1.5%&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;加一的新需求已经有了，&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt; 用户的需求也会慢慢满足，每天半小时的英语得学，天气好的时候篮球也得打，有勒布朗的比赛也要看，周记也要写，宣传Island Widgets的抖音也得发...&lt;/p&gt;\n&lt;p&gt;每天都很忙碌😄&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-20xu-qiu-cong-he-er-lai&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记20需求从何而来\&#34;&gt;程序员自由创业周记#20：需求从何而来&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/461064/pexels-photo-461064.jpeg\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;之前看过我周记的朋友应该了解我从7月份开始独立创业以来，主要做了两个产品，一个是加一，一个是&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt; ，上班的时候工作内容是上级主管分配，自己只管完成工作；那创业的工作内容谁来安排呢，我又是什么契机做了这两款产品，产品的需求从何而来，在这篇周记里聊一下；&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#20：需求从何而来&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-12-15 10:04:46&#34;,&#34;dateFormat&#34;:&#34;2023-12-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-20xu-qiu-cong-he-er-lai/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:200000,&#34;words&#34;:979,&#34;minutes&#34;:4},&#34;description&#34;:&#34;程序员自由创业周记#20：需求从何而来\n\n之前看过我周记的朋友应该了解我从7月份开始独立创业以来，主要做了两个产品，一个是加一，一个是Island Widgets - 灵动岛+锁屏小组件 ，上班的时候工作内容是上级主管分配，自己只管完成工作...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B020%E9%9C%80%E6%B1%82%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5\&#34;&gt;程序员自由创业周记#20：需求从何而来&lt;/a&gt;&lt;br&gt;\n*&lt;br&gt;\n*&lt;br&gt;\n* &lt;a href=\&#34;#%E5%8A%A0%E4%B8%80\&#34;&gt;加一&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#island-widgets-%E7%81%B5%E5%8A%A8%E5%B2%9B%E9%94%81%E5%B1%8F%E5%B0%8F%E7%BB%84%E4%BB%B6\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#%E8%BF%AD%E4%BB%A3\&#34;&gt;迭代&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#%E5%AE%9E%E6%97%B6%E7%BD%91%E9%80%9F\&#34;&gt;实时网速&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98-cpu-%E5%B8%A7%E7%8E%87\&#34;&gt;运行内存、CPU、帧率&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE\&#34;&gt;多语言配置&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#standby-%E5%92%8C-iwatch%E9%80%82%E9%85%8D\&#34;&gt;StandBy 和 iWatch适配&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#11%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;11月收支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记19定价的学问\&#34;&gt;程序员自由创业周记#19：定价的学问&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1888026/pexels-photo-1888026.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;定价\&#34;&gt;定价&lt;/h3&gt;\n&lt;p&gt;在之前的周记里讲过，目前 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  的定价参照的是国外一款优秀的灵动岛软件价格的 1/10。而这个应用只有健康类目步数、热量、心率的6个组件，它的价格是148/每年，不能买断；&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882572.F976AF5B-E972-4D5B-A249-8D4298D5A701_4_5005_c.jpeg\&#34; alt=\&#34;健康类组件软件定价\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  除了健康类目的步数、跑步距离、体温、运动时间、心律、能量、骑行距离以外还有其他二十几种不同的小组件。倘若一直保持 12/每年，18买断的价格是有点低；看了下11月的销售数据，会员卖出去几十份，送出去十几份，扣除苹果税后收入大概是上班期间月收入的1%；如果收入一直这么少创业是不能持久的，不同于有资本助力的企业，不能一直为爱发电，&lt;/p&gt;\n&lt;p&gt;又下载了另外一款国内优秀的做实时网速的软件，看了下它的定价：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882591.77911E25-5B78-4038-9C58-06EE358FEB33_4_5005_c.jpeg\&#34; alt=\&#34;实时网速组件定价\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而这些软件都集成了广告，广告也会为开发者带来收入，我再次陷入了沉思。&lt;/p&gt;\n&lt;h3 id=\&#34;定价-2\&#34;&gt;定价&lt;/h3&gt;\n&lt;p&gt;定价是一门学问，只要软件是收费的就会有人不满意；&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882604.17013332323522.jpg\&#34; alt=\&#34;用户抱怨不是免费软件\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;定价太高用户就会望而却步，太低开发者也会入不敷出。如何保证这中间的平衡还需慢慢摸索。不过可以确定的是，随着功能的不断增多，用户体验的逐渐完善，&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  价格会相应的越来越高。&lt;/p&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;p&gt;这周北京有点冷，没去打球，就在家里专心满足用户的产品需求：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882616.17013392031306.jpg\&#34; alt=\&#34;用户需求\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;除了实时网速以外，增加了 CPU负载、RAM占用、屏幕帧率的实时显示；并进一步优化了耗电；比如把定位的精度调到最低、降低数据刷新频率、数据相同不渲染界面、App锁屏后停止更新等等；因为灵动岛的数据需要定时更新，频率太低会有用户反馈不及时、太高会增加一定的耗电；如何把握这其中的平衡也需慢慢摸索，目前处于一个我比较满意的节点。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.30.17013416882632.92F0096D-29BB-459B-8FFC-17DD92814BFE_1_201_a.jpeg\&#34; alt=\&#34;Island Widgets 新首页\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-19ding-jie-de-xue-wen&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记19定价的学问\&#34;&gt;程序员自由创业周记#19：定价的学问&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1888026/pexels-photo-1888026.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;定价\&#34;&gt;定价&lt;/h3&gt;\n&lt;p&gt;在之前的周记里讲过，目前 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛+锁屏小组件&lt;/a&gt;  的定价参照的是国外一款优秀的灵动岛软件价格的 1/10。而这个应用只有健康类目步数、热量、心率的6个组件，它的价格是148/每年，不能买断；&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#19：定价的学问&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-12-01 12:02:07&#34;,&#34;dateFormat&#34;:&#34;2023-12-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-19ding-jie-de-xue-wen/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:122000,&#34;words&#34;:597,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#19：定价的学问\n\n定价\n在之前的周记里讲过，目前 Island Widgets - 灵动岛+锁屏小组件  的定价参照的是国外一款优秀的灵动岛软件价格的 1/10。而这个应用只有健康类目步数、热量、心率的6个组件，它的价...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B019%E5%AE%9A%E4%BB%B7%E7%9A%84%E5%AD%A6%E9%97%AE\&#34;&gt;程序员自由创业周记#19：定价的学问&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%BB%B7\&#34;&gt;定价&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%BB%B7-2\&#34;&gt;定价&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记18iphone显示实时网速\&#34;&gt;程序员自由创业周记#18：iPhone显示实时网速&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/3422964/pexels-photo-3422964.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;用户反馈\&#34;&gt;用户反馈&lt;/h3&gt;\n&lt;p&gt;上周在经过一系列推广之后收到了许多正反馈，从一定程度上增强了我的创业决心，坚定的去做一些对用户有用的软件，其中最受用户期待的功能是：实时网速。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542903.17010705864743.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542925.17010706069630.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542939.17010707259991.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010719542952.17010709125127.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;不像Android系统，iOS系统本身不支持实时网速的显示，在灵动岛出现之前也没有体验更好的解决方案，如果能在灵动岛上显示当前手机的实时网速，会是个对用户比较友好也比较酷的功能，说干就干，在研究了大量资料把功能实现了出来，然后进行了一系列优化让其更省电。最后上线。最终手机显示的效果如：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010552141124.7502E698-73EC-466A-A17A-09F8D8C159B7_1_201_a.jpeg\&#34; alt=\&#34;请忽略壁纸上的美女，截图主要演示灵动岛网速的功能\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;另外，如果手机没有灵动岛，在锁屏界面也能显示当前的实时网速，见图：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.27.17010552141132.8A284B62-8219-40EF-9271-58323ED34D2B_1_201_a.jpeg\&#34; alt=\&#34;请忽略图中美女\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;不止网速\&#34;&gt;不止网速&lt;/h3&gt;\n&lt;p&gt;目前创业项目 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 在实时网速以外，还有 下班倒计时、手机拿起次数、步数、心率、热搜、待办、天气、抢票倒计时等一系列功能，还计划实现番茄钟、快捷启动、桌面小组件等功能，直到把这个软件做到我满意为止。&lt;/p&gt;\n&lt;h2 id=\&#34;怎么下载\&#34;&gt;怎么下载？&lt;/h2&gt;\n&lt;p&gt;iPhone 用户在AppStore 搜索：&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;或者浏览器直接输入：https://apps.apple.com/cn/app/id6464542768&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-18iphone-xian-shi-shi-shi-wang-su&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记18iphone显示实时网速\&#34;&gt;程序员自由创业周记#18：iPhone显示实时网速&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/3422964/pexels-photo-3422964.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;用户反馈\&#34;&gt;用户反馈&lt;/h3&gt;\n&lt;p&gt;上周在经过一系列推广之后收到了许多正反馈，从一定程度上增强了我的创业决心，坚定的去做一些对用户有用的软件，其中最受用户期待的功能是：实时网速。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#18：iPhone显示实时网速&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-12-01 12:01:19&#34;,&#34;dateFormat&#34;:&#34;2023-12-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-18iphone-xian-shi-shi-shi-wang-su/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:76000,&#34;words&#34;:367,&#34;minutes&#34;:2},&#34;description&#34;:&#34;程序员自由创业周记#18：iPhone显示实时网速\n\n用户反馈\n上周在经过一系列推广之后收到了许多正反馈，从一定程度上增强了我的创业决心，坚定的去做一些对用户有用的软件，其中最受用户期待的功能是：实时网速。\n\n\n\n\n\n不像Android系统...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B018iphone%E6%98%BE%E7%A4%BA%E5%AE%9E%E6%97%B6%E7%BD%91%E9%80%9F\&#34;&gt;程序员自由创业周记#18：iPhone显示实时网速&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E6%88%B7%E5%8F%8D%E9%A6%88\&#34;&gt;用户反馈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E6%AD%A2%E7%BD%91%E9%80%9F\&#34;&gt;不止网速&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%8E%E4%B9%88%E4%B8%8B%E8%BD%BD\&#34;&gt;怎么下载？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8250916/pexels-photo-8250916.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;感谢\&#34;&gt;感谢&lt;/h3&gt;\n&lt;p&gt;认识我的人应该知道，现实生活中的我是一个比较有礼貌的人，即便是在今年6月从前公司HR手里接过《单方违法解除合同通知书》的时候我也是跟她说的是谢谢，并且进行了一番颇为友好的对话，感谢近三年来公司的培养。更不用说最近两天收到的很多陌生人各种对 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛&amp;amp;锁屏小组件&lt;/a&gt; 的赞美和认可了，我也只有说不完的感谢。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;推广\&#34;&gt;推广&lt;/h3&gt;\n&lt;p&gt;经过两个月的开发和完善，创业以来做的第2个软件：&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛&amp;amp;锁屏小组件&lt;/a&gt; 已经基本达到了进行推广的要求，程序员创业的大忌就是做的软件不进行推广，孤芳自赏，幻想着只通过自然流量爆火，也不是没有可能，但是很难。开发只是产品生命周期的第1步，后面还有9步要走。所以，在这周三，我开始了对&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛&amp;amp;锁屏小组件&lt;/a&gt;的“叫卖”，取得了&lt;br&gt;\n一定的效果：&lt;br&gt;\n&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491891.iShot_2023-11-17_09.53.11.png\&#34; alt=\&#34;11月15趋势\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;尝试了以下这些方案：&lt;/p&gt;\n&lt;h4 id=\&#34;1-在-v2ex-网站上抽奖送终生会员\&#34;&gt;1. 在 &lt;a href=\&#34;https://www.v2ex.com/t/992091\&#34;&gt;V2EX&lt;/a&gt; 网站上抽奖送终生会员&lt;/h4&gt;\n&lt;p&gt;不得不说，V站的用户是素质最高也是最热情的，截止目前有4447次访问，231次回复，其中绝大部分回复都对软件表示了浓厚的兴趣和赞美。截取部分用户的回复：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;198plus： 支持一下，感觉不错&lt;/li&gt;\n&lt;li&gt;zheermao: 看上去不错，支持&lt;/li&gt;\n&lt;li&gt;pinkayo: 造福了非灵动岛设备的使用者，真是太棒了。可以好好体验一下&lt;/li&gt;\n&lt;li&gt;gabkfivyfbst: 不错啊看着，比很多软件的灵动岛设计都实用&lt;/li&gt;\n&lt;li&gt;ychen997: 一直在看你的博客，来支持一下&lt;/li&gt;\n&lt;li&gt;lefer: 非灵动岛用户刚刚付费了终身&lt;/li&gt;\n&lt;li&gt;lma8：挺有意思&lt;/li&gt;\n&lt;li&gt;wuhan027：已下载安装体验，感谢作者开发这么实用的 app ！&lt;/li&gt;\n&lt;li&gt;laragh：v2 的开发老哥们都这么顶么？支持一下~&lt;/li&gt;\n&lt;li&gt;...&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;231 回复，无一 diss。感谢是说不完的，我能做的只有坚持创业，完善软件，对得起支持的朋友。 终生会员抽奖截止到今晚上8点，还有点时间，感兴趣的可以直接来这个链接：https://www.v2ex.com/t/992091  （打开这个链接需要一点点科技）&lt;/p&gt;\n&lt;h4 id=\&#34;2-在-小众软件-上发布产品介绍\&#34;&gt;2. 在 &lt;a href=\&#34;https://meta.appinn.net/t/topic/49268\&#34;&gt;小众软件&lt;/a&gt; 上发布产品介绍&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491908.17001883894040.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;3-给新趣集-投稿\&#34;&gt;3. 给&lt;a href=\&#34;https://xinquji.com/posts/806536\&#34;&gt;新趣集&lt;/a&gt; 投稿&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491917.17001884899855.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;4-在-chinese-independent-developer-新增产品\&#34;&gt;4. 在 &lt;a href=\&#34;https://github.com/1c7/chinese-independent-developer\&#34;&gt;chinese-independent-developer&lt;/a&gt; 新增产品&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.17.17001891491924.17001885718786.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;5-其他一些投稿目前还在审核\&#34;&gt;5. 其他一些投稿目前还在审核：&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;阮一峰周报&lt;/li&gt;\n&lt;li&gt;创造者日报&lt;/li&gt;\n&lt;li&gt;神器集&lt;/li&gt;\n&lt;li&gt;...&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;6-朋友圈和微信公众号发布产品介绍\&#34;&gt;6. 朋友圈和微信公众号发布产品介绍&lt;/h4&gt;\n&lt;h3 id=\&#34;回归开发\&#34;&gt;回归开发&lt;/h3&gt;\n&lt;p&gt;推广固然重要，一些用户反馈的希望有的新功能比如 实时网速、自定义背景、抢票定时器浮窗等 的开发需要沉下心来慢慢做，有时候慢就是快。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-17shuo-bu-wan-de-gan-xie&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8250916/pexels-photo-8250916.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;感谢\&#34;&gt;感谢&lt;/h3&gt;\n&lt;p&gt;认识我的人应该知道，现实生活中的我是一个比较有礼貌的人，即便是在今年6月从前公司HR手里接过《单方违法解除合同通知书》的时候我也是跟她说的是谢谢，并且进行了一番颇为友好的对话，感谢近三年来公司的培养。更不用说最近两天收到的很多陌生人各种对 &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets - 灵动岛&amp;amp;锁屏小组件&lt;/a&gt; 的赞美和认可了，我也只有说不完的感谢。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#17：说不完的感谢&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-11-17 10:51:23&#34;,&#34;dateFormat&#34;:&#34;2023-11-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-17shuo-bu-wan-de-gan-xie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:156000,&#34;words&#34;:740,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n感谢\n认识我的人应该知道，现实生活中的我是一个比较有礼貌的人，即便是在今年6月从前公司HR手里接过《单方违法解除合同通知书》的时候我也是跟她说的是谢谢，并且进行了一番颇为友好的对话，感谢近三年来公司的培养。更不用说最近两天收到的很多陌生人...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%84%9F%E8%B0%A2\&#34;&gt;感谢&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A8%E5%B9%BF\&#34;&gt;推广&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%9C%A8-v2ex-%E7%BD%91%E7%AB%99%E4%B8%8A%E6%8A%BD%E5%A5%96%E9%80%81%E7%BB%88%E7%94%9F%E4%BC%9A%E5%91%98\&#34;&gt;1. 在 V2EX 网站上抽奖送终生会员&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%9C%A8-%E5%B0%8F%E4%BC%97%E8%BD%AF%E4%BB%B6-%E4%B8%8A%E5%8F%91%E5%B8%83%E4%BA%A7%E5%93%81%E4%BB%8B%E7%BB%8D\&#34;&gt;2. 在 小众软件 上发布产品介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E7%BB%99%E6%96%B0%E8%B6%A3%E9%9B%86-%E6%8A%95%E7%A8%BF\&#34;&gt;3. 给新趣集 投稿&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E5%9C%A8-chinese-independent-developer-%E6%96%B0%E5%A2%9E%E4%BA%A7%E5%93%81\&#34;&gt;4. 在 chinese-independent-developer 新增产品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%8A%95%E7%A8%BF%E7%9B%AE%E5%89%8D%E8%BF%98%E5%9C%A8%E5%AE%A1%E6%A0%B8\&#34;&gt;5. 其他一些投稿目前还在审核：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%8F%91%E5%B8%83%E4%BA%A7%E5%93%81%E4%BB%8B%E7%BB%8D\&#34;&gt;6. 朋友圈和微信公众号发布产品介绍&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9E%E5%BD%92%E5%BC%80%E5%8F%91\&#34;&gt;回归开发&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;岛屿之梦发现灵动生活island-widgets-带你迈向全新体验\&#34;&gt;岛屿之梦，发现灵动生活——『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』带你迈向全新体验！&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584262.B429ED3D-3C6E-4F31-97CF-3C273CB04FB5_1_201_a.jpeg\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;在繁忙的现代生活中，我们时常渴望能够拥有一份轻松自在的生活方式。现在，『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』应用隆重登场，为你的iOS设备带来一场全新的使用体验，让你置身于一个灵动的岛屿世界中。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;无需打开任何其他应用，只需一瞥你的手机屏幕，你将发现一个全新的世界。让我们一起看看『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』带给你的七项魔力：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;首先，你的手机使用习惯一目了然。每天我们拿起手机的次数不计其数，但你是否真正了解自己的使用习惯呢？『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』的小组件会记录你拿起手机的次数，帮助你更好地认识自己，从而更好地管理时间。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584271.05A0574E-1735-4CA8-BA7C-A81CF1B393E9_4_5005_c.jpeg\&#34; alt=\&#34;手机拿起次数-展开\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686435.C6A16C61-953A-4B29-B628-306699459446_1_201_a.jpeg\&#34; alt=\&#34;手机拿起次数-倒计时\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;其次，健康数据一览。在健康意识的日益增强下，对自身健康的关注变得越来越重要。『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』实时监测步数、跑步距离、心率、体温等健康数据，让你时刻关注自身健康状况，更好地调整自己的生活方式。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584278.ADDB7D80-8226-4913-A8A0-606B44728C3F_4_5005_c.jpeg\&#34; alt=\&#34;步数心率-展开\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686447.5513EB01-C995-4C5F-8251-1D8C4BA8DBDC_1_201_a.jpeg\&#34; alt=\&#34;步数心率-倒计时\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;放下繁忙的工作，享受休闲时光，这是多么让人向往的事情。『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』帮你实现这个愿望，通过设置下班时间，应用会精确倒计时，帮助你规划工作日，确保你能按时离开工作岗位，享受属于自己的休闲时光。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584284.4D752933-9CBE-4727-A3CF-75428A9C397F_4_5005_c.jpeg\&#34; alt=\&#34;下班倒计时-展开\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686456.E8AA8B3B-A112-4BDB-B0BD-1BBB203C4865_4_5005_c.jpeg\&#34; alt=\&#34;下班倒计时-倒计时\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;而对于那些特殊的时刻，『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』也不会让你错过。你可以轻松跟踪并倒计时到各种重要时刻，如Deadline、纪念日等。无论是工作还是生活，你都能时刻掌握时间，不再错过任何重要时刻。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584290.CEED6C59-DE3B-4768-ADF0-E8130898A709_4_5005_c.jpeg\&#34; alt=\&#34;自定义倒计时-展开\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686464.1E4196D8-503D-421D-B014-09FBE6F7BA10_1_201_a.jpeg\&#34; alt=\&#34;自定义倒计时-灵动岛\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;除此之外，『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』还为你提供准确的天气预报，帮助你合理安排活动计划。无论是出门旅行还是日常出行，你都能轻松了解当地的天气情况，做出最佳决策。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584301.6F078C50-42D0-4B3B-B8FD-62F705386905_4_5005_c.jpeg\&#34; alt=\&#34;天气预报-展开\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686472.66F9F6C9-CF5E-4029-A23F-1472A873D88E_1_201_a.jpeg\&#34; alt=\&#34;天气-灵动岛\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过热搜功能，『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』让你随时浏览社交媒体上的热门话题和趋势，保持与时事新闻和社交动态的紧密联系。无论你是时事追随者还是社交达人，『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』都能让你第一时间了解到最新的动态。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584315.3DE6C703-1505-49C8-BB29-1AA6871A0BC9_4_5005_c.jpeg\&#34; alt=\&#34;热搜-展开\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;13\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686480.12D8375A-697F-4FDA-ABFD-C38CBC62F906_1_201_a.jpeg\&#34; alt=\&#34;热搜-灵动岛\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;最后，别忘了待办事项。『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』将你的待办事项放在随处可见的地方，让你时刻保持清晰的工作计划，不再遗漏重要任务。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;14\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584325.28062FEB-C924-4128-9DDA-897F14D7E8A7_4_5005_c.jpeg\&#34; alt=\&#34;待办-展开\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;15\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000248686488.F697C6FD-FBDE-4B33-8A31-72D1860C8449_1_201_a.jpeg\&#34; alt=\&#34;待办-灵动岛\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;我们不仅为你提供以上丰富的功能，还在不断努力开发新功能，以进一步满足你的不同需求。即将推出的更新将为你带来更多强大的工具，让你的使用体验更加丰富多彩。&lt;/p&gt;\n&lt;p&gt;岛屿之梦，就在你的指尖。立即下载『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』，让这个精彩应用为你的iOS设备注入全新活力！从此，发现灵动生活，体验不一样的惊喜！&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;dao-yu-zhi-meng-fa-xian-ling-dong-sheng-huo-island-widgets-dai-ni-mai-xiang-quan-xin-ti-yan&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;岛屿之梦发现灵动生活island-widgets-带你迈向全新体验\&#34;&gt;岛屿之梦，发现灵动生活——『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』带你迈向全新体验！&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.15.17000229584262.B429ED3D-3C6E-4F31-97CF-3C273CB04FB5_1_201_a.jpeg\&#34; alt=\&#34;封面\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;在繁忙的现代生活中，我们时常渴望能够拥有一份轻松自在的生活方式。现在，『&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 』应用隆重登场，为你的iOS设备带来一场全新的使用体验，让你置身于一个灵动的岛屿世界中。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;岛屿之梦，发现灵动生活——『Island Widgets 』带你迈向全新体验！&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;作品&#34;,&#34;slug&#34;:&#34;h-bEXLFyD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/h-bEXLFyD/&#34;}],&#34;date&#34;:&#34;2023-11-15 12:36:49&#34;,&#34;dateFormat&#34;:&#34;2023-11-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/dao-yu-zhi-meng-fa-xian-ling-dong-sheng-huo-island-widgets-dai-ni-mai-xiang-quan-xin-ti-yan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:156000,&#34;words&#34;:760,&#34;minutes&#34;:3},&#34;description&#34;:&#34;岛屿之梦，发现灵动生活——『Island Widgets 』带你迈向全新体验！\n\n在繁忙的现代生活中，我们时常渴望能够拥有一份轻松自在的生活方式。现在，『Island Widgets 』应用隆重登场，为你的iOS设备带来一场全新的使用体验，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B2%9B%E5%B1%BF%E4%B9%8B%E6%A2%A6%E5%8F%91%E7%8E%B0%E7%81%B5%E5%8A%A8%E7%94%9F%E6%B4%BBisland-widgets-%E5%B8%A6%E4%BD%A0%E8%BF%88%E5%90%91%E5%85%A8%E6%96%B0%E4%BD%93%E9%AA%8C\&#34;&gt;岛屿之梦，发现灵动生活——『Island Widgets 』带你迈向全新体验！&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记16备案和十月收支\&#34;&gt;程序员自由创业周记#16：备案和十月收支&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8850709/pexels-photo-8850709.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;政策\&#34;&gt;政策&lt;/h3&gt;\n&lt;p&gt;众所周知，从今年9月26日开始，新App必须在工信部备案获得备案号才能在Apple Store上架，之前上架的App需要在24年3月31之前完成备案。消息一出，国内独立开发者纷纷嚷着要出海，各种抵制，我觉得这是大可不必的。即便不需要备案，做的软件也要出海，而不是因为需要备案才要出海；另外我觉得国家自有他的考虑，备案之后的App如果出问题定位到发布者的成本便会大大降低，试想，明年3月以后，应用商店里披着正常软件外壳的违法应用会变多还得变少呢。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;尝试\&#34;&gt;尝试&lt;/h3&gt;\n&lt;p&gt;创业以后已经做了两个小而美的软件：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt; ：习惯养成打卡，追踪生活小事，记录日常情绪，计数、统计&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; ：灵动岛/锁屏小组件，囊括下班倒计时、手机拿起次数、步数、热搜等&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;准备再做第三个： 小憩 - 电脑用久了提醒你休息下眼睛的Mac工具。&lt;/p&gt;\n&lt;p&gt;因为是新App，因为之前看其他人的博客讲备案需要二十多天，那我得先去备案，拿到备案号才能上架。真正去尝试了发现并没有网上说的那么繁琐，甚至我只用了半个小时就完成了备案提交，而且再第二天就备案通过拿到了备案号。并没有网上传言的那么麻烦。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.10.16995817507586.beian-2023.11.08.png\&#34; alt=\&#34;beian-2023.11.08\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;之所以这么快主要原因是我之前备案过域名，在原本的备案主体新增App就好了。如果之前没有备案过域名，耗时肯定会长一些。另外，备案需要的材料比如：App Logo（用的之前做的学伟扫描的Logo），备案服务码（新买了一个ECS实例），域名（用的个人技术博客 https://qiuxuewei.com/ ）都是现成的。&lt;/p&gt;\n&lt;h3 id=\&#34;10月收支\&#34;&gt;10月收支&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;支出：15035.76&lt;/li&gt;\n&lt;li&gt;收入：0&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;创业4个月过去了，还是没有收入，一直这么下去肯定是不行的， &lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; ：灵动岛/锁屏小组件，囊括下班倒计时、手机拿起次数、步数、热搜等. 已经完善的差不多了，下周开始就要尝试下推广，找到潜在愿意为之付费的用户，我会在接下来的周记里记录我所尝试的推广手段和所获得反馈。值得一提的是在前天纯自然流量的基础上，有一位用户购买了&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 的终身会员，它所给我带来的开心和认同感比上班的时候发了工资还要强得多的多。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.10.16995817507606.423DD333-8CC1-4DDF-9855-DBD2ECFFC1BF_1_201_a.jpeg\&#34; alt=\&#34;423DD333-8CC1-4DDF-9855-DBD2ECFFC1BF_1_201_a\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-16bei-an-he-shi-yue-shou-zhi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记16备案和十月收支\&#34;&gt;程序员自由创业周记#16：备案和十月收支&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/8850709/pexels-photo-8850709.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;政策\&#34;&gt;政策&lt;/h3&gt;\n&lt;p&gt;众所周知，从今年9月26日开始，新App必须在工信部备案获得备案号才能在Apple Store上架，之前上架的App需要在24年3月31之前完成备案。消息一出，国内独立开发者纷纷嚷着要出海，各种抵制，我觉得这是大可不必的。即便不需要备案，做的软件也要出海，而不是因为需要备案才要出海；另外我觉得国家自有他的考虑，备案之后的App如果出问题定位到发布者的成本便会大大降低，试想，明年3月以后，应用商店里披着正常软件外壳的违法应用会变多还得变少呢。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#16：备案和十月收支&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-11-10 10:13:43&#34;,&#34;dateFormat&#34;:&#34;2023-11-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-16bei-an-he-shi-yue-shou-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:147000,&#34;words&#34;:711,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#16：备案和十月收支\n\n政策\n众所周知，从今年9月26日开始，新App必须在工信部备案获得备案号才能在Apple Store上架，之前上架的App需要在24年3月31之前完成备案。消息一出，国内独立开发者纷纷嚷着要出海，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B016%E5%A4%87%E6%A1%88%E5%92%8C%E5%8D%81%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;程序员自由创业周记#16：备案和十月收支&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%BF%E7%AD%96\&#34;&gt;政策&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%9D%E8%AF%95\&#34;&gt;尝试&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#10%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;10月收支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记15微信被封\&#34;&gt;程序员自由创业周记#15：微信被封&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/7827745/pexels-photo-7827745.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;二维码不能乱发\&#34;&gt;二维码不能乱发&lt;/h3&gt;\n&lt;p&gt;周日收到微信官方的一条消息：&lt;br&gt;\n“该账号因被投诉组织、参与或邀请他人加入发布色情/低俗营销/虚假欺诈等违规内容的群聊，对他人造成严重骚扰。当前无法使用添加朋友。2023-11-05 10:02后可申请解除限制。”&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;上周组建了一个学英语的微信群，把进群的二维码发了出来，起初是打算营造一个争先恐后学英语的氛围，初心是美好的，现实是残酷的，这个二维码导致了我建的群以及我的微信号都被封，部分功能限制使用一个月。原因是经常有人进群发几条广告就退，而且举报这个人也没用，会有不同的人进群发广告，这极大违背了我建群的初衷，因为被封的理由太莫名其妙，申诉后我的微信也恢复了正常功能，这也提醒下各位，无限制进群的二维码谨慎使用，最好是先加自己好友，甄别后再拉。否则会被别人利用。&lt;/p&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;p&gt;这周依旧在完善我的 Island Widgets (灵动岛&amp;amp;锁屏小组件) 这款产品，增加了健康类的组件，在灵动岛和锁屏页面现在当前的步数、心率等。这对于关注健康的用户是个福音，Island Widgets 灵动岛和锁屏上的小组件意味着你无需打开任何App（或者在任何App内）即可了解这些信息。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.11.05.16991950546455.E8D04714-02F7-4CE2-873B-39F3C93C237A_1_101_o.jpeg\&#34; alt=\&#34;E8D04714-02F7-4CE2-873B-39F3C93C237A_1_101_o\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;新赛季\&#34;&gt;新赛季&lt;/h3&gt;\n&lt;p&gt;随着NBA新赛季烈火重燃，已经许久没打球的我这周不是在看家看NBA比赛就是在球场打球，说服自己的理由是创业不能时刻紧绷，要适当放松自己。周末一般球场人满为患，现在可以挑风和日丽的时候去，一般下午2点去球场，玩到4点半出出汗去接小朋友放学。上午如果有湖人比赛的话会看一看，第一件球衣就是詹姆斯的骑士23号，也就一直看他所在球队的比赛，他的自律也在一定程度上影响着我。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-15wei-xin-bei-feng&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记15微信被封\&#34;&gt;程序员自由创业周记#15：微信被封&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/7827745/pexels-photo-7827745.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;二维码不能乱发\&#34;&gt;二维码不能乱发&lt;/h3&gt;\n&lt;p&gt;周日收到微信官方的一条消息：&lt;br&gt;\n“该账号因被投诉组织、参与或邀请他人加入发布色情/低俗营销/虚假欺诈等违规内容的群聊，对他人造成严重骚扰。当前无法使用添加朋友。2023-11-05 10:02后可申请解除限制。”&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#15：微信被封&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-11-05 22:44:21&#34;,&#34;dateFormat&#34;:&#34;2023-11-05&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-15wei-xin-bei-feng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:120000,&#34;words&#34;:588,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#15：微信被封\n\n二维码不能乱发\n周日收到微信官方的一条消息：\n“该账号因被投诉组织、参与或邀请他人加入发布色情/低俗营销/虚假欺诈等违规内容的群聊，对他人造成严重骚扰。当前无法使用添加朋友。2023-11-05 10:...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B015%E5%BE%AE%E4%BF%A1%E8%A2%AB%E5%B0%81\&#34;&gt;程序员自由创业周记#15：微信被封&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%B8%8D%E8%83%BD%E4%B9%B1%E5%8F%91\&#34;&gt;二维码不能乱发&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E8%B5%9B%E5%AD%A3\&#34;&gt;新赛季&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/301920/pexels-photo-301920.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;持续学习的职业\&#34;&gt;持续学习的职业&lt;/h3&gt;\n&lt;p&gt;众所周知，软件工程师是一类需要持续学习的职业，不单单是每年层出不穷的新技术需要掌握，过去落下的计算机基础知识也需要不断精进，否则，在这个竞争日益加剧的当下，很容易被后浪拍在沙滩上。过去移动互联网辉煌的10年逐渐趋于平凡，社交媒体上越来越多的程序员转行的消息不绝于耳，上周看到一名iOS程序员转行做水电工的消息，大为震撼。还记得15年移动互联网刚起步的时候，遍地都是各种移动开发培训机构，各行各业的有志之士希望通过4个月轻松月薪过万，这也导致了后面中低端工程师的极速饱和。如今移动端开发工程师就业的难度已经变得极为艰难，尤其是原生应用开发。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;所以需要持续不断的学习，丰富自己的技术栈，成为那1%的精英。才能在激烈的买方市场中脱颖而出。&lt;/p&gt;\n&lt;p&gt;所以，即便我在创业做一些软件，也需要持续的学习，除了本行iOS相关技术以外，还计划学后端Java自己搭服务器，和前端自己写网站。另外，还有英语。&lt;/p&gt;\n&lt;h3 id=\&#34;每天打卡30分钟\&#34;&gt;每天打卡30分钟&lt;/h3&gt;\n&lt;p&gt;之前上班的时候曾经也持续学过一段时间，但是囿于工作较饱和，没有大声讲英语的场地和需要3小时路上通勤的缘故和自己找借口不学的种种原因并没有坚持下去。希望借这段自由的时光把英语口语和听力能力提上一个层次。把计划写在周记里也是希望有个外界的监督，Push自己，不要在家一有空就去球场打球🏀。我建一个英语学习的打卡群，如果有想一起学英语打卡的同学可以扫码进群或者加我微信（jikexuewei）邀请你。我们一起互相监督，共同进步，成为那个更好的自己。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/important/qrcode/english-group.JPG\&#34; alt=\&#34;英语学习打卡\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.27.16983702664473.16983680354581.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;本周软件进展\&#34;&gt;本周软件进展&lt;/h3&gt;\n&lt;h4 id=\&#34;island-widgets\&#34;&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; (灵动岛小组件)&lt;/h4&gt;\n&lt;p&gt;v1.0.2 通过了审核，加了内购的选项，国外一款仅支持健康类灵动岛主题的软件售价是148每年，我的定价策略是，第一版的价格是它的10分之一，等后续版本完善后再涨到与之类似的价格。现在提供的功能是把喜欢的照片、手机拿起次数、天气、下班倒计时、自定义倒计时和热搜这几类灵动岛组件的功能，后续会增加健康类，把跑步或者骑行过程的步数或里程呈现在灵动岛上。有希望体验或者支持博主的朋友可以AppStore搜索：&lt;a href=\&#34;https://apps.apple.com/cn/app/id6464542768\&#34;&gt;Island Widgets&lt;/a&gt; 或者网页直接输入：https://apps.apple.com/cn/app/id6464542768&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.27.16983702664493.16983688238176.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;加一\&#34;&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt;&lt;/h4&gt;\n&lt;p&gt;为 习惯养成打卡，追踪生活小事，记录日常情绪，计数、统计 的产品 &lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt;，增加了拖动排序和点击跳转的功能还有一些体验优化。&lt;/p&gt;\n&lt;h3 id=\&#34;焦虑\&#34;&gt;焦虑&lt;/h3&gt;\n&lt;p&gt;过去这周是创业以来焦虑情绪最严重的一段时间，一个月二百多的收入对于一个三口之家来说是远远不够的，多次想放弃创业找个班上，又多次说服自己，不能既想又想，既想有着稳定的收入又想搏一把青春无悔，哪有这种好事呢😂&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-14chi-xu-xue-xi&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/301920/pexels-photo-301920.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;持续学习的职业\&#34;&gt;持续学习的职业&lt;/h3&gt;\n&lt;p&gt;众所周知，软件工程师是一类需要持续学习的职业，不单单是每年层出不穷的新技术需要掌握，过去落下的计算机基础知识也需要不断精进，否则，在这个竞争日益加剧的当下，很容易被后浪拍在沙滩上。过去移动互联网辉煌的10年逐渐趋于平凡，社交媒体上越来越多的程序员转行的消息不绝于耳，上周看到一名iOS程序员转行做水电工的消息，大为震撼。还记得15年移动互联网刚起步的时候，遍地都是各种移动开发培训机构，各行各业的有志之士希望通过4个月轻松月薪过万，这也导致了后面中低端工程师的极速饱和。如今移动端开发工程师就业的难度已经变得极为艰难，尤其是原生应用开发。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#14：持续学习&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-10-27 09:49:04&#34;,&#34;dateFormat&#34;:&#34;2023-10-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-14chi-xu-xue-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:188000,&#34;words&#34;:920,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n持续学习的职业\n众所周知，软件工程师是一类需要持续学习的职业，不单单是每年层出不穷的新技术需要掌握，过去落下的计算机基础知识也需要不断精进，否则，在这个竞争日益加剧的当下，很容易被后浪拍在沙滩上。过去移动互联网辉煌的10年逐渐趋于平凡，社...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%81%8C%E4%B8%9A\&#34;&gt;持续学习的职业&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AF%8F%E5%A4%A9%E6%89%93%E5%8D%A130%E5%88%86%E9%92%9F\&#34;&gt;每天打卡30分钟&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BD%AF%E4%BB%B6%E8%BF%9B%E5%B1%95\&#34;&gt;本周软件进展&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#island-widgets\&#34;&gt;Island Widgets&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A0%E4%B8%80\&#34;&gt;加一&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%84%A6%E8%99%91\&#34;&gt;焦虑&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6289064/pexels-photo-6289064.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;国庆假期\&#34;&gt;国庆假期&lt;/h3&gt;\n&lt;p&gt;对于我而言是没有放假的概念的，可以说每天都是假期，但是孩子放假就不能做软件了，得陪着他，尤其他生了半个月的病，隔三差五就得去医院排两小时队看个医生，周记因此耽搁了两次。没有看到我的更新不代表我放弃了，只是没有腾出空。没想到的是居然会有网友关注我怎么停更了，实在抱歉🫡&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345322.16971660346018.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;9月收支\&#34;&gt;9月收支&lt;/h3&gt;\n&lt;p&gt;支出：10933.35；收入：287.51&lt;/p&gt;\n&lt;h3 id=\&#34;第一桶金\&#34;&gt;第一桶金&lt;/h3&gt;\n&lt;p&gt;距离7月7日决定开始创业已经三个月了，前两个月一直没有收入，这周刚收到了第一笔打款，金额 287.51 ，算是第一桶金吧。因为加一是与另外两位大佬合作的作品，所以是加一2.0上线两个月以来总收入的1/4。终于算是迈出了第一步，未来可期。试想，一个软件每个月收入1000，我如果做10个是不是就能覆盖支出了呢。&lt;/p&gt;\n&lt;h3 id=\&#34;本周进展\&#34;&gt;本周进展&lt;/h3&gt;\n&lt;h4 id=\&#34;island-widgets\&#34;&gt;Island Widgets&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;开发了自定义图片上岛功能，这样就能把我小儿子的照片一直放在灵动岛上了。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345333.16971713519140.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;开发了手机拿起次数上岛功能，每次拿起手机在灵动岛上提示你这是今天第几次拿起手机，提醒我放下手机，回到生活。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345341.16971714093498.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;开发了会员功能，有收入这个梦才能做的更久一些。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345348.16971714588231.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;加一\&#34;&gt;加一&lt;/h4&gt;\n&lt;p&gt;开发了桌面小组件，不用打开App也能记录&lt;br&gt;\n&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.10.13.16971722345357.16971719454545.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;同道中人\&#34;&gt;同道中人&lt;/h3&gt;\n&lt;p&gt;相信每个程序员心中都有一个做自己软件的梦想，不知道是不是受我启发，隔壁村发小也开始副业搞自己的小程序：文字控壁纸&lt;br&gt;\n一款壁纸类小程序，除了官方推荐外也可以自定义壁纸。&lt;/p&gt;\n&lt;p&gt;希望这段旅程能结实更多同道中人，创业路上才不会孤单。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-13di-yi-tong-jin&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6289064/pexels-photo-6289064.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;国庆假期\&#34;&gt;国庆假期&lt;/h3&gt;\n&lt;p&gt;对于我而言是没有放假的概念的，可以说每天都是假期，但是孩子放假就不能做软件了，得陪着他，尤其他生了半个月的病，隔三差五就得去医院排两小时队看个医生，周记因此耽搁了两次。没有看到我的更新不代表我放弃了，只是没有腾出空。没想到的是居然会有网友关注我怎么停更了，实在抱歉🫡&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#13：第一桶金&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-10-13 13:01:49&#34;,&#34;dateFormat&#34;:&#34;2023-10-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-13di-yi-tong-jin/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:105000,&#34;words&#34;:512,&#34;minutes&#34;:2},&#34;description&#34;:&#34;\n国庆假期\n对于我而言是没有放假的概念的，可以说每天都是假期，但是孩子放假就不能做软件了，得陪着他，尤其他生了半个月的病，隔三差五就得去医院排两小时队看个医生，周记因此耽搁了两次。没有看到我的更新不代表我放弃了，只是没有腾出空。没想到的是居...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%BD%E5%BA%86%E5%81%87%E6%9C%9F\&#34;&gt;国庆假期&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;9月收支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%B8%80%E6%A1%B6%E9%87%91\&#34;&gt;第一桶金&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E8%BF%9B%E5%B1%95\&#34;&gt;本周进展&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#island-widgets\&#34;&gt;Island Widgets&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A0%E4%B8%80\&#34;&gt;加一&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8C%E9%81%93%E4%B8%AD%E4%BA%BA\&#34;&gt;同道中人&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/9821386/pexels-photo-9821386.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;下载量涨了999\&#34;&gt;下载量涨了999%&lt;/h3&gt;\n&lt;p&gt;在此之前，我的Apple开发账号上只有一个产品-学伟扫描，因为没有推广，只靠自然流量，每天的下载量寥寥无几，这种稳定无人问津的状态断断续续保持了4年。&lt;br&gt;\n之前的周记里介绍了最近在做创业的第二个项目-学伟灵动大全，耗时半个月，解决了无数技术问题，因为之前没有学过 SwiftUI，连写一个图片控件也要问 ChatGPT，也因为之前没做过灵动岛相关的项目，看了大量的资料，也请教了在新浪负责微博小组件开发的好朋友小谢，他也倾囊相助帮我解决了好些技术难题，对于用SwiftUI开发一个灵动岛项目，我的起点可以说是低到尘埃里，这里也想借此鼓励下我的读者，我这么菜的都能把软件做出来，相信每个人都可以。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;本着软件开发不能闷着头做，需要边做边接受用户反馈改进产品的原则，上周上线了灵动岛项目的1.0 MVP版本，之所以称之为MVP，就是它目前的功能仅限于能用，功能也是最基本的灵动岛下班倒计时、纪念日倒计时、微博、抖音、百度热搜， 计划这个项目做半年，功能完善到我满意为止。&lt;/p&gt;\n&lt;p&gt;昨天看了下Apple Connect 统计后台，自然下载量居然涨了999%。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.22.16953469623339.IMG_1020.jpeg\&#34; alt=\&#34;IMG_1020\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;名字\&#34;&gt;名字&lt;/h3&gt;\n&lt;p&gt;之前周记里朋友建议我改个名，觉得 “学伟灵动大全” 这个名不太好听，我悉心听取了建议，起了个洋气的名字：Island Widgets。中文翻译过来是：岛屿小工具 的意思，他确实是个在岛屿上的一系列小工具。这样也省去了名字的国际化，国内版本和海外版本都叫这个名字，见名知意。Logo 和 UI 是我美丽的媳妇帮我设计的，主打一个简约、漂亮。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.22.16953469623353.IMG_1024.jpeg\&#34; alt=\&#34;IMG_1024\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;天气预报\&#34;&gt;天气预报&lt;/h3&gt;\n&lt;p&gt;既然是小工具合集，一个实时的天气预报必不可少，这是我第二次做天气预报相关主题的软件，第一个还是大学刚毕业的时候做的 OneSky ，那时候还是iPhone 5 的时代。做天气预报一是提供灵动岛实时天气的功能，二是开启后台定位的权限。如果没有需要定位的功能，Apple的审核员不会允许软件随随便便开启后台定位，这也是iOS系统体验相对比Android好一点点的其中一个原因。只要App被允许用户在后台能存活，Island Widgets 就可以实时更新灵动岛，比如每半个小时在用户灵动岛上更新下热搜的内容，比如每次解锁在灵动岛上告诉下用户这是第几次拿起手机，比如每隔5分钟在灵动岛上告诉下用户跑步跑了多长距离等等。&lt;/p&gt;\n&lt;h3 id=\&#34;欢迎体验\&#34;&gt;欢迎体验&lt;/h3&gt;\n&lt;p&gt;只要是iPhone用户，就可以体验，虽说 Island Widgets 主要是为灵动岛设计的，但是没有灵动岛的iPhone设备，可以在锁屏界面和通知界面看到，目前还没加付费功能，全免无广告。&lt;br&gt;\nAppStore 搜索：Island Widgets   或者浏览器输入：https://apps.apple.com/cn/app/id6464542768 。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.22.16953470221571.Group%252080.png\&#34; alt=\&#34;Group 80\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-12999&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/9821386/pexels-photo-9821386.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1600\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;下载量涨了999\&#34;&gt;下载量涨了999%&lt;/h3&gt;\n&lt;p&gt;在此之前，我的Apple开发账号上只有一个产品-学伟扫描，因为没有推广，只靠自然流量，每天的下载量寥寥无几，这种稳定无人问津的状态断断续续保持了4年。&lt;br&gt;\n之前的周记里介绍了最近在做创业的第二个项目-学伟灵动大全，耗时半个月，解决了无数技术问题，因为之前没有学过 SwiftUI，连写一个图片控件也要问 ChatGPT，也因为之前没做过灵动岛相关的项目，看了大量的资料，也请教了在新浪负责微博小组件开发的好朋友小谢，他也倾囊相助帮我解决了好些技术难题，对于用SwiftUI开发一个灵动岛项目，我的起点可以说是低到尘埃里，这里也想借此鼓励下我的读者，我这么菜的都能把软件做出来，相信每个人都可以。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#12：999%&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-09-22 09:53:57&#34;,&#34;dateFormat&#34;:&#34;2023-09-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-12999/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:181000,&#34;words&#34;:873,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n下载量涨了999%\n在此之前，我的Apple开发账号上只有一个产品-学伟扫描，因为没有推广，只靠自然流量，每天的下载量寥寥无几，这种稳定无人问津的状态断断续续保持了4年。\n之前的周记里介绍了最近在做创业的第二个项目-学伟灵动大全，耗时半个...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BD%BD%E9%87%8F%E6%B6%A8%E4%BA%86999\&#34;&gt;下载量涨了999%&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8D%E5%AD%97\&#34;&gt;名字&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5\&#34;&gt;天气预报&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AC%A2%E8%BF%8E%E4%BD%93%E9%AA%8C\&#34;&gt;欢迎体验&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.unsplash.com/photo-1553835973-dec43bfddbeb?ixlib=rb-4.0.3&amp;amp;ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGJyYW5kfGVufDB8MHwwfHx8MA%3D%3D&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=800&amp;amp;q=60\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;商标重要吗\&#34;&gt;商标重要吗&lt;/h3&gt;\n&lt;p&gt;为什么我那么重视App名字里要有一个自己的商标，主要防止的是被竞争对手抄袭，甚至连名字也起同样的，如果没有商标，很难维权，只能放任自由。在上上家公司，我们的产品起了一个与别人重复的名字，刚好那个名字别的公司有商标，又恰巧他们知道了我们的产品用了他们的名字，被投诉到Apple，我们的产品直接被下架和封号。后来我们给Apple发邮件也无济于事，这也直接导致了公司收入严重受挫，以致于整个iOS团队耗时小半年上架了它的马甲包应用，此后也是一蹶不振，后来结果就是App停服，最后直接导致了公司倒闭，团队解散。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;这也是为什么我执意把我做的一系列软件起名：学伟xx 的原因，我注册了“学伟”的9、38、42类软件产品相关类目的商标，如果万一哪天我的产品被人抄袭叫了同样的名字，也可以维权。但是这个名字作为人名还可以，作为软件的名字就很奇怪了。给人一种城乡结合部的感觉，尤其这个名字还没人听说的时候。对于软件的推广可能会起到副作用，所以在一番纠结以后，还是决定给软件改名，起一个人畜无害的名字，首先这个名字别人不会注册商标，不至于无意碰瓷到别人。&lt;/p&gt;\n&lt;p&gt;毕竟现在最重要的不是防竞争对手，而是增长和营收。&lt;/p&gt;\n&lt;h3 id=\&#34;微扫描\&#34;&gt;微扫描&lt;/h3&gt;\n&lt;p&gt;好的商标难注册，19年做的那个OCR软件最先的名字叫微扫描，后来注册“微扫描”的商标被驳回。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.15.16947290512794.16947027926134.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;退而求其次，干脆改名叫微扫吧，继续注册 “微扫” 的商标，又被驳回。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.15.16947290512811.16947028372601.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;名字注册不了，自己设计的logo注册下总行了吧，还是被驳回。。。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.15.16947290512822.16947028941120.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;几乎我能想到的好名字，基本已经被别人注册过了。而且我只有13个月做梦的时间，重新注册一个好听的商标显然也已经来不及了。所以在之前的周记中有很多人给我做了善意的提醒，大多数人的认知和经验都是比我强，别人的提醒肯定不无道理。&lt;/p&gt;\n&lt;h3 id=\&#34;改个名吧\&#34;&gt;改个名吧&lt;/h3&gt;\n&lt;p&gt;在“学伟” 跟“奔驰”、 “松下”、“丰田”、“希尔顿”、“腾讯”、“小鹏”、“王致和” 那些名字一样深入人心以前，我就先不用这个商标做创业期间做的一系列软件的名字了。&lt;br&gt;\n商标很重要，一个好听的商标更重要。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-11shang-biao&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.unsplash.com/photo-1553835973-dec43bfddbeb?ixlib=rb-4.0.3&amp;amp;ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGJyYW5kfGVufDB8MHwwfHx8MA%3D%3D&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=800&amp;amp;q=60\&#34; alt=\&#34;cover\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;商标重要吗\&#34;&gt;商标重要吗&lt;/h3&gt;\n&lt;p&gt;为什么我那么重视App名字里要有一个自己的商标，主要防止的是被竞争对手抄袭，甚至连名字也起同样的，如果没有商标，很难维权，只能放任自由。在上上家公司，我们的产品起了一个与别人重复的名字，刚好那个名字别的公司有商标，又恰巧他们知道了我们的产品用了他们的名字，被投诉到Apple，我们的产品直接被下架和封号。后来我们给Apple发邮件也无济于事，这也直接导致了公司收入严重受挫，以致于整个iOS团队耗时小半年上架了它的马甲包应用，此后也是一蹶不振，后来结果就是App停服，最后直接导致了公司倒闭，团队解散。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#11：商标&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-09-15 10:12:17&#34;,&#34;dateFormat&#34;:&#34;2023-09-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-11shang-biao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:145000,&#34;words&#34;:715,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n商标重要吗\n为什么我那么重视App名字里要有一个自己的商标，主要防止的是被竞争对手抄袭，甚至连名字也起同样的，如果没有商标，很难维权，只能放任自由。在上上家公司，我们的产品起了一个与别人重复的名字，刚好那个名字别的公司有商标，又恰巧他们知...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%95%86%E6%A0%87%E9%87%8D%E8%A6%81%E5%90%97\&#34;&gt;商标重要吗&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E6%89%AB%E6%8F%8F\&#34;&gt;微扫描&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%B9%E4%B8%AA%E5%90%8D%E5%90%A7\&#34;&gt;改个名吧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;8月收支\&#34;&gt;8月收支&lt;/h3&gt;\n&lt;h4 id=\&#34;支出1158532\&#34;&gt;支出：115853.2&lt;/h4&gt;\n&lt;h4 id=\&#34;收入0\&#34;&gt;收入：0&lt;/h4&gt;\n&lt;p&gt;8月给研究生媳妇交了第一年学费，是真的学费。不得不说，MBA学费真贵，尤其是北师大的MBA。不过媳妇喜欢学习，作为爱人必须无条件支持。而且是在家全职看孩子挤时间考上的，非常难能可贵。记得在刚毕业那会我也在继续读研和工作纠结过一段时间，读研学历提升好找工作；工作能更快接受企业历练；再做了一番思想斗争和学了一个月发现不是那块料后果断选择了工作。服务的公司的规模也从七八个人，到二三十人，后来一两百人，最后到四万多人，四家风格迥异的互联网公司，做的事一直没变，iOS开发。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;在公司上班就是这样，只需要做好自己的份内之事即可，也就是除了iOS其他的不需要我去关心，这也导致了我技术栈的单一。这也是职业规划不够明确的后果，如果当时就认定以后创业，就该除了iOS一外把Web和后端的技术学会，不至于现在没有收入的时候再重新开始学。虽然大学学的是计算机，但是那时候我并没有那个觉悟，学习也仅是在临近考试的时候抱抱佛脚。&lt;/p&gt;\n&lt;p&gt;如果能重来，大学我除了教室、图书馆和篮球场肯定哪也不去。诚然，人生不会重来。&lt;/p&gt;\n&lt;h3 id=\&#34;小众软件\&#34;&gt;小众软件&lt;/h3&gt;\n&lt;p&gt;新项目切入的点极小众，现在搜索应用市场做类似主题的几乎没有，我愿称之为新蓝海，只不过比较小众。为什么其他公司不做，是因为傻吗？还是因为用户太少不值得投入；我想是因为后者，在此之前，只有iPhone14 Pro 和 iPhone14 Pro Max的用户有灵动岛，专门为灵动岛开发应用软件不值当的，但是下周二发布的iPhone15将抛弃之前的刘海屏，全系列采用灵动岛设计。以后可以使用灵动岛的用户必然会越来越多，在更多竞争对手进场之前布局我猜能有一点机会吧，即便没成，也解决了我自身的需求，就是只要在使用手机，都能看到我的宝贝儿子，都能知道几点下班。&lt;/p&gt;\n&lt;h3 id=\&#34;学伟灵动大全\&#34;&gt;学伟灵动大全&lt;/h3&gt;\n&lt;h4 id=\&#34;在桌面\&#34;&gt;在桌面&lt;/h4&gt;\n&lt;p&gt;提示我现在是休息时间&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782556.437B46CB-5AD3-4C57-A4BA-6110CAF09E6F_4_5005_c.jpeg\&#34; alt=\&#34;437B46CB-5AD3-4C57-A4BA-6110CAF09E6F_4_5005_c\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;在刷抖音\&#34;&gt;在刷抖音&lt;/h4&gt;\n&lt;p&gt;小盆友默默地看着爸爸&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782578.island-dy-sy.jpg\&#34; alt=\&#34;island-dy-sy\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;在用微信\&#34;&gt;在用微信&lt;/h4&gt;\n&lt;p&gt;小盆友也在默默地看着爸爸&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782597.island-gzh-sy.jpg\&#34; alt=\&#34;island-gzh-sy\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;在锁屏\&#34;&gt;在锁屏&lt;/h4&gt;\n&lt;p&gt;还有多久下班甚至都不用算&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.09.08.16941416782614.IMG_0950.jpg\&#34; alt=\&#34;IMG_0950\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;计划下周上线\&#34;&gt;计划下周上线&lt;/h3&gt;\n&lt;p&gt;把想做的东西用技术实现出来，即方便自己，也有可能为别人带来一点用，并乐在其中还挺难得的。&lt;br&gt;\n用我的座右铭之一-巴菲特的一段话用作第10篇周记的结尾：&lt;br&gt;\n“你财富自由之后想做什么工作，现在就该做什么工作，这样的工作才是理想的工作。做这样的工作，你会很开心，能学到东西，能充满激情。每天会从床上跳起来，一天不工作都不行。”&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-10xiao-zhong-ruan-jian&#34;,&#34;abstract&#34;:&#34;&lt;h3 id=\&#34;8月收支\&#34;&gt;8月收支&lt;/h3&gt;\n&lt;h4 id=\&#34;支出1158532\&#34;&gt;支出：115853.2&lt;/h4&gt;\n&lt;h4 id=\&#34;收入0\&#34;&gt;收入：0&lt;/h4&gt;\n&lt;p&gt;8月给研究生媳妇交了第一年学费，是真的学费。不得不说，MBA学费真贵，尤其是北师大的MBA。不过媳妇喜欢学习，作为爱人必须无条件支持。而且是在家全职看孩子挤时间考上的，非常难能可贵。记得在刚毕业那会我也在继续读研和工作纠结过一段时间，读研学历提升好找工作；工作能更快接受企业历练；再做了一番思想斗争和学了一个月发现不是那块料后果断选择了工作。服务的公司的规模也从七八个人，到二三十人，后来一两百人，最后到四万多人，四家风格迥异的互联网公司，做的事一直没变，iOS开发。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#10：小众软件&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-09-08 10:56:38&#34;,&#34;dateFormat&#34;:&#34;2023-09-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-10xiao-zhong-ruan-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:171000,&#34;words&#34;:845,&#34;minutes&#34;:3},&#34;description&#34;:&#34;8月收支\n支出：115853.2\n收入：0\n8月给研究生媳妇交了第一年学费，是真的学费。不得不说，MBA学费真贵，尤其是北师大的MBA。不过媳妇喜欢学习，作为爱人必须无条件支持。而且是在家全职看孩子挤时间考上的，非常难能可贵。记得在刚毕业那...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#8%E6%9C%88%E6%94%B6%E6%94%AF\&#34;&gt;8月收支&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%AF%E5%87%BA1158532\&#34;&gt;支出：115853.2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%B6%E5%85%A50\&#34;&gt;收入：0&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%8F%E4%BC%97%E8%BD%AF%E4%BB%B6\&#34;&gt;小众软件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%A6%E4%BC%9F%E7%81%B5%E5%8A%A8%E5%A4%A7%E5%85%A8\&#34;&gt;学伟灵动大全&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E6%A1%8C%E9%9D%A2\&#34;&gt;在桌面&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E5%88%B7%E6%8A%96%E9%9F%B3\&#34;&gt;在刷抖音&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E7%94%A8%E5%BE%AE%E4%BF%A1\&#34;&gt;在用微信&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E9%94%81%E5%B1%8F\&#34;&gt;在锁屏&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%A1%E5%88%92%E4%B8%8B%E5%91%A8%E4%B8%8A%E7%BA%BF\&#34;&gt;计划下周上线&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1536428/pexels-photo-1536428.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;img\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;最开心的事\&#34;&gt;最开心的事&lt;/h3&gt;\n&lt;p&gt;人一天中最开心的时刻是什么时候？莫过于下班的时候；一天中最开心的事是什么？莫过于下班后干的任何事；&lt;br&gt;\n这么重要的时刻，能不能有一款产品只要手机在手就能知道还有多久下班，不论是手机在锁屏界面，还是在桌面，还是在聊微信，亦或是在刷抖音。&lt;br&gt;\n只要你在用手机，就能知道还有多久下班。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;最爱的人\&#34;&gt;最爱的人&lt;/h3&gt;\n&lt;p&gt;你最爱的人是谁？是偶尔吵架的爱人？是一年能见一两次的父母？是天天想粘着你的孩子？还是每年一有演唱会就必去的那个明星；&lt;br&gt;\n能不能有一款产品，只要在用手机，不用打开相册，就能看到你所爱的人照片，不论你是在用手机上的任何软件。&lt;/p&gt;\n&lt;h3 id=\&#34;学伟xx大全\&#34;&gt;学伟xx大全&lt;/h3&gt;\n&lt;p&gt;既然没有，那我就开发一个：把你最关心的放在手机时刻能看到的地方。&lt;br&gt;\n你最关心的可以有很多选择，可以是某一个时刻、某张照片、某句话、今天的天气、或者现在正在发生的事儿。&lt;br&gt;\n所以这是一个集合了：下班计时、纪念日、番茄钟、天气预报、微博热搜、TODO List等各种功能于一身的软件。&lt;br&gt;\n因为可以有很多选择，所以产品的名字就叫：学伟xx大全。&lt;br&gt;\n因为是你最关心的，所以只要你在用手机，就能看到。&lt;/p&gt;\n&lt;h3 id=\&#34;骑行\&#34;&gt;骑行&lt;/h3&gt;\n&lt;p&gt;这周三回了趟前公司，把停在车棚俩月的自行车从北五环骑了回来，30多公里，一个来小时。这辆自行车也朝夕相处陪伴了我一年多，每天陪着我上下班，现在他也已经完成他的使命了，该给他找一个新主人了。&lt;br&gt;\n现在回想，之前4年每天骑行40公里这段时间挺难能可贵的，骑行的时候戴着耳机听着书、播客或者音频课。既锻炼了身体又涨了见识。把这种百利而无一害的通勤方式推荐给所有人，只要单程20公里以内，完全可以选择骑自行车上下班。不过自行车肯定不能是共享单车，推荐公路车，我骑了两年山地，两年公路。各有千秋，挑自己喜欢的。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;往期文章\&#34;&gt;往期文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE1MzIwNg==&amp;amp;action=getalbum&amp;amp;album_id=3044710252514050050#wechat_redirect\&#34;&gt;创业周记合集&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-9zui-kai-xin-de-shi&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1536428/pexels-photo-1536428.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;img\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;最开心的事\&#34;&gt;最开心的事&lt;/h3&gt;\n&lt;p&gt;人一天中最开心的时刻是什么时候？莫过于下班的时候；一天中最开心的事是什么？莫过于下班后干的任何事；&lt;br&gt;\n这么重要的时刻，能不能有一款产品只要手机在手就能知道还有多久下班，不论是手机在锁屏界面，还是在桌面，还是在聊微信，亦或是在刷抖音。&lt;br&gt;\n只要你在用手机，就能知道还有多久下班。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#9：最开心的事&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-09-02 06:05:18&#34;,&#34;dateFormat&#34;:&#34;2023-09-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-9zui-kai-xin-de-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:125000,&#34;words&#34;:622,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n最开心的事\n人一天中最开心的时刻是什么时候？莫过于下班的时候；一天中最开心的事是什么？莫过于下班后干的任何事；\n这么重要的时刻，能不能有一款产品只要手机在手就能知道还有多久下班，不论是手机在锁屏界面，还是在桌面，还是在聊微信，亦或是在刷抖...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%80%E5%BC%80%E5%BF%83%E7%9A%84%E4%BA%8B\&#34;&gt;最开心的事&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%80%E7%88%B1%E7%9A%84%E4%BA%BA\&#34;&gt;最爱的人&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%A6%E4%BC%9Fxx%E5%A4%A7%E5%85%A8\&#34;&gt;学伟xx大全&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%AA%91%E8%A1%8C\&#34;&gt;骑行&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;往期文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1037992/pexels-photo-1037992.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1\&#34; alt=\&#34;img\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;软件的样子\&#34;&gt;软件的样子&lt;/h3&gt;\n&lt;p&gt;就像建造房子，工人施工需要照着图纸，没有图纸直接上手施工倒是也可以，只是房子的质量和样子都不敢恭维。程序员在一定意义上与建筑工人很像，只不过他们码砖，我们码码。软件开发之前也需要提前设计好界面，设计好交互。有了设计稿程序员也能更专注的实现功能，但是很少有程序员懂设计。那创业做软件设计怎么办？以我现有的认知介绍几种方式。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h4 id=\&#34;1-ai作图\&#34;&gt;1. AI作图&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.24.16928879183132.16928847361644.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;即把想实现的界面描述给AI，它能自动为你生成设计稿，不要苛求生成的设计稿有多惊艳，我试过，现阶段仅仅停留在能用，聊胜于无。&lt;/p&gt;\n&lt;h4 id=\&#34;2-与专业设计师合作\&#34;&gt;2. 与专业设计师合作&lt;/h4&gt;\n&lt;p&gt;合作的方式有两种：1是前期用爱发电，收益按比例分成。 2是直接以外包的形式给人固定收益；这取决于双方的性格和互相了解的程度，可以在论坛上发帖找设计师。我的第二个作品加一便是以第一种形式合作的，只不过是设计师找的我。设计稿和交互都做好了，”只差一个程序员“。&lt;/p&gt;\n&lt;h4 id=\&#34;3-雇佣一名远程设计师\&#34;&gt;3. 雇佣一名远程设计师&lt;/h4&gt;\n&lt;p&gt;在诸如一些设计外包外包平台上发布一个职位，可以短期雇佣一名专业设计师，给人发月薪，可半天工作或全天工作，设计师的工资以其经验的长短有所不同，月薪5k+ 最短可雇佣1个月，这更像是正式的创业，有前期资本的支持。&lt;/p&gt;\n&lt;h4 id=\&#34;4-淘宝找设计外包团队\&#34;&gt;4. 淘宝找设计外包团队&lt;/h4&gt;\n&lt;p&gt;众所周知，万物皆可淘。淘宝相对透明，服务好坏可以通过评价判断。&lt;/p&gt;\n&lt;h4 id=\&#34;5-自己学\&#34;&gt;5. 自己学&lt;/h4&gt;\n&lt;p&gt;小破站上找一套Figma或者Sketch教程，学完自己搞几个作品，自己动手丰衣足食。适合掌控欲强的程序员，做成啥样完全自己说了算，缺点就是慢。&lt;/p&gt;\n&lt;h4 id=\&#34;6-找一个设计师老婆女朋友\&#34;&gt;6. 找一个设计师老婆(女朋友)&lt;/h4&gt;\n&lt;p&gt;嘿嘿...&lt;/p&gt;\n&lt;h3 id=\&#34;新作品进展\&#34;&gt;新作品进展&lt;/h3&gt;\n&lt;p&gt;新作品有一个核心功能是天气预报，媳妇仅用了两天的时间，给我设计好了包括天气预报在内的5个页面，而且还有点好看。&lt;br&gt;\n&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.24.16928879183143.16928868265767.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;仲裁进展\&#34;&gt;仲裁进展&lt;/h3&gt;\n&lt;p&gt;这周二打了人生第一次官司，一个人面对公司两个律师和仲裁员书记员，没怯场。公司的裁员理由主要有几点：1.没按时交周报（实际按时交了）。2.不接领导电话（实际把电话接通的消息删了）。3.门禁时间不满9个小时（实际公司不需要打卡）。 4. 领导消息不回。（实际半夜11点我已经睡了）。理由在我看来比较苍白，而且我也有充分的证据一一驳斥。结果1-3个月后出，顺其自然。不希望这件事再占我时间，后续的流程我也会委托给专业的律师，让专业的人做专业的事。&lt;/p&gt;\n&lt;h3 id=\&#34;周更和往期文章\&#34;&gt;周更和往期文章&lt;/h3&gt;\n&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;\n&lt;p&gt;往期文章：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd\&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd\&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd\&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=653a502b51d5cd5fb9021eb1ce0c9179&amp;amp;chksm=fd9f624dcae8eb5bb19504f493a8c33b063a767626209a903ef3802f5a3a261946bbc4614b8e#rd\&#34;&gt;程序员自由创业周记#5：加一上线&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484272&amp;amp;idx=1&amp;amp;sn=45134c5275f280474641fa0340ccc3f0&amp;amp;chksm=fd9f6269cae8eb7f10164bac0a4bcdedad9cd24bcca723461223d4f3cf7e36e4b58b1deb991c#rd\&#34;&gt;程序员自由创业周记#6：劝退&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484306&amp;amp;idx=1&amp;amp;sn=a5e528f34e838e983c1ae59df656ce15&amp;amp;chksm=fd9f628bcae8eb9d5b93bdb468891b6dd4e53473ecc154f91a579d3c9283153c4b0dcd467e73#rd\&#34;&gt;程序员自由创业周记#7：仲裁&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-8zen-me-she-ji&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/1037992/pexels-photo-1037992.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=1\&#34; alt=\&#34;img\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;软件的样子\&#34;&gt;软件的样子&lt;/h3&gt;\n&lt;p&gt;就像建造房子，工人施工需要照着图纸，没有图纸直接上手施工倒是也可以，只是房子的质量和样子都不敢恭维。程序员在一定意义上与建筑工人很像，只不过他们码砖，我们码码。软件开发之前也需要提前设计好界面，设计好交互。有了设计稿程序员也能更专注的实现功能，但是很少有程序员懂设计。那创业做软件设计怎么办？以我现有的认知介绍几种方式。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#8：怎么设计&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-08-25 10:14:24&#34;,&#34;dateFormat&#34;:&#34;2023-08-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-8zen-me-she-ji/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:200000,&#34;words&#34;:976,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。\n软件的样子\n就像建造房子，工人施工需要照着图纸，没有图纸直接上手施工倒是也可以，只是房子的质量和样子都不敢恭维。程序员在一定意义上与建筑工人很像，只不过他们码...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%AD%90\&#34;&gt;软件的样子&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-ai%E4%BD%9C%E5%9B%BE\&#34;&gt;1. AI作图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%B8%8E%E4%B8%93%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%90%88%E4%BD%9C\&#34;&gt;2. 与专业设计师合作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E9%9B%87%E4%BD%A3%E4%B8%80%E5%90%8D%E8%BF%9C%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%B8%88\&#34;&gt;3. 雇佣一名远程设计师&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E6%B7%98%E5%AE%9D%E6%89%BE%E8%AE%BE%E8%AE%A1%E5%A4%96%E5%8C%85%E5%9B%A2%E9%98%9F\&#34;&gt;4. 淘宝找设计外包团队&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E8%87%AA%E5%B7%B1%E5%AD%A6\&#34;&gt;5. 自己学&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E6%89%BE%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%81%E5%A9%86%E5%A5%B3%E6%9C%8B%E5%8F%8B\&#34;&gt;6. 找一个设计师老婆(女朋友)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E4%BD%9C%E5%93%81%E8%BF%9B%E5%B1%95\&#34;&gt;新作品进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%B2%E8%A3%81%E8%BF%9B%E5%B1%95\&#34;&gt;仲裁进展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4%E5%92%8C%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;周更和往期文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6077326/pexels-photo-6077326.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;law\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;没想到\&#34;&gt;没想到&lt;/h3&gt;\n&lt;p&gt;没想到写的周记会有这么多人看，还能收到这么多陌生(或熟悉)朋友的真诚建议、鼓励、甚至是打赏，几乎所有的评论和私信我都认真的回复了，本想的是通过网友和朋友的监督坚定我创业的信念，有点外界压力也能迫使自己持续输出一些对别人有点用的东西，是几个有一点用的软件产品、一段程序员不一样的经历、一些创业失败(2.5%概率成功)的经验、一些不成熟的想法、一些移动端开发的踩坑经历、一些解决问题的过程、一些软件推广的实践、或是以后再回想这段经历的流水账，还有就是有关一些劳动仲裁的经验。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550431.16923211593377.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;被裁\&#34;&gt;被裁&lt;/h3&gt;\n&lt;p&gt;在之前的 &lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt; 提到我开始全职创业的其中一个原因是：“刚从BAT其中的一家被动离职”，所谓被动离职说人话就是被公司裁员了，而且是0赔偿被单方走的，这事也让我想通了，无论在公司多么努力，多么卖命，一旦公司决定裁员，所有的努力都会付之一炬。而且留给自己的对自己的职业发展帮助并没有那么大，比如对之前维护的那个项目的熟悉度，我之前在公司做的是一个之前内部用了10年的内部产品，成立一个单独的部门把这个优秀的产品交付给其他客户，我在部门成立仅有5个同学的时候加入，从0开始熟悉这个有将近40万行代码的庞大工程，忙到一天从早上10点坐在工位到9点下班连喝水的时间都没有，做到随便一个模块出问题能第一时间定位并解决，做到组里疑难问题都让我排查，做到经理年度评估能力突出，做到任务完成数比去年多168%，做到代码提交数比同级多1/3，做到代码行数排在全部门9/26，做到Bug数排在客户端6/17，也难逃被无情裁员的现实。经理通知我被裁的时候我问原因是什么：他给我的答案是我周末不主动加班，晚上11点找不到人。我问，我工作都做完了周末去干什么呢，可能我真的不适合职场吧，至少不适合这种充满了内卷氛围的职场。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550443.16922492799979.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550450.16922494183043.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550456.16922494127658.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550463.16922510674976.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;对上家的感情\&#34;&gt;对上家的感情&lt;/h3&gt;\n&lt;p&gt;虽说前公司把我裁了，我并不记恨它。反而特别感谢，是它给了我前大厂员工的虚名，给了我现在不上班能有饭吃的资本，给了我时间让我充分了解了劳动法，也给了我不请律师下周自己去仲裁的勇气。&lt;br&gt;\n从去年11月份领导通知我在那次的裁员名单里到真正离开，中间持续了7个月，能持续这么久也是我没想到的，记得去年6月份部门第一次裁员的时候也就一个周，很多同学就从工作群里找不到了。外包同学甚至只需要一个下午的时间，通知你明天不用来了，就没再见了。而我，让我有如此多的时间了解劳动法，收集证据，考虑未来的道路，这7个月甚至让我把赔偿金的n从2变成了3。感情很复杂，感激多于埋怨吧。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550469.16922508683040.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;本周工作\&#34;&gt;本周工作&lt;/h3&gt;\n&lt;p&gt;本周除了准备仲裁证据外，开发了&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt;2.1.0版本，加了首页记录项左右无限滑动的交互优化，免得用户一个个手动点切换记录项体验不好，另外加了统一展示全部记录项的功能，在一个界面记录所有记录。&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt;是一款打卡计次的工具，记录任何想记录的事儿。欢迎体验：AppStore搜&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt;，或者浏览器输入：https://apps.apple.com/cn/app/id1477743089。&lt;br&gt;\n另外把起床时间改成了5点，没办法，早上梦想太吵。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550475.IMG_0751-1.png\&#34; alt=\&#34;IMG_0751\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550481.plusone-2.1.0-list.png\&#34; alt=\&#34;plusone-2.1.0-list\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;目前方向\&#34;&gt;目前方向&lt;/h3&gt;\n&lt;p&gt;上周的第一个月的收支明细收到了一些关注，有大佬针对我存在的问题-产品选型，输出了一篇干货满满的文章，我拜读完也是收获很多，推荐给想自己做产品的朋友。&lt;a href=\&#34;https://aoxiang.me/14/08/2023/choose-product/\&#34;&gt;独立开发第一步——选择一个好的IDEA&lt;/a&gt; 。另外就是，学伟扫描是19年尝试独立开发产品的时候做的一款OCR、翻译和图片转PDF工具，到如今Apple自己下场在系统层面集成OCR的今天，这类App确实不值得再投入时间，不过我自己一直在用，处于偶尔维护状态。接下来做的产品除了日常维护&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt;以外，会针对灵动岛/小组件一个细分领域，上线一系列的小工具，做完这些再尝试其他方向，反正现在有大把的时间搞，失败了积累经验、抹抹眼泪再开下一个。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.18.16923222550487.x-4.5-blog.png\&#34; alt=\&#34;x-4.5-blog\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;周更和往期文章\&#34;&gt;周更和往期文章&lt;/h3&gt;\n&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;\n&lt;p&gt;往期文章：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd\&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd\&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd\&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=653a502b51d5cd5fb9021eb1ce0c9179&amp;amp;chksm=fd9f624dcae8eb5bb19504f493a8c33b063a767626209a903ef3802f5a3a261946bbc4614b8e#rd\&#34;&gt;程序员自由创业周记#5：加一上线&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484272&amp;amp;idx=1&amp;amp;sn=45134c5275f280474641fa0340ccc3f0&amp;amp;chksm=fd9f6269cae8eb7f10164bac0a4bcdedad9cd24bcca723461223d4f3cf7e36e4b58b1deb991c#rd\&#34;&gt;程序员自由创业周记#6：劝退&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-7zhong-cai&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://images.pexels.com/photos/6077326/pexels-photo-6077326.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;w=1260&amp;amp;h=750&amp;amp;dpr=2\&#34; alt=\&#34;law\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;没想到\&#34;&gt;没想到&lt;/h3&gt;\n&lt;p&gt;没想到写的周记会有这么多人看，还能收到这么多陌生(或熟悉)朋友的真诚建议、鼓励、甚至是打赏，几乎所有的评论和私信我都认真的回复了，本想的是通过网友和朋友的监督坚定我创业的信念，有点外界压力也能迫使自己持续输出一些对别人有点用的东西，是几个有一点用的软件产品、一段程序员不一样的经历、一些创业失败(2.5%概率成功)的经验、一些不成熟的想法、一些移动端开发的踩坑经历、一些解决问题的过程、一些软件推广的实践、或是以后再回想这段经历的流水账，还有就是有关一些劳动仲裁的经验。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#7：仲裁&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-08-18 09:31:45&#34;,&#34;dateFormat&#34;:&#34;2023-08-18&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-7zhong-cai/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:308000,&#34;words&#34;:1500,&#34;minutes&#34;:6},&#34;description&#34;:&#34;\n这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。\n没想到\n没想到写的周记会有这么多人看，还能收到这么多陌生(或熟悉)朋友的真诚建议、鼓励、甚至是打赏，几乎所有的评论和私信我都认真的回复了，本想的是通过网友和朋...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B2%A1%E6%83%B3%E5%88%B0\&#34;&gt;没想到&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A2%AB%E8%A3%81\&#34;&gt;被裁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E4%B8%8A%E5%AE%B6%E7%9A%84%E6%84%9F%E6%83%85\&#34;&gt;对上家的感情&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%91%A8%E5%B7%A5%E4%BD%9C\&#34;&gt;本周工作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%AE%E5%89%8D%E6%96%B9%E5%90%91\&#34;&gt;目前方向&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4%E5%92%8C%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;周更和往期文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917169577176.photo-1547496614-154dee7fd157.jpeg\&#34; alt=\&#34;photo-1547496614-154dee7fd157\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;劝退\&#34;&gt;劝退&lt;/h3&gt;\n&lt;p&gt;如果一位程序员问我要不要进行独立开发创业，我100%会建议他不要冲动，因为这条路太苦太累，成功率太低，论性价比而言，找个工作安心打工无疑更高，有稳定的收入，能安逸的成长，如果公司不加班就更好了，可以业余时间尝试做独立软件，等收入积累到一定程度，积蓄能坚持3-5年，或者独立软件收入逐渐稳定跟主业持平时可以再全职做。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;收支明细\&#34;&gt;收支明细&lt;/h3&gt;\n&lt;p&gt;距离决定全职独立开发创业已经过去一个月了，打开记账软件满满的焦虑再次袭来，积蓄还能撑多久，梦还能做多久，之前预想到前期很长一段时间内将没有任何收入，可真正经历只出不进的日子，还是会非常焦虑。支出：首先是固定支出房租：4500，房贷：3534，社保：1901；第一个月置办了台性能比较好的电脑和一台测试机：16609，外加一些必要的生活开销总共支出：28697.77。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917166442409.IMG_0718.png\&#34; alt=\&#34;IMG_0718\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;收入\&#34;&gt;收入&lt;/h3&gt;\n&lt;p&gt;目前两款独立软件产品：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id1468603429\&#34;&gt;学伟扫描&lt;/a&gt; （ https://apps.apple.com/cn/app/id1468603429 ） 收入：-4.5，&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt; （ https://apps.apple.com/cn/app/id1477743089 ） 收入：0，&lt;/li&gt;\n&lt;li&gt;共：-4.5元。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;创业第一个月收入为-4.5元。为什么是负的，因为唯一的一笔销售额是我测试的时候自己买的会员，苹果扣了15%的税，加一因为8月刚上线，还没有收入。&lt;br&gt;\n落差大吗，看了下去年个人所得税的收入，对比现在，不可谓不惨，落差不可谓不大。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917166442428.16916782933520.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;给自己加油\&#34;&gt;给自己加油&lt;/h3&gt;\n&lt;p&gt;路是自己选的，即便再苦再累再穷，我也不打算放弃，希望我能一直坚持下去，坚持到柳暗花明那一天。&lt;/p&gt;\n&lt;h3 id=\&#34;周更和往期文章\&#34;&gt;周更和往期文章&lt;/h3&gt;\n&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;\n&lt;p&gt;往期文章：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd\&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd\&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd\&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=653a502b51d5cd5fb9021eb1ce0c9179&amp;amp;chksm=fd9f624dcae8eb5bb19504f493a8c33b063a767626209a903ef3802f5a3a261946bbc4614b8e#rd\&#34;&gt;程序员自由创业周记#5：加一上线&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-6quan-tui&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917169577176.photo-1547496614-154dee7fd157.jpeg\&#34; alt=\&#34;photo-1547496614-154dee7fd157\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;劝退\&#34;&gt;劝退&lt;/h3&gt;\n&lt;p&gt;如果一位程序员问我要不要进行独立开发创业，我100%会建议他不要冲动，因为这条路太苦太累，成功率太低，论性价比而言，找个工作安心打工无疑更高，有稳定的收入，能安逸的成长，如果公司不加班就更好了，可以业余时间尝试做独立软件，等收入积累到一定程度，积蓄能坚持3-5年，或者独立软件收入逐渐稳定跟主业持平时可以再全职做。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34; 程序员自由创业周记#6：劝退&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-08-11 09:44:18&#34;,&#34;dateFormat&#34;:&#34;2023-08-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-6quan-tui/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:133000,&#34;words&#34;:633,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。\n劝退\n如果一位程序员问我要不要进行独立开发创业，我100%会建议他不要冲动，因为这条路太苦太累，成功率太低，论性价比而言，找个工作安心打工无疑更高，有稳定的收...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%9D%E9%80%80\&#34;&gt;劝退&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%B6%E6%94%AF%E6%98%8E%E7%BB%86\&#34;&gt;收支明细&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%B6%E5%85%A5\&#34;&gt;收入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%99%E8%87%AA%E5%B7%B1%E5%8A%A0%E6%B2%B9\&#34;&gt;给自己加油&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4%E5%92%8C%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;周更和往期文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记5加一上线\&#34;&gt;程序员自由创业周记#5：加一上线&lt;/h1&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;充实\&#34;&gt;充实&lt;/h3&gt;\n&lt;p&gt;如果说程序员独立创业的成功率只有5%，那如果家里有一位3岁多还没上幼儿园的小朋友要照顾，成功的概率至少还要降低一半，过去一个月，除了吃饭睡觉几乎都在开发软件和构思新产品，完成了13个全新的让人眼前一亮的界面，其中的统计、展示、发布逻辑也费了一番功夫，毕竟做的产品要服务可能得服务成千上万的用户，让用户在使用产品的时候有一个好的体验尤为重要。原本想的是离职以后去318玩一圈，回来再打半个月篮球，睡到自然醒，真正开始创业才发现，比上班还忙，甚至忙到连电影都舍不得看，有一股很强的内驱力迫使自己往前走。体现在以前自然醒的时间是9点10分，最近一段时间是早上5点55。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;产品发布\&#34;&gt;产品发布&lt;/h3&gt;\n&lt;p&gt;之前在 &lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd\&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt; 中提到过这一个月一直在忙的这个项目，一个记录生活的小而美产品，&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt; 在昨天通过了审核，成功上线AppStore。这大概是我之前做过的软件中最漂亮的一个。欣赏几张她的美照：&lt;/p&gt;\n&lt;h4 id=\&#34;截图1\&#34;&gt;截图1&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377928.6271691025600_.pic_hd.jpg\&#34; alt=\&#34;6271691025600_.pic_hd\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;截图2\&#34;&gt;截图2&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377936.6261691025599_.pic_hd.jpg\&#34; alt=\&#34;6261691025599_.pic_hd\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;截图3\&#34;&gt;截图3&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377942.6251691025598_.pic_hd.jpg\&#34; alt=\&#34;6251691025598_.pic_hd\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;截图4\&#34;&gt;截图4&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917187377949.6241691025596_.pic_hd.jpg\&#34; alt=\&#34;6241691025596_.pic_hd\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;有什么用\&#34;&gt;有什么用&lt;/h3&gt;\n&lt;p&gt;做一个产品光漂亮还不够，得有用，对用户有价值才行。加一是一个极简打卡计数器，主要用来：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;习惯养成打卡。喝水、早睡、阅读、不喝奶茶等等新习惯，只要做到了，就可用加一来打卡一次。&lt;/li&gt;\n&lt;li&gt;记录情绪状态。生气、emo、失眠、熬夜等等不常发生的状态，一年下来究竟会发生多少次呢？发生一次，便可记录一次。&lt;/li&gt;\n&lt;li&gt;追踪生活小事。今年感冒几次了、看了几次日出日落，给家里打了几次电话……不起眼的小事，记起来就不会忘记。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;生活不止眼前的苟且，需要也值得认真对待，&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt; （ https://apps.apple.com/cn/app/id1477743089 ） 可以记录你做的每一件值得记录的事。闲暇时拿起 &lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt; 摇晃下首页的瓶子，会有满满成就感的！&lt;/p&gt;\n&lt;p&gt;iPhone用户 AppStore搜索：加一，或者浏览器输入： https://apps.apple.com/cn/app/id1477743089&lt;/p&gt;\n&lt;h3 id=\&#34;收入\&#34;&gt;收入&lt;/h3&gt;\n&lt;p&gt;下周的周记会公布创业第一个月花了多少钱，挣了多少钱 😄&lt;/p&gt;\n&lt;h3 id=\&#34;周更和往期文章\&#34;&gt;周更和往期文章&lt;/h3&gt;\n&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;\n&lt;p&gt;往期文章：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd\&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd\&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484216&amp;amp;idx=1&amp;amp;sn=db3924fc4c318b3743f2c94a8f47c2d3&amp;amp;chksm=fd9f6221cae8eb37e5769cdbcef7231c3e950061d7f528cb977bf3ae6b2f665ea354d3a78ab7#rd\&#34;&gt;程序员自由创业周记#4：从一笔30美元的收入谈起&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-5jia-yi-shang-xian&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;程序员自由创业周记5加一上线\&#34;&gt;程序员自由创业周记#5：加一上线&lt;/h1&gt;\n&lt;p&gt;这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。&lt;/p&gt;\n&lt;h3 id=\&#34;充实\&#34;&gt;充实&lt;/h3&gt;\n&lt;p&gt;如果说程序员独立创业的成功率只有5%，那如果家里有一位3岁多还没上幼儿园的小朋友要照顾，成功的概率至少还要降低一半，过去一个月，除了吃饭睡觉几乎都在开发软件和构思新产品，完成了13个全新的让人眼前一亮的界面，其中的统计、展示、发布逻辑也费了一番功夫，毕竟做的产品要服务可能得服务成千上万的用户，让用户在使用产品的时候有一个好的体验尤为重要。原本想的是离职以后去318玩一圈，回来再打半个月篮球，睡到自然醒，真正开始创业才发现，比上班还忙，甚至忙到连电影都舍不得看，有一股很强的内驱力迫使自己往前走。体现在以前自然醒的时间是9点10分，最近一段时间是早上5点55。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#5：加一上线&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-08-04 09:10:56&#34;,&#34;dateFormat&#34;:&#34;2023-08-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-5jia-yi-shang-xian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:165000,&#34;words&#34;:796,&#34;minutes&#34;:3},&#34;description&#34;:&#34;程序员自由创业周记#5：加一上线\n这是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。\n充实\n如果说程序员独立创业的成功率只有5%，那如果家里有一位3岁多还没上幼儿园的小朋友要照顾，成功的概率至少还要降低一半，过去...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E7%94%B1%E5%88%9B%E4%B8%9A%E5%91%A8%E8%AE%B05%E5%8A%A0%E4%B8%80%E4%B8%8A%E7%BA%BF\&#34;&gt;程序员自由创业周记#5：加一上线&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%85%E5%AE%9E\&#34;&gt;充实&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83\&#34;&gt;产品发布&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%AA%E5%9B%BE1\&#34;&gt;截图1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%AA%E5%9B%BE2\&#34;&gt;截图2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%AA%E5%9B%BE3\&#34;&gt;截图3&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%AA%E5%9B%BE4\&#34;&gt;截图4&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\&#34;&gt;有什么用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%B6%E5%85%A5\&#34;&gt;收入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4%E5%92%8C%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;周更和往期文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917196663205.pexels-freestocksorg-127713.jpg\&#34; alt=\&#34;pexels-freestocksorg-127713\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;本文是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。在文末，您还可以找到之前的历史文章。&lt;/p&gt;\n&lt;h3 id=\&#34;惊喜之旅\&#34;&gt;惊喜之旅&lt;/h3&gt;\n&lt;p&gt;这次的惊喜源于 &lt;a href=\&#34;https://apps.apple.com/cn/app/id1507727251\&#34;&gt;学伟扫描Pro&lt;/a&gt; 在美国销售的第一笔订单，这标志着我的产品获得了漂亮国用户的认可，让我感到非常欣慰。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id1468603429\&#34;&gt;学伟扫描&lt;/a&gt; 是我四年前尝试独立开发的第一款产品，最初命名为微扫描，但商标注册失败；后来改成了微扫，商标依然未能注册成功；最终，我决定将”学伟“注册为第9类软件商标，成功注册，于是有了这个朴实无华的名字。然而，无论名字如何，最重要的是产品本身。&lt;a href=\&#34;https://apps.apple.com/cn/app/id1468603429\&#34;&gt;学伟扫描&lt;/a&gt; 上线三年来，在没有任何推广的前提下，收获了2.2万次下载，获得32个评分，其中30个是五星评价，1个是四星评价，1个是三星评价；好评率高达93.75%。因此，她确实挺好用，能够吸引漂亮国用户也就不足为奇了。值得一提的是，Pro版本在美区售价为30美元，而普通版本则为3.99美元（包年订阅）。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917196663216.iScannerPro-29.99.png\&#34; alt=\&#34;iScannerPro-29.99\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;学伟扫描\&#34;&gt;&lt;a href=\&#34;https://apps.apple.com/cn/app/id1468603429\&#34;&gt;学伟扫描&lt;/a&gt; 的功能简介&lt;/h3&gt;\n&lt;p&gt;简单来说，&lt;a href=\&#34;https://apps.apple.com/cn/app/id1468603429\&#34;&gt;学伟扫描&lt;/a&gt; 的功能就是将照片中的文字提取出来，这项技术被称为OCR。除此之外，它还扩展了其他功能，比如：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;当朋友发来一张充满文字的图片时，可以用它提取文字内容；&lt;/li&gt;\n&lt;li&gt;上课时拍摄了很多课件，可以用它按科目进行整理，并删除相册中的重复照片；&lt;/li&gt;\n&lt;li&gt;在刷微博时看到一张英文图片，不知道其意思，可以用它进行识别和翻译，从而了解其含义；&lt;/li&gt;\n&lt;li&gt;将一张或多张图片转换成PDF格式导出，或通过打印机进行打印。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;突出优势\&#34;&gt;突出优势&lt;/h3&gt;\n&lt;p&gt;市面上类似的软件成百上千，甚至iPhone自带的拍照功能也具备OCR功能，那么&lt;a href=\&#34;https://apps.apple.com/cn/app/id1468603429\&#34;&gt;学伟扫描&lt;/a&gt; 有何优势呢？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;它采用了市面上最准确的API，确保了最高的识别准确率；&lt;/li&gt;\n&lt;li&gt;完全无广告，用户体验更加纯粹；&lt;/li&gt;\n&lt;li&gt;仅需0.25秒即可启动，操作更加高效便捷；&lt;/li&gt;\n&lt;li&gt;可以根据需要建立文件夹分类整理文件；&lt;/li&gt;\n&lt;li&gt;数据安全，所有资料均在本地管理，保障用户隐私。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917196663224.16917196406595.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;种下的种子\&#34;&gt;种下的种子&lt;/h3&gt;\n&lt;p&gt;虽然 &lt;a href=\&#34;https://apps.apple.com/cn/app/id1468603429\&#34;&gt;学伟扫描&lt;/a&gt; 三年来的收入还不足以覆盖一年开发者账号的年费，但它确实是当初我准备追求全职独立开发道路时所种下的一颗种子。通过这一过程，我深刻体验到开发一款完全属于自己的软件带来的乐趣。相比之下，为他人打工无论有多轻松都让我感到痛苦，而做自己的产品无论再累也让我感到幸福。&lt;/p&gt;\n&lt;h3 id=\&#34;周更和往期文章\&#34;&gt;周更和往期文章&lt;/h3&gt;\n&lt;p&gt;我的周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待您的关注。&lt;/p&gt;\n&lt;p&gt;往期文章：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd\&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484202&amp;amp;idx=1&amp;amp;sn=bd0f20c0a52b1ad96391e1c6de2e8a2b&amp;amp;chksm=fd9f6233cae8eb2535f61bca7eee01da3be9f3f25eec65dd7131ed63a17bf494f0ab693ab3f8#rd\&#34;&gt;程序员自由创业周记#3：No1.作品&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-4cong-yi-bi-30-mei-yuan-de-shou-ru-tan-qi&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917196663205.pexels-freestocksorg-127713.jpg\&#34; alt=\&#34;pexels-freestocksorg-127713\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;本文是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。在文末，您还可以找到之前的历史文章。&lt;/p&gt;\n&lt;h3 id=\&#34;惊喜之旅\&#34;&gt;惊喜之旅&lt;/h3&gt;\n&lt;p&gt;这次的惊喜源于 &lt;a href=\&#34;https://apps.apple.com/cn/app/id1507727251\&#34;&gt;学伟扫描Pro&lt;/a&gt; 在美国销售的第一笔订单，这标志着我的产品获得了漂亮国用户的认可，让我感到非常欣慰。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#4：从一笔30美元的收入谈起&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-07-28 09:18:33&#34;,&#34;dateFormat&#34;:&#34;2023-07-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-4cong-yi-bi-30-mei-yuan-de-shou-ru-tan-qi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:175000,&#34;words&#34;:859,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n本文是一位程序员进行独立开发创业的记录，将分享创业过程中的所思所想以及收支明细。在文末，您还可以找到之前的历史文章。\n惊喜之旅\n这次的惊喜源于 学伟扫描Pro 在美国销售的第一笔订单，这标志着我的产品获得了漂亮国用户的认可，让我感到非常欣...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%83%8A%E5%96%9C%E4%B9%8B%E6%97%85\&#34;&gt;惊喜之旅&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%A6%E4%BC%9F%E6%89%AB%E6%8F%8F\&#34;&gt;学伟扫描&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AA%81%E5%87%BA%E4%BC%98%E5%8A%BF\&#34;&gt;突出优势&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A7%8D%E4%B8%8B%E7%9A%84%E7%A7%8D%E5%AD%90\&#34;&gt;种下的种子&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4%E5%92%8C%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;周更和往期文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198093162.pexels-czapp-17077346.jpg\&#34; alt=\&#34;pexels-czapp-árpád-17077346\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。&lt;/p&gt;\n&lt;h3 id=\&#34;作息\&#34;&gt;作息&lt;/h3&gt;\n&lt;p&gt;如果不是热爱，很难解释为什么能早上6点自然醒后坐在电脑前除了吃饭一直敲代码到23点这个现象，而且还乐此不疲。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;之前上班的时候生活就很规律，没想到失业后的生活比之前还要规律；记得还在上班的时候，每天7点半懒洋洋的起床，洗洗涮涮挤上8点的地铁，晃晃悠悠到公司吃免费的早餐，开启一天司空寻常的打工时间，完成“上级”们规定的工作任务，到了6点打会球，再肝到89点下班回家，回家可能看看电影，刷刷手机就半夜了，周而复始，那时候有工资，周末隔三差五的京郊旅个游。现在，旅游对现在的自己来说算是很奢侈了，毕竟这点前得花13个月。还不确定产品何时才会有收入。&lt;/p&gt;\n&lt;h3 id=\&#34;焦虑\&#34;&gt;焦虑&lt;/h3&gt;\n&lt;p&gt;焦虑一直伴随着我，努力工作的时候想着会不会做不好；前期部门同事被优化的时候焦虑会不会临到我；被通知优化的时候焦虑失业会不会找不到工作；创业后焦虑没收入家里开销不够；打球投篮不准的时候焦虑会不会拉队友后腿。。。 还好我调整能力比较强，内心比较强大，能一直专注做我以为有价值的事，这其中家人、朋友还有坚持了一年每天10分钟的正念一直给我提供源源不断的能量。&lt;br&gt;\n相信每个人都会或多或少的有过焦虑的情绪，这太正常不过了，哪有那么一帆风顺、波澜不惊的生活呢，即便有我也不想过。&lt;/p&gt;\n&lt;h3 id=\&#34;第一个作品\&#34;&gt;第一个作品&lt;/h3&gt;\n&lt;p&gt;最近一个月都在紧锣密鼓的开发第一个作品，预期月底能提审AppStore，这个产品的设计和第一个版本都不是我，我负责的是2.0的改版，前期是没有收入的，以收益分成的形式合作；也就是说App 上线后产生收入在扣除成本后的收益的一部分是我的报酬，我把他完全看做自己的产品，也在跟独立开发圈两位前辈的合作中学习，也正是在这个App的开发中渐渐进入创业的状态。&lt;/p&gt;\n&lt;h3 id=\&#34;什么作品\&#34;&gt;什么作品&lt;/h3&gt;\n&lt;p&gt;她在AppStore的名字叫：&lt;a href=\&#34;https://apps.apple.com/cn/app/id1477743089\&#34;&gt;加一&lt;/a&gt;；一个打卡类型的应用，记录日常生活的点点滴滴，比如今年看了几次日出&lt;/p&gt;\n&lt;h5 id=\&#34;这是她现在的样子\&#34;&gt;这是她现在的样子：&lt;/h5&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198093177.16899270859771.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h5 id=\&#34;这是她未来的样子\&#34;&gt;这是她未来的样子：&lt;/h5&gt;\n&lt;p&gt;先留个悬念吧，肯定很漂亮，也很实用...&lt;/p&gt;\n&lt;h3 id=\&#34;文具\&#34;&gt;文具&lt;/h3&gt;\n&lt;p&gt;之前提到为了开发上上周买了一台 24G 内存 的MacBookAir，昨天刚折价800外加送300多配件外加送货上门把它卖了，没办法，现在开发的强度太大了；我怕它一直发热出问题，耽误我造火箭。然后在闲鱼上淘了台 32G 内存的MacBookPro，期望我跟它能合作愉快&lt;/p&gt;\n&lt;h3 id=\&#34;周更往期文章\&#34;&gt;周更&amp;amp;往期文章&lt;/h3&gt;\n&lt;p&gt;周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待关注。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484180&amp;amp;idx=1&amp;amp;sn=cb99529a03e58a938947a5409a2d612f&amp;amp;chksm=fd9f620dcae8eb1bfc6fbdf6821232653c4d3a411f04813d0b2b3de0faa098305fcfb5599ee2#rd\&#34;&gt;程序员自由创业周记#2：前期准备&lt;/a&gt;d)&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-3no1zuo-pin&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198093162.pexels-czapp-17077346.jpg\&#34; alt=\&#34;pexels-czapp-árpád-17077346\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。&lt;/p&gt;\n&lt;h3 id=\&#34;作息\&#34;&gt;作息&lt;/h3&gt;\n&lt;p&gt;如果不是热爱，很难解释为什么能早上6点自然醒后坐在电脑前除了吃饭一直敲代码到23点这个现象，而且还乐此不疲。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#3：No1.作品&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;}],&#34;date&#34;:&#34;2023-07-21 16:24:06&#34;,&#34;dateFormat&#34;:&#34;2023-07-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-3no1zuo-pin/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:183000,&#34;words&#34;:896,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。\n作息\n如果不是热爱，很难解释为什么能早上6点自然醒后坐在电脑前除了吃饭一直敲代码到23点这个现象，而且还乐此不疲。\n\n之前上班的时候生活就...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%9C%E6%81%AF\&#34;&gt;作息&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%84%A6%E8%99%91\&#34;&gt;焦虑&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%9C%E5%93%81\&#34;&gt;第一个作品&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E4%BD%9C%E5%93%81\&#34;&gt;什么作品&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%99%E6%98%AF%E5%A5%B9%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%A0%B7%E5%AD%90\&#34;&gt;这是她现在的样子：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%99%E6%98%AF%E5%A5%B9%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%A0%B7%E5%AD%90\&#34;&gt;这是她未来的样子：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E5%85%B7\&#34;&gt;文具&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;周更&amp;amp;往期文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198932716.pexels-skylar-kang-6368836.jpg\&#34; alt=\&#34;pexels-skylar-kang-6368836\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。&lt;/p&gt;\n&lt;h3 id=\&#34;感恩\&#34;&gt;感恩&lt;/h3&gt;\n&lt;p&gt;上次公开了创业的决定后，得到了很多亲朋好友和陌生朋友的鼓励或支持，以不同的形式，感动之情溢于言表。这些都会记在心里，大恩不言谢~&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;创业方向\&#34;&gt;创业方向&lt;/h3&gt;\n&lt;p&gt;笔者是一名资质平平的iOS开发程序猿，创业项目也就是开发App卖，类型的话主要以工具类为主，优先会解决一些我的需求。平台以iOS平台和MacOS平台为主，如果移动端产品反响不错会考虑使用Flutter开发Android版本。后续即将开发的产品会在如下几个里选几个：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;MacOS 定时提醒休息&lt;/li&gt;\n&lt;li&gt;MacOS 截图、OCR&lt;/li&gt;\n&lt;li&gt;MacOS 番茄钟&lt;/li&gt;\n&lt;li&gt;MacOS &amp;amp; iOS 纪念日倒计时&lt;/li&gt;\n&lt;li&gt;iOS 各种类型的小组件&lt;/li&gt;\n&lt;li&gt;iOS 个人OKR目标管理&lt;/li&gt;\n&lt;li&gt;iOS 每日金句&lt;/li&gt;\n&lt;li&gt;iOS 灵动岛动画&lt;/li&gt;\n&lt;li&gt;iOS 音频转文字&lt;/li&gt;\n&lt;li&gt;iOS 闹钟&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;上面的任何一种类型在商店都能找到一堆产品，我这边差异性可能就是极简和用户体验，还有就是出海，不限于国内市场；&lt;br&gt;\n我负责产品规划，代码开发，运营推广，爱人负责UI设计。每个阶段都会借助AI工具的帮助，最大限度发挥个人的力量。而且个人精力和积蓄有效，所以只给自己13个月的时间，如果赚不到钱就找活。也正是因为只有13个月，所以不可能每个产品都做，会集中精力打磨其中的几个，中间涉及到任何经验我均会在周报中公开，也便监督自己。&lt;/p&gt;\n&lt;p&gt;还有最近两周在跟独立开发圈的两位前辈在共同开发一款打卡类型的软件，产品经理的设计令人过目难忘，另外一位的技术能力让人折服；相信在跟两位前辈的合作能让我更快进入创业的状态。&lt;/p&gt;\n&lt;h3 id=\&#34;差生文具多\&#34;&gt;差生文具多&lt;/h3&gt;\n&lt;h4 id=\&#34;macbook\&#34;&gt;MacBook&lt;/h4&gt;\n&lt;p&gt;既然是开发iOS App，必然需要一台Mac电脑，原本的 「MacBook Air 8G内存 M1芯片 13寸 2019款」，本来是我一直在用，但随着爱人研究生开学，和即将为产品设计UI也需要一台单独的电脑，所以决定再采购一台MacBook开发用，台式电脑肯定不行，既然独立开发，就要享受走到哪在哪工作的状态。结合预算和性能 「MacBook Pro 16G内存 M1 Pro芯片 51G硬盘 16寸 2021款」 和 「MacBook Air 24G内存 M2芯片 1T硬盘 15寸 2023」进入了最终的决赛，两款都是1.35万左右，开发iOS App都完全足够，最终通过拍脑门决定买了后者。而且之前的Air 用着很顺畅，也没有GPU的强需求，觉得Air足够；&lt;br&gt;\n然后买完就后悔了，等电脑到了以后，发现用Xcode 15 beta版本调试发热严重，屏幕下沿温度能达到43摄氏度，去Apple直营店检测也没问题，可能这是Xcode 测试版本的通病吧。如果再让我选一次，可能选择有风扇的Pro吧。&lt;/p&gt;\n&lt;h4 id=\&#34;iphone\&#34;&gt;iPhone&lt;/h4&gt;\n&lt;p&gt;因为用Xcode15发热严重，加上我的主力机升级了iOS17必须用Xcode15才能调试，迫使我从咸鱼上淘了一台换过屏+电池循环897次的iPhone12 作为测试机。&lt;/p&gt;\n&lt;h4 id=\&#34;gpt\&#34;&gt;GPT&lt;/h4&gt;\n&lt;p&gt;除了MacBook，升级了ChatGPT Plus，以便使用 GPT4 的模型帮我写代码；然后买了 GitHub Copilot 也是在Xcode写代码的时候一些简单的语法能提示的更多一些；这两个AI工具大概每天能帮我节省半小时的开发时间吧，预估。&lt;/p&gt;\n&lt;h3 id=\&#34;工位\&#34;&gt;工位&lt;/h3&gt;\n&lt;p&gt;还有就是整理了下在家的工位，白天去图书馆、公园、咖啡馆写代码，晚上在家自己的工位上写。虽说没人监督，但是动力确实比上班的时候足。每天叫醒自己的真正的是梦想。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198932731.A9D8AFAF-C730-4917-8ECB-F1511030A5AB_1_105_c.jpeg\&#34; alt=\&#34;A9D8AFAF-C730-4917-8ECB-F1511030A5AB_1_105_c\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;周更往期文章\&#34;&gt;周更&amp;amp;往期文章&lt;/h3&gt;\n&lt;p&gt;周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待关注。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzU4NDE1MzIwNg==&amp;amp;mid=2247484168&amp;amp;idx=1&amp;amp;sn=6122e8d93af633c45a34535479a6f469&amp;amp;chksm=fd9f6211cae8eb073edda95d56f8fe756d42047031d74fa479cfd138df268ed65f97b2fac4a0#rd\&#34;&gt;程序员自由创业周记#1：做一场梦吧&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-2qian-qi-zhun-bei&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917198932716.pexels-skylar-kang-6368836.jpg\&#34; alt=\&#34;pexels-skylar-kang-6368836\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。&lt;/p&gt;\n&lt;h3 id=\&#34;感恩\&#34;&gt;感恩&lt;/h3&gt;\n&lt;p&gt;上次公开了创业的决定后，得到了很多亲朋好友和陌生朋友的鼓励或支持，以不同的形式，感动之情溢于言表。这些都会记在心里，大恩不言谢~&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#2：前期准备&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;},{&#34;name&#34;:&#34;独立开发&#34;,&#34;slug&#34;:&#34;UV91key1Zw&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/UV91key1Zw/&#34;}],&#34;date&#34;:&#34;2023-07-14 16:48:47&#34;,&#34;dateFormat&#34;:&#34;2023-07-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-2qian-qi-zhun-bei/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:232000,&#34;words&#34;:1093,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n本文是程序员进行独立开发创业的记录，会分享创业创业过程中的所思所想和收支明细，文末有往期历史文章。\n感恩\n上次公开了创业的决定后，得到了很多亲朋好友和陌生朋友的鼓励或支持，以不同的形式，感动之情溢于言表。这些都会记在心里，大恩不言谢~\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%84%9F%E6%81%A9\&#34;&gt;感恩&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E4%B8%9A%E6%96%B9%E5%90%91\&#34;&gt;创业方向&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A\&#34;&gt;差生文具多&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#macbook\&#34;&gt;MacBook&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#iphone\&#34;&gt;iPhone&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#gpt\&#34;&gt;GPT&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E4%BD%8D\&#34;&gt;工位&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4%E5%BE%80%E6%9C%9F%E6%96%87%E7%AB%A0\&#34;&gt;周更&amp;amp;往期文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917199828281.pexels-sindre-fs-1106416.jpg\&#34; alt=\&#34;pexels-sindre-fs-1106416\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;自由\&#34;&gt;“自由”&lt;/h3&gt;\n&lt;p&gt;为了做这一场梦，前前后后准备了4年，从19年接触 独立开发/数字游民/自由职业者 以后，总觉得这才是我一直追求的生活方式，没有职场的阿谀奉承，没有人强制你某个时间点必须坐到某个座位上，再也没有无休止的会，当然，也没有人再固定每个月往你银行卡打钱。然后可以自由的选择工作场所，自由的选择工作时间，自由的选择开发什么产品，自由的选择是否工作，自由的呼吸，自由的活。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;为了这种自由的生活方式，在深思熟虑了两周以后，决定暂时先不找工作，进行一次全职创业，做一场13个月的梦~&lt;/p&gt;\n&lt;h3 id=\&#34;我是谁\&#34;&gt;我是谁&lt;/h3&gt;\n&lt;p&gt;先介绍下自己：全网ID：极客学伟，一名从事了8年iOS开发的程序员，刚从BAT其中的一家被动离职，上个月刚过完30岁生日，一位3岁男孩的父亲，土生土长的山东农村孩子，也正因为没有背景，有家庭和孩子要养，这场梦不能做太久，所以暂定13个月，倘若13个月后没有挣到足够基本生活的收入，再去找个班上。&lt;/p&gt;\n&lt;h3 id=\&#34;缘由\&#34;&gt;缘由&lt;/h3&gt;\n&lt;p&gt;为什么选择这个时间节点创业，主要是以下几点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;自己的开发技术随算不上什么大佬，但基本能完成大部分的开发任务。&lt;/li&gt;\n&lt;li&gt;当前AI蓬勃发展，开发产品辅助AI的协助，如虎添翼。&lt;/li&gt;\n&lt;li&gt;积累了很多idea，需要一段时间集中把他们变成产品推向市场，再慢慢打磨。&lt;/li&gt;\n&lt;li&gt;工作几年也攒了一些钱，够一年家庭基本开销。&lt;/li&gt;\n&lt;li&gt;积累了一些独立开发的经验，也加了几个群，不孤单。&lt;/li&gt;\n&lt;li&gt;爱人支持。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;准备\&#34;&gt;准备&lt;/h3&gt;\n&lt;p&gt;从19年接触独立开发之后，我主要做了这些事：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;独立开发了一款OCR软件：&lt;a href=\&#34;https://apps.apple.com/mo/app/id1530758072\&#34;&gt;学伟扫描&lt;/a&gt; ，独立开发产品初体验。&lt;/li&gt;\n&lt;li&gt;注册了一家公司。&lt;/li&gt;\n&lt;li&gt;注册了 ”学伟“ 的商标，计划后续所有的产品都叫 学伟xx ，希望能做成一个有些许知名度的品牌​。​&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;致敬\&#34;&gt;致敬&lt;/h3&gt;\n&lt;p&gt;受 &lt;a href=\&#34;https://v2ex.com/member/maduoduo\&#34;&gt;maduoduo&lt;/a&gt;、&lt;a href=\&#34;https://www.v2ex.com/member/vulgur\&#34;&gt;vulgur&lt;/a&gt; 等前辈的影响，会公开创业期间的所思所想和收支情况，也算对自己的督促。&lt;/p&gt;\n&lt;p&gt;预计这13个月的总收入不会比之前上班一个月挣得多，大概95%的概率会失败，但就是图这5%的概率，万一成了呢！&lt;/p&gt;\n&lt;h3 id=\&#34;周更\&#34;&gt;周更&lt;/h3&gt;\n&lt;p&gt;周记主要发布在个人博客：&lt;a href=\&#34;https://qiuxuewei.com/\&#34;&gt;极客学伟&lt;/a&gt; 和 同名微信公众号上，期待关注。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-1zuo-yi-chang-meng-ba&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://wescanner-docx.jkxuewei.com/images/mweb/2023.08.11.16917199828281.pexels-sindre-fs-1106416.jpg\&#34; alt=\&#34;pexels-sindre-fs-1106416\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;自由\&#34;&gt;“自由”&lt;/h3&gt;\n&lt;p&gt;为了做这一场梦，前前后后准备了4年，从19年接触 独立开发/数字游民/自由职业者 以后，总觉得这才是我一直追求的生活方式，没有职场的阿谀奉承，没有人强制你某个时间点必须坐到某个座位上，再也没有无休止的会，当然，也没有人再固定每个月往你银行卡打钱。然后可以自由的选择工作场所，自由的选择工作时间，自由的选择开发什么产品，自由的选择是否工作，自由的呼吸，自由的活。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;程序员自由创业周记#1：做一场梦吧&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;创业&#34;,&#34;slug&#34;:&#34;o9DpHl3EH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/o9DpHl3EH/&#34;},{&#34;name&#34;:&#34;独立开发&#34;,&#34;slug&#34;:&#34;UV91key1Zw&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/UV91key1Zw/&#34;}],&#34;date&#34;:&#34;2023-07-07 11:20:16&#34;,&#34;dateFormat&#34;:&#34;2023-07-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/cheng-xu-yuan-zi-you-chuang-ye-zhou-ji-1zuo-yi-chang-meng-ba/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:140000,&#34;words&#34;:682,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n“自由”\n为了做这一场梦，前前后后准备了4年，从19年接触 独立开发/数字游民/自由职业者 以后，总觉得这才是我一直追求的生活方式，没有职场的阿谀奉承，没有人强制你某个时间点必须坐到某个座位上，再也没有无休止的会，当然，也没有人再固定每个...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E7%94%B1\&#34;&gt;“自由”&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%91%E6%98%AF%E8%B0%81\&#34;&gt;我是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%98%E7%94%B1\&#34;&gt;缘由&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%86%E5%A4%87\&#34;&gt;准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%B4%E6%95%AC\&#34;&gt;致敬&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%A8%E6%9B%B4\&#34;&gt;周更&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;设计模式-行为型\&#34;&gt;设计模式-行为型&lt;/h1&gt;\n&lt;p&gt;行为型设计模式主要用于软件运行时复杂的流程控制。包含：模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式和解释器模式&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;模板方法模式\&#34;&gt;模板方法模式&lt;/h2&gt;\n&lt;p&gt;在软件设计时，很多时候系统的运行流程都是确定的，在整个流程中，可能只有部分环节的具体实现是有差别的，这时我们就可以使用模板方法模式，其具体定义为：定义一个操作流程中的算法骨架，将部分算法环节的实现延迟到子类中，使子类可以在不改变算法骨架的前提下对特定步骤进行定制。&lt;/p&gt;\n&lt;p&gt;以职员的工作流程为例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class Management {\n    func clockIn() {\n        print(&amp;quot;上班&amp;quot;)\n    }\n    func working() {\n        print(&amp;quot;工作&amp;quot;)\n    }\n    func clockOut() {\n        print(&amp;quot;下班&amp;quot;)\n    }\n    func start() {\n        clockIn()\n        working()\n        clockOut()\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;无论对于任何岗位的职员，这个流程都不变，对于不同的岗位不同的是具体的工作内容，例如添加一位工程师，以模板方法模式设计：&lt;/p&gt;\n&lt;h3 id=\&#34;重构后\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;...\nclass Engineer: Management {\n    override func working() {\n        print(&amp;quot;软件设计&amp;quot;)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用模板方法模式设计后，代码的复用性更强，但是因为子类修改了父类的方法的实现，有悖里氏替换原则，因此在选择时需要根据具体场景进行分析。&lt;/p&gt;\n&lt;h2 id=\&#34;策略模式\&#34;&gt;策略模式&lt;/h2&gt;\n&lt;p&gt;策略模式核心原则是定义一系列算法，将每个算法独立封装，使用者可以灵活的进行选择替换。&lt;/p&gt;\n&lt;p&gt;例如现实生活中到某地的出行方式有很多种，可以灵活选择：出租车、公交车、地铁、自行车等，需要根据路程远近和交通状况灵活的选择，这就是一种策略模式。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-2\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;protocol Transport {\n    func toDestination()\n}\nclass Taxi: Transport {\n    func toDestination() {\n        print(&amp;quot;出租车&amp;quot;)\n    }\n}\nclass Bus: Transport {\n    func toDestination() {\n        print(&amp;quot;公交车&amp;quot;)\n    }\n}\nclass Subway: Transport {\n    func toDestination() {\n        print(&amp;quot;地铁&amp;quot;)\n    }\n}\nclass Action {\n    var destination: String\n    var transport: Transport\n    init(destination: String, transport: Transport) {\n        self.destination = destination\n        self.transport = transport\n    }\n    func go() {\n        self.transport.toDestination()\n    }\n}\nlet action = Action(destination: &amp;quot;北京&amp;quot;, transport: Subway())\naction.go()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过策略模式，不同的Action对象调用go方法很容易根据场景实现不同的行为。&lt;/p&gt;\n&lt;h2 id=\&#34;命令模式\&#34;&gt;命令模式&lt;/h2&gt;\n&lt;p&gt;命令模式的核心是将请求封装为对象，使得请求的发起与执行分开，发起方和执行方通过命令进行交互。&lt;br&gt;\n以教务系统为例，&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;struct Teacher {\n    var name: String\n    var subject: String\n    func log() {\n        print(&amp;quot;\\(name) + \\(subject)&amp;quot;)\n    }\n}\nclass School {\n    var teachers = [Teacher]()\n    func addTeacher(name: String, subject: String) {\n        teachers.append(Teacher(name: name, subject: subject))\n    }\n    func deleteTeacher(name: String) {\n        teachers = teachers.filter {$0.name != name}\n    }\n    func show() {\n        for teacher in teachers {\n            teacher.log()\n        }\n    }\n}\nlet school = School()\nschool.addTeacher(name: &amp;quot;学伟&amp;quot;, subject: &amp;quot;计算机&amp;quot;)\nschool.addTeacher(name: &amp;quot;张三&amp;quot;, subject: &amp;quot;体育&amp;quot;)\nschool.addTeacher(name: &amp;quot;李四&amp;quot;, subject: &amp;quot;数学&amp;quot;)\nschool.show()\nschool.deleteTeacher(name: &amp;quot;李四&amp;quot;)\nschool.show()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中，&lt;code&gt;School&lt;/code&gt; 提供了展示所有教师信息的方法，也提供了添加和删除教师的方法，通过这种方式对教师的操作难以维护，可以使用命令模式对其重构，将添加和删除教师、展示所有教师的逻辑都封装成一种命令。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-3\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;struct Teacher {\n    var name: String\n    var subject: String\n    func log() {\n        print(&amp;quot;\\(name) + \\(subject)&amp;quot;)\n    }\n}\nclass SchoolCommand {\n    enum ActionType {\n        case add\n        case delete\n        case show\n    }\n    var type: ActionType\n    var name: String?\n    var subject: String?\n    init(type: ActionType, name: String? = nil, subject: String? = nil) {\n        self.type = type\n        self.name = name\n        self.subject = subject\n    }\n}\nclass School {\n    var teachers = [Teacher]()\n    func runCommand(command: SchoolCommand) {\n        switch command.type {\n        case .add:\n            addTeacher(name: command.name!, subject: command.subject!)\n        case .delete:\n            deleteTeacher(name: command.name!)\n        case .show:\n            show()\n        }\n    }\n    private func addTeacher(name: String, subject: String) {\n        teachers.append(Teacher(name: name, subject: subject))\n    }\n    private func deleteTeacher(name: String) {\n        teachers = teachers.filter {$0.name != name}\n    }\n    private func show() {\n        for teacher in teachers {\n            teacher.log()\n        }\n    }\n}\nlet school = School()\nschool.runCommand(command: SchoolCommand(type: .add, name: &amp;quot;学伟&amp;quot;, subject: &amp;quot;计算机&amp;quot;))\nschool.runCommand(command: SchoolCommand(type: .add, name: &amp;quot;张三&amp;quot;, subject: &amp;quot;体育&amp;quot;))\nschool.runCommand(command: SchoolCommand(type: .add, name: &amp;quot;李四&amp;quot;, subject: &amp;quot;数学&amp;quot;))\nschool.runCommand(command: SchoolCommand(type: .show))\nschool.runCommand(command: SchoolCommand(type: .delete,name: &amp;quot;李四&amp;quot;))\nschool.runCommand(command: SchoolCommand(type: .show))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用命令模式重构后，对于 &lt;code&gt;School&lt;/code&gt; 的操作都通过 命令 &lt;code&gt;SchoolCommand&lt;/code&gt; 触发，代码扩展性更强，且命令可以作为对象直接被存储、传输、重复和撤销，在某些场景下会非常有用。&lt;/p&gt;\n&lt;h2 id=\&#34;职责链模式\&#34;&gt;职责链模式&lt;/h2&gt;\n&lt;p&gt;一个请求被发出，从低层向高层依次寻找可以处理此请求的对象，直到找到处理者才结束责任链。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-4\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;struct Requet {\n    enum Level {\n        case low\n        case middle\n        case high\n    }\n    var level: Level\n}\nprotocol Handler {\n    var nextHandler: Handler? { get }\n    func handlerRequest(request: Requet)\n    func nextHanderDo(request: Requet)\n}\nextension Handler {\n    func nextHanderDo(request: Requet) {\n        if let nextHandler = nextHandler {\n            nextHandler.handlerRequest(request: request)\n        } else {\n            print(&amp;quot;无法处理请求&amp;quot;)\n        }\n    }\n}\nclass HighHandler: Handler {\n    var nextHandler: Handler? = nil\n    func handlerRequest(request: Requet) {\n        if request.level == .high {\n            print(&amp;quot;HighHandler 处理请求&amp;quot;)\n        } else {\n            nextHanderDo(request: request)\n        }\n    }\n}\nclass MiddleHandler: Handler {\n    var nextHandler: Handler? = HighHandler()\n    func handlerRequest(request: Requet) {\n        if request.level == .middle {\n            print(&amp;quot;MiddleHandler 处理请求&amp;quot;)\n        } else {\n            nextHanderDo(request: request)\n        }\n    }\n}\nclass LowHandler: Handler {\n    var nextHandler: Handler? = MiddleHandler()\n    func handlerRequest(request: Requet) {\n        if request.level == .low {\n            print(&amp;quot;LowHandler 处理请求&amp;quot;)\n        } else {\n            nextHanderDo(request: request)\n        }\n    }\n}\nclass Chain: Handler {\n    var nextHandler: Handler? = LowHandler()\n    func handlerRequest(request: Requet) {\n        nextHandler?.handlerRequest(request: request)\n    }\n}\nvar request = Requet(level: .low)\nChain().handlerRequest(request: request)\nrequest = Requet(level: .middle)\nChain().handlerRequest(request: request)\nrequest = Requet(level: .high)\nChain().handlerRequest(request: request)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;外界只需传入指定等级的请求，责任链内部即可根据等级选择相应的处理逻辑。&lt;/p&gt;\n&lt;p&gt;责任链模式的核心是将请求发送到责任链上，链上的每一个处理者可以根据实际情况决定是否处理此请求，如果不能处理则将请求继续向上发送，直到被某个处理者处理或者没有处理者为止。这种结构可以灵活地向责任链中增加或删除处理者，对于不同种类的请求，发出方只需要将其发送到责任链上，不需要关心具体被哪一个处理者处理。降低了对象间的耦合性，并且使责任的分担更加清晰。&lt;/p&gt;\n&lt;h2 id=\&#34;状态模式\&#34;&gt;状态模式&lt;/h2&gt;\n&lt;p&gt;状态模式的核心是：当控制一个对象行为的状态转换过于复杂时，把状态处理的逻辑分离出到单独的状态类中。&lt;br&gt;\n在软件设计中，对象在不同的情况下会表现出不同的行为，被称为有状态的对象。影响对象行为的属性被称为状态，影响对象行为的属性被称为状态。对有状态的对象进行编程时，使用状态设计模式可以使代码的内聚性更强。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-5\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class StateContent {\n    var currentState: State\n    init(_ currentState: State) {\n        self.currentState = currentState\n    }\n    func changeState(curState: State) {\n        self.currentState = curState\n    }\n}\nprotocol State {\n    func info()\n    func doAction(content: StateContent)\n}\nclass Open: State {\n    func info() {\n        print(&amp;quot;开灯&amp;quot;)\n    }\n    func doAction(content: StateContent) {\n        content.currentState = Open()\n    }\n}\nclass Close: State {\n    func info() {\n        print(&amp;quot;关灯&amp;quot;)\n    }\n    func doAction(content: StateContent) {\n        content.currentState = Close()\n    }\n}\nclass LightButton {\n    var stateContent: StateContent\n    init(state: State) {\n        self.stateContent = StateContent(state)\n    }\n    func change(state: State) {\n        self.stateContent.changeState(curState: state)\n    }\n    func log() {\n        stateContent.currentState.info()\n    }\n}\nlet light = LightButton(state: Close())\nlight.log()\nlight.change(state: Open())\nlight.log()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中 &lt;code&gt;StateContent&lt;/code&gt; 定义了状态的上下文，用来维护当前开关的状态。而 &lt;code&gt;Open&lt;/code&gt; 、&lt;code&gt;Close&lt;/code&gt; 则是对状态的封装。&lt;/p&gt;\n&lt;h2 id=\&#34;观察者模式\&#34;&gt;观察者模式&lt;/h2&gt;\n&lt;p&gt;观察者模式又被称为发布-订阅模式，在观察者模式中，一个对象发生变化会通知到所有依赖它的对象，依赖它的对象可以根据情况进行自身行为的更改。&lt;br&gt;\n在iOS开发中，通知中心和键值监听系统的实现都使用了观察者模式。如下代码通过实现一个简易的通知中心演示观察者模式&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-6\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;typealias XWNotificationCallback = (XWNotification) -&amp;gt; Void\nstruct XWNotification {\n    var name: String\n    var data: String\n    var object: AnyObject?\n    func info() {\n        print(&amp;quot;name: \\(name), data: \\(data), object: \\(String(describing: object))&amp;quot;)\n    }\n}\nstruct XWObsever {\n    var object: AnyObject\n    var callback: XWNotificationCallback\n}\nclass XWNotificationCenter {\n    static let shared = XWNotificationCenter()\n    private var observers = Dictionary&amp;lt;String, Array&amp;lt;XWObsever&amp;gt;&amp;gt;()\n    private init() {}\n    func addObserver(name: String, object: AnyObject, callback: @escaping XWNotificationCallback) {\n        let observer = XWObsever(object: object, callback: callback)\n        if var curObserver = observers[name] {\n            curObserver.append(observer)\n        } else {\n            observers[name] = [observer]\n        }\n    }\n    func removeObserver(name: String) {\n        observers.removeValue(forKey: name)\n    }\n    func postNotification(notification: XWNotification) {\n        if let array = observers[notification.name] {\n            var postNotification = notification\n            for observer in array {\n                postNotification.object = observer.object\n                observer.callback(postNotification)\n            }\n        }\n    }\n}\nlet key = &amp;quot;KEY&amp;quot;\nXWNotificationCenter.shared.addObserver(name: key, object: &amp;quot;监听者A&amp;quot; as AnyObject) { noti in\n    noti.info()\n}\n//XWNotificationCenter.shared.removeObserver(name: key)\nXWNotificationCenter.shared.postNotification(notification: XWNotification(name: key, data: &amp;quot;通知内容&amp;quot;))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以上就是一个简易通知中心的实现，当添加了监听之后，一旦通知被发出，回调方法就会立刻执行，对于相同名称的通知，可以添加多个观察者。&lt;/p&gt;\n&lt;h2 id=\&#34;中介者模式\&#34;&gt;中介者模式&lt;/h2&gt;\n&lt;p&gt;中介者模式的核心是将网状的对象交互结构改为星形结构，即所有的对象都与一个中介者进行交互。使用中介者模式可以使原本耦合性很强的对象间的耦合变得松散，提高系统的灵活性和扩展性。&lt;/p&gt;\n&lt;p&gt;如下代码演示了网状的对象交互结构&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class ServerA {\n    func handleClientA() {\n        print(&amp;quot;ServerA 处理 ClientA 的请求&amp;quot;)\n    }\n    func handleClientB() {\n        print(&amp;quot;ServerA 处理 ClientB 的请求&amp;quot;)\n    }\n}\nclass ServerB {\n    func handleClientA() {\n        print(&amp;quot;ServerB 处理 ClientA 的请求&amp;quot;)\n    }\n    func handleClientB() {\n        print(&amp;quot;ServerB 处理 ClientB 的请求&amp;quot;)\n    }\n}\nclass ClientA {\n    func requestServerA() {\n        ServerA().handleClientA()\n    }\n    func requestServerB() {\n        ServerB().handleClientA()\n    }\n}\nclass ClientB {\n    func requestServerA() {\n        ServerA().handleClientB()\n    }\n    func requestServerB() {\n        ServerB().handleClientB()\n    }\n}\nlet clientA = ClientA()\nclientA.requestServerA()\nclientA.requestServerB()\nlet clientB = ClientB()\nclientB.requestServerA()\nclientB.requestServerB()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如上所述，两个客户端可以分别与服务端进行交互，有时客户端也可以点对点的与另外的客户端进行交互，这样会使系统的结构更加复杂，可以通过中介者模式统一客户端与服务端的交互逻辑&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-7\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class ServerA {\n    func handleClientA() {\n        print(&amp;quot;ServerA 处理 ClientA 的请求&amp;quot;)\n    }\n    func handleClientB() {\n        print(&amp;quot;ServerA 处理 ClientB 的请求&amp;quot;)\n    }\n}\nclass ServerB {\n    func handleClientA() {\n        print(&amp;quot;ServerB 处理 ClientA 的请求&amp;quot;)\n    }\n    func handleClientB() {\n        print(&amp;quot;ServerB 处理 ClientB 的请求&amp;quot;)\n    }\n}\nclass ClientA {}\nclass ClientB {}\nclass Mediator {\n    static func handler(client: AnyObject, server: AnyObject) {\n        if client is ClientA {\n            if server is ServerA {\n                ServerA().handleClientA()\n            } else {\n                ServerB().handleClientA()\n            }\n        } else {\n            if server is ServerA {\n                ServerA().handleClientB()\n            } else {\n                ServerB().handleClientB()\n            }\n        }\n    }\n}\nlet clientA = ClientA()\nlet clientB = ClientB()\nlet serverA = ServerA()\nlet serverB = ServerB()\nMediator.handler(client: clientA, server: serverA)\nMediator.handler(client: clientA, server: serverB)\nMediator.handler(client: clientB, server: serverA)\nMediator.handler(client: clientB, server: serverB)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;重构后客户端相关类中无须知道服务端具体的实现细节，中介者统一封装了这些逻辑。&lt;/p&gt;\n&lt;h2 id=\&#34;迭代器模式\&#34;&gt;迭代器模式&lt;/h2&gt;\n&lt;p&gt;软件设计中，很多对象都是以聚合的方式组成的，或者其内部包含集合类型的数据，在访问对象时，通常需要通过遍历的方式获取到其中的各个元素。这样，如果对象内部组合的方式产生了变化就必须对源码进行修改。&lt;/p&gt;\n&lt;p&gt;迭代器模式的核心是提供一个对象来访问聚合对象中的一系列数据，不暴露聚合对象内部的具体实现，这样即保证了类的安全性，也将内部的集合遍历逻辑与聚合对象本身进行了分离。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-8\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;protocol Iterator {\n    associatedtype ObjectType\n    var cursor: Int { get }\n    func next() -&amp;gt; ObjectType?\n    func reset()\n}\nclass School: Iterator {\n    private var teachers = [String]()\n    typealias ObjectType = String\n    var cursor: Int = 0\n    func next() -&amp;gt; String? {\n        if cursor &amp;lt; teachers.count {\n            let teacher = teachers[cursor]\n            cursor += 1\n            return teacher\n        } else {\n            return nil\n        }\n    }\n    \n    func reset() {\n        cursor = 0\n    }\n    \n    func addTeacher(name: String) {\n        teachers.append(name)\n    }\n}\nlet school = School()\nschool.addTeacher(name: &amp;quot;学伟&amp;quot;)\nschool.addTeacher(name: &amp;quot;小王&amp;quot;)\nschool.addTeacher(name: &amp;quot;乔布斯&amp;quot;)\nwhile let teacher = school.next() {\n    print(teacher)\n}\nprint(&amp;quot;遍历完成&amp;quot;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;外界对 &lt;code&gt;School&lt;/code&gt; 内部的数组是不感知的，使用迭代器模式可以很好的对内部实现进行封闭，外部除了通过类中暴露的函数来操作 teachers 数组外，不能直接操作。&lt;br&gt;\n在&lt;code&gt;Swift&lt;/code&gt;标准库中，可以直接使用官方迭代器协议 &lt;code&gt;IteratorProtocol&lt;/code&gt; 。&lt;/p&gt;\n&lt;h2 id=\&#34;访问者模式\&#34;&gt;访问者模式&lt;/h2&gt;\n&lt;p&gt;当数据的类型固定，但对其访问的操作相对灵活时，可以采用访问者模式对软件系统进行设计。访问者模式的核心是将数据的处理方式从数据结构中分离出来，之后可以方便地对数据的处理方法进行扩展。&lt;br&gt;\n举一个现实生活中应用访问者模式的例子：作为一种数据，不同的角色对其访问会有不同的行为表现，对于景区门票这一数据，作为游客需要购买，作为验票员需要验票，这种场景：&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-9\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;struct Ticket {\n    var name: String\n}\nprotocol Visitor {\n    func visit(ticket: Ticket)\n}\nclass Tourist: Visitor {\n    func visit(ticket: Ticket) {\n        print(&amp;quot;游客购买\\(ticket.name)&amp;quot;)\n    }\n}\nclass Guard: Visitor {\n    func visit(ticket: Ticket) {\n        print(&amp;quot;检票员检查了\\(ticket.name)&amp;quot;)\n    }\n}\nlet ticket = Ticket(name: &amp;quot;公园门票&amp;quot;)\nlet tourist = Tourist()\ntourist.visit(ticket: ticket)\nlet guarder = Guard()\nguarder.visit(ticket: ticket)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如上，不同角色对门票的操作分别封装在了独立的类中，这使之后新增行为变得非常容易，例如财务人员对门票价格进行核对等。&lt;/p&gt;\n&lt;h2 id=\&#34;备忘录模式\&#34;&gt;备忘录模式&lt;/h2&gt;\n&lt;p&gt;备忘录模式的定义：在不破坏封装性的前提下，对一个对象的状态进行保存，在需要时，可以方便地恢复到原来保存的状态，备忘录模式又被称为快照模式。&lt;br&gt;\n从功能上讲，备忘录模式与命令模式有许多相似之处，都是提供了一种恢复状态的机制；不同的是，命令模式是将操作封装成命令，命令可以回滚，备忘录模式则是存储对象某一时刻的状态，可以将状态进行重置。&lt;br&gt;\n例如，很多应用都提供了用户自定义偏好设置的功能，偏好设置的保存与重置可以采用备忘录模式实现。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-10\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;protocol MementoProtocol {\n    func allKeys() -&amp;gt; [String]\n    func valueForKey(key: String) -&amp;gt; Any\n    func setValue(value: Any, key: String)\n}\nclass Setting: MementoProtocol {\n    var setting1 = false\n    var setting2 = false\n    func allKeys() -&amp;gt; [String] {\n        return [&amp;quot;setting1&amp;quot;, &amp;quot;setting2&amp;quot;]\n    }\n    \n    func valueForKey(key: String) -&amp;gt; Any {\n        switch key {\n        case &amp;quot;setting1&amp;quot;:\n            return setting1\n        case &amp;quot;setting2&amp;quot;:\n            return setting2\n        default:\n            return &amp;quot;&amp;quot;\n        }\n    }\n    \n    func setValue(value: Any, key: String) {\n        switch key {\n        case &amp;quot;setting1&amp;quot;:\n            setting1 = value as? Bool ?? false\n        case &amp;quot;setting2&amp;quot;:\n            setting2 = value as? Bool ?? false\n        default:\n            print(&amp;quot;key: \\(key) 设置错误&amp;quot;)\n        }\n    }\n    func show() {\n        print(&amp;quot;setting1: \\(setting1) ++ setting2: \\(setting2)&amp;quot;)\n    }\n}\nclass MementoManager {\n    var dictionary = [String: [String: Any]]()\n    func saveState(obj: MementoProtocol, stateName: String) {\n        var dict = [String: Any]()\n        for key in obj.allKeys() {\n            dict[key] = obj.valueForKey(key: key)\n        }\n        dictionary[stateName] = dict\n    }\n    func resetState(obj: MementoProtocol, stateName: String) {\n        if let dict = dictionary[stateName] {\n            for kv in dict {\n                obj.setValue(value: kv.value, key: kv.key)\n            }\n        }\n    }\n}\nvar setting = Setting()\nlet manager = MementoManager()\nsetting.setting1 = true\nsetting.setting2 = true\nmanager.saveState(obj: setting, stateName: &amp;quot;vip&amp;quot;)\nsetting.setting2 = false\nmanager.saveState(obj: setting, stateName: &amp;quot;super&amp;quot;)\nsetting.show()\nmanager.resetState(obj: setting, stateName: &amp;quot;vip&amp;quot;)\nsetting.show()\nmanager.resetState(obj: setting, stateName: &amp;quot;super&amp;quot;)\nsetting.show()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;MementoManager&lt;/code&gt; 是一个快照管理类，可以将任何符合 &lt;code&gt;MementoProtocol&lt;/code&gt; 协议的对象进行快照保存。一个对象可以保存多个快照，在需要时可以方便地恢复到某个快照。有存档机制的软件可以按照备忘录设计模式的思路实现。&lt;/p&gt;\n&lt;h2 id=\&#34;解释器模式\&#34;&gt;解释器模式&lt;/h2&gt;\n&lt;p&gt;定义一种简洁的语言，通过实现一个解释器来对语言进行解析，从而实现逻辑。&lt;br&gt;\n正则表达式和iOS开发中用于自动布局的 VFL（Visual Format Language）是对解释器模式的应用。&lt;/p&gt;\n&lt;p&gt;例如，在软件中的页面路由跳转可以采用解释器模式进行设计。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-11\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class Interpreter {\n    static func handler(string: String) {\n        let proto = string.components(separatedBy: &amp;quot;://&amp;quot;)\n        if let pro = proto.first {\n            print(&amp;quot;路由协议: \\(pro)&amp;quot;)\n            if proto.count &amp;gt; 1, let last = proto.last {\n                let path = last.split(separator: &amp;quot;?&amp;quot;, maxSplits: 2, omittingEmptySubsequences: true)\n                if let pathFirst = path.first {\n                    print(&amp;quot;路由路径: \\(pathFirst)&amp;quot;)\n                    if path.count &amp;gt; 1, let param = path.last {\n                        print(&amp;quot;路由参数: \\(param)&amp;quot;)\n                    }\n                }\n            }\n        }\n    }\n}\nInterpreter.handler(string: &amp;quot;http://www.xxx.com?key=value&amp;quot;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此类用于解析某逻辑的设计模式即解释器模式的应用。&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;模板方法模式：定义算法骨架的前提下允许对关键环节的算法实现做修改&lt;/li&gt;\n&lt;li&gt;策略模式：定义一系列方便切换的算法实现&lt;/li&gt;\n&lt;li&gt;命令模式：将操作封装为命令对象&lt;/li&gt;\n&lt;li&gt;责任链模式：通过责任链对请求进行处理，隐藏处理请求的对象细节&lt;/li&gt;\n&lt;li&gt;状态模式：将变化的属性封装为状态对象进行统一管理&lt;/li&gt;\n&lt;li&gt;观察者模式：通过监听的方式处理对象间的交互逻辑&lt;/li&gt;\n&lt;li&gt;中介者模式：通过定义中介者来将网状结构的逻辑改为星状结构&lt;/li&gt;\n&lt;li&gt;迭代器模式：提供一种访问对象内部集合数据的接口&lt;/li&gt;\n&lt;li&gt;访问者模式：将数据的操作与数据本身分离&lt;/li&gt;\n&lt;li&gt;备忘录模式：通过快照的方式存储对象的状态&lt;/li&gt;\n&lt;li&gt;解释器模式：通过编写解释器对自定义的简单语言进行解析，从而实现逻辑&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;she-ji-mo-shi-xing-wei-xing&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;设计模式-行为型\&#34;&gt;设计模式-行为型&lt;/h1&gt;\n&lt;p&gt;行为型设计模式主要用于软件运行时复杂的流程控制。包含：模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式和解释器模式&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;设计模式-行为型&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-02-24 12:52:46&#34;,&#34;dateFormat&#34;:&#34;2023-02-24&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/she-ji-mo-shi-xing-wei-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;18 min read&#34;,&#34;time&#34;:1072000,&#34;words&#34;:4158,&#34;minutes&#34;:18},&#34;description&#34;:&#34;设计模式-行为型\n行为型设计模式主要用于软件运行时复杂的流程控制。包含：模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式和解释器模式\n\n模板方法模式\n在软件设计时，很多时候系...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B\&#34;&gt;设计模式-行为型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\&#34;&gt;模板方法模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\&#34;&gt;策略模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-2\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\&#34;&gt;命令模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-3\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F\&#34;&gt;职责链模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-4\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\&#34;&gt;状态模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-5\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\&#34;&gt;观察者模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-6\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\&#34;&gt;中介者模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-7\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\&#34;&gt;迭代器模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-8\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\&#34;&gt;访问者模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-9\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\&#34;&gt;备忘录模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-10\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\&#34;&gt;解释器模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-11\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;设计模式-结构型\&#34;&gt;设计模式-结构型&lt;/h1&gt;\n&lt;p&gt;结构型设计模式包含：代理模式、适配器模式、桥接模式、装饰模式、外观设计模式、享元模式、组合模式&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;代理模式\&#34;&gt;代理模式&lt;/h2&gt;\n&lt;p&gt;核心是在具体的功能类与使用者之间建立一个中介类作为代理，使用者通过代理对象对真实的功能类进行访问。&lt;br&gt;\n在iOS开发中，代理设计模式非常有用，在UIKit框架中，&lt;code&gt;UITableView&lt;/code&gt; 和 &lt;code&gt;UITextView&lt;/code&gt; 等组件的渲染和交互都采用了代理设计模式。&lt;/p&gt;\n&lt;p&gt;以病人预约看病的软件设计举例，核心功能类只有两个医生类和病人类，病人看病前首先预约，预约完成后问诊，医生陈述病情，然后开药。整个系统中有些行为既不属于病人类也不属于医生类，如医生的预约和问诊过程的控制等，这时就需要一个代理类代理医生处理这些行为。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class Patient {\n    func describeCondition() -&amp;gt; String {\n        let describe = &amp;quot;描述病情&amp;quot;\n        print(describe)\n        return describe\n    }\n}\nclass Doctor {\n    func writPrescription(condition: String) -&amp;gt; String {\n        let prescription = &amp;quot;依据病情: \\(condition), 开的处方&amp;quot;\n        print(prescription)\n        return prescription\n    }\n}\nclass DoctorProxy {\n    var patient: Patient\n    init(patient: Patient) {\n        self.patient = patient\n    }\n    func seeDoctor() {\n        // 预约医生\n        let doctor = reservation()\n        // 病人描述病情\n        let condition = self.patient.describeCondition()\n        // 医生开处方\n        doctor.writPrescription(condition: condition)\n    }\n    func reservation() -&amp;gt; Doctor {\n        let doctor = Doctor()\n        print(&amp;quot;预约医生&amp;quot;)\n        return doctor\n    }\n}\nlet patient = Patient()\nlet doctorProxy = DoctorProxy(patient: patient)\ndoctorProxy.seeDoctor()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中，病人并没有和医生进行直接交互，而是通过中间的代理类 &lt;code&gt;DoctorProxy&lt;/code&gt;。实际开发中，使用代理设计模式可以使具体的功能类的聚合性更强，并可以在某些功能的执行前后进行额外的准备工作和善后工作。&lt;/p&gt;\n&lt;h2 id=\&#34;适配器模式\&#34;&gt;适配器模式&lt;/h2&gt;\n&lt;p&gt;适配器模式并不是软件设计中的最佳实践，其主要为了解决软件开发过程中新旧模块不兼容的问题。其定义：将一个类的接口转换成使用者期望的另外接口，使得原本接口不兼容的类可以一起工作。&lt;/p&gt;\n&lt;p&gt;当数据模型版本升级时，可以使用适配器模式兼容旧的数据模型&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-2\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class User {\n    var name: String\n    var age: Int\n}\nclass UserV2 {\n    var nickName: String\n    var age: Int\n    var address: String\n}\nclass UserAdapter {\n    static func toUserV2(user: User) -&amp;gt; UserV2 {\n        return UserV2(nickName: user.name, age: user.age, address: &amp;quot;&amp;quot;)\n    }\n}\nlet user = User(name: &amp;quot;学伟&amp;quot;, age: 18)\nlet userV2 = UserAdapter.toUserV2(user: user)\nprint(userV2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;实际开发中，由于数据模型升级造成的代码不兼容问题会经常遇到，当项目过于庞大时，如果贸然修改以往的旧代码，会有很大的工作量，同时也会伴随很大的风险，使用适配器模式就是一种比较适合的折中选择。&lt;/p&gt;\n&lt;h2 id=\&#34;桥接模式\&#34;&gt;桥接模式&lt;/h2&gt;\n&lt;p&gt;桥接模式是合成复用原则的一种应用，其核心是将抽象与实现分离，用组合来代替继承关系，从而给类更多的扩展性，降低类之间的耦合度。&lt;br&gt;\n实际开发中，当某个类具有多维度的属性时，在组织类的结构时，使用桥接模式十分适合。&lt;br&gt;\n例如：汽车从功能上分为轿车和卡车，颜色上又分为黑色白色。在设计时有两种设计方案：一种是创建轿车和卡车的类，每个类包含颜色属性：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;enum Color {\n    case red\n    case green\n}\nclass Car {\n    var color: Color\n}\nclass Saloon: Car {\n    print(&amp;quot;我是轿车&amp;quot;)\n}\nclass Truck: Car {\n    print(&amp;quot;我是卡车&amp;quot;)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;另外一种设计方案可以根据桥接模式，根据实际需要对功能和颜色进行组合。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-3\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;enum Color {\n    case red\n    case green\n}\nenum CarType {\n    case saloon\n    case truck\n    var name: String {\n        switch self {\n        case .saloon:\n            return &amp;quot;轿车&amp;quot;\n        case .truck:\n            return &amp;quot;卡车&amp;quot;\n        }\n    }\n}\nprotocol CarProtocol {\n    var color: Color { get }\n    var carType: CarType { get }\n    func log()\n}\nextension CarProtocol {\n    func log() {\n        print(&amp;quot;我是&amp;quot; + carType.name)\n    }\n}\nclass Car: CarProtocol {\n    var color: Color\n    var carType: CarType\n    init(color: Color, carType: CarType) {\n        self.color = color\n        self.carType = carType\n    }\n}\nlet car = Car(color: .red, carType: .saloon)\ncar.log()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过组合颜色和类型两个枚举来构建汽车对象，避免了因继承带来的耦合问题。&lt;/p&gt;\n&lt;h2 id=\&#34;装饰模式\&#34;&gt;装饰模式&lt;/h2&gt;\n&lt;p&gt;在不改变对象结构的情况下，为该对象增加一些功能。&lt;br&gt;\n类比现实生活中的：手机壳、壁画...&lt;/p&gt;\n&lt;p&gt;以为墙添加贴纸的逻辑设计为例：&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-4\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;protocol WallProtocol {\n    func printInfo()\n}\nclass Wall: WallProtocol {\n    func printInfo() {\n        print(&amp;quot;墙面&amp;quot;)\n    }\n}\nclass StickerDecorator: WallProtocol {\n    var wall: Wall\n    init(wall: Wall) {\n        self.wall = wall\n    }\n    func printInfo() {\n        print(&amp;quot;贴纸装饰&amp;quot;)\n        self.wall.printInfo()\n    }\n}\nlet wall = Wall()\nlet stickerDecorator = StickerDecorator(wall: wall)\nstickerDecorator.printInfo()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中 &lt;code&gt;StickerDecorator&lt;/code&gt; 即装饰器，也需要完整的实现功能类所实现的接口，这样才能不会改变被装饰对象的原始行为。&lt;br&gt;\n使用装饰模式可以理解成：为对象的行为进行扩展，只是相比较于继承，装饰模式更加灵活、类之间的耦合度也更低。同时，装饰模式可能由于过度设计而增加过多装饰器类，使系统复杂性变高。&lt;/p&gt;\n&lt;h2 id=\&#34;外观设计模式\&#34;&gt;外观设计模式&lt;/h2&gt;\n&lt;p&gt;在软件设计中，当一个系统的功能越来越强时，子模块会越来越多，应用端对系统的访问也会越来越复杂。这时可以通过提供一个外观类来统一处理这些交互，降低应用端使用的复杂性。&lt;br&gt;\n以客户购买商品流程的设计为例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;struct User {\n    var name: String\n}\nstruct Goods {\n    static func choseGoods(user: User) {\n        print(&amp;quot;\\(user.name)选择商品&amp;quot;)\n    }\n}\nstruct Cashier {\n    static func pay(user: User) {\n        print(&amp;quot;\\(user.name)付款&amp;quot;)\n    }\n}\nstruct Package {\n    static func packing(user: User) {\n        print(&amp;quot;\\(user.name)打包&amp;quot;)\n    }\n}\nlet user = User(name: &amp;quot;学伟&amp;quot;)\nGoods.choseGoods(user: user)\nCashier.pay(user: user)\nPackage.packing(user: user)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;User&lt;/code&gt;需要完成一个购物流程需要同时与 &lt;code&gt;Goods&lt;/code&gt; 、&lt;code&gt;Cashier&lt;/code&gt;、&lt;code&gt;Package&lt;/code&gt; 三个类进行交互。当每个模块都变得越来越复杂时，代码的扩展和维护将变得十分困难。&lt;br&gt;\n对于这样的场景，可以定义一个外观类来统一处理用户的购物逻辑。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-5\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;...\nstruct Store {\n    static func shop(user: User) {\n        Goods.choseGoods(user: user)\n        Cashier.pay(user: user)\n        Package.packing(user: user)\n    }\n}\nlet user = User(name: &amp;quot;学伟&amp;quot;)\nStore.shop(user: user)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中，&lt;code&gt;Store&lt;/code&gt; 起到外观的作用，顾客只需要与 &lt;code&gt;Store&lt;/code&gt; 一个类进行交互即可，&lt;/p&gt;\n&lt;h2 id=\&#34;享元模式\&#34;&gt;享元模式&lt;/h2&gt;\n&lt;p&gt;运用共享技术实现大量细粒度对象的复用，避免大量重复对象造成系统的资源开销。&lt;br&gt;\n在享元模式中，需要根据共享性将对象中的数据拆分成内部状态和外部状态，之后将内部状态封装成享元对象用户共享。享元模式会增加系统的复杂度，对于不会产生大量重复对象的系统并不适用。&lt;/p&gt;\n&lt;p&gt;以黑白棋设计为例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;struct Place {\n    var x: Int\n    var y: Int\n}\nenum Color {\n    case White\n    case Black\n}\nclass ChessPiece {\n    var place: Place\n    var color: Color\n    var radius: Double\n    init(place: Place, color: Color, radius: Double) {\n        self.place = place\n        self.color = color\n        self.radius = radius\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一个棋子除了位置不同外，颜色和半径对于大部分棋子来说是相同的，这种场景下，place 就是 外部状态，color与radius为内部状态，可以使用享元模式重构&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-6\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;struct Place {\n    var x: Int\n    var y: Int\n}\nenum Color {\n    case White\n    case Black\n}\nclass ChessPieceFlyweight {\n    var color: Color\n    var radius: Double\n    init(color: Color, radius: Double) {\n        self.color = color\n        self.radius = radius\n    }\n}\nclass ChessPieceFlyweightFactory {\n    static let white = ChessPieceFlyweight(color: .White, radius: 16.0)\n    static let black = ChessPieceFlyweight(color: .Black, radius: 16.0)\n    static func getChessPieceFlyweight(color: Color) -&amp;gt; ChessPieceFlyweight {\n        switch color {\n        case .White:\n            return white\n        case .Black:\n            return black\n        }\n    }\n}\nclass ChessPiece {\n    var place: Place\n    var chessPieceFlyweight: ChessPieceFlyweight\n    init(place: Place, color: Color) {\n        self.place = place\n        self.chessPieceFlyweight = ChessPieceFlyweightFactory.getChessPieceFlyweight(color: color)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;即便创建若干个棋子，真实的 ChessPieceFlyweight 只有两个，随着创建的个数越多，节省的内存也越多。&lt;/p&gt;\n&lt;h2 id=\&#34;组合模式\&#34;&gt;组合模式&lt;/h2&gt;\n&lt;p&gt;采用树状层级结构来表示部分与整体的关系，使得无论是整体对象还是单个对象，对其访问都具有一致性。&lt;br&gt;\n在面向对象设计思想中，完整的文件系统至少需要两个类来描述，文件夹和文件；文件系统实际就是树状层级结构，可以使用组合模式设计。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-7\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;enum NodeType {\n    case Folder\n    case File\n}\nprotocol FileNode {\n    var type: NodeType { get }\n    var name: String { get }\n    func addNode(node: FileNode)\n    func removeNode(node: FileNode)\n    func getAllNode() -&amp;gt; [FileNode]\n}\nclass file: FileNode {\n    var type: NodeType\n    var name: String\n    var child = [FileNode]()\n    init(type: NodeType, name: String) {\n        self.type = type\n        self.name = name\n    }\n    func addNode(node: FileNode) {\n        self.child.append(node)\n    }\n    \n    func removeNode(node: FileNode) {\n        self.child = self.child.filter({ n in\n            if node.name == n.name &amp;amp;&amp;amp; node.type == n.type {\n                return false\n            }\n            return true\n        })\n    }\n    \n    func getAllNode() -&amp;gt; [FileNode] {\n        return self.child\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过定义统一的 &lt;code&gt;FileNode&lt;/code&gt; 接口，使得使用方无论关心当前操作的节点是文件夹还是文件，都有统一的访问方式，而且屏蔽了树结构中层级的概念，这是组合模式最大的优势。&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;代理模式：使用中介处理对象间的交互&lt;/li&gt;\n&lt;li&gt;适配器模式：新旧接口不兼容时的安全处理方案&lt;/li&gt;\n&lt;li&gt;桥接模式：使用组合代替继承，将抽象与实现分离&lt;/li&gt;\n&lt;li&gt;装饰模式：不改变原始行为的前提下对类的功能进行扩展&lt;/li&gt;\n&lt;li&gt;外观模式：使用统一的外观接口处理类之间一对多的交互逻辑&lt;/li&gt;\n&lt;li&gt;享元模式：创建大量重复对象的优化方案&lt;/li&gt;\n&lt;li&gt;组合模式：部分与整体提供统一的功能接口&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;she-ji-mo-shi-jie-gou-xing&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;设计模式-结构型\&#34;&gt;设计模式-结构型&lt;/h1&gt;\n&lt;p&gt;结构型设计模式包含：代理模式、适配器模式、桥接模式、装饰模式、外观设计模式、享元模式、组合模式&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;设计模式-结构型&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-02-13 16:57:53&#34;,&#34;dateFormat&#34;:&#34;2023-02-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/she-ji-mo-shi-jie-gou-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:574000,&#34;words&#34;:2345,&#34;minutes&#34;:10},&#34;description&#34;:&#34;设计模式-结构型\n结构型设计模式包含：代理模式、适配器模式、桥接模式、装饰模式、外观设计模式、享元模式、组合模式\n\n代理模式\n核心是在具体的功能类与使用者之间建立一个中介类作为代理，使用者通过代理对象对真实的功能类进行访问。\n在iOS开发中...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B\&#34;&gt;设计模式-结构型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\&#34;&gt;代理模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\&#34;&gt;适配器模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-2\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\&#34;&gt;桥接模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-3\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F\&#34;&gt;装饰模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-4\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\&#34;&gt;外观设计模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-5\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\&#34;&gt;享元模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-6\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\&#34;&gt;组合模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-7\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;设计模式-创建型\&#34;&gt;设计模式-创建型&lt;/h1&gt;\n&lt;p&gt;创建型设计模式包含：单例模式、原型模式、工厂方法模式、抽象工厂模式、建造者模式&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;单例模式\&#34;&gt;单例模式&lt;/h2&gt;\n&lt;p&gt;单例模式在开发中也是最常见的一种设计模式之一，系统原生提供的很多类的设计都采用了单例模式，例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;FileManager.default\nUserDefaults.standard\nNotificationCenter.default\nUIApplication.shared\nURLSession.shared\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其目的是为了节省内存资源并保证数据内容的一致性，需要让某些类只能创建一个实例。单例模式有如下特点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;单例类只有一个实例对象&lt;/li&gt;\n&lt;li&gt;单例类的实例对象由自己创建&lt;/li&gt;\n&lt;li&gt;需要对外提供一个访问其实例对象的接口&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在软件设计中，有关全局共享的资源数据，大型通用的管理类等都可以使用单例模式，例如登录用户的用户信息类、全局的计时器、程序的日志管理类&lt;/p&gt;\n&lt;h3 id=\&#34;swift-单例\&#34;&gt;Swift 单例&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class ClassA {\n    static let share = ClassA()\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;objective-c-单例\&#34;&gt;Objective-C 单例&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;static XXClassManager *_defaultManager;\n+ (instancetype)shareInstance {\n    if (!_defaultManager) {\n        _defaultManager = [[self alloc] init];\n    }\n    return _defaultManager;\n}\n+ (instancetype)allocWithZone:(struct _NSZone *)zone {\n    if (!_defaultManager) {\n        static dispatch_once_t onceToken;\n        dispatch_once(&amp;amp;onceToken, ^{\n            _defaultManager = [super allocWithZone:zone];\n        });\n    }\n    return _defaultManager;\n}\n- (id)copyWithZone:(NSZone *)zone{\n    return _defaultManager;\n}\n- (id)mutableCopyWithZone:(NSZone *)zone{\n    return _defaultManager;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;原型模式\&#34;&gt;原型模式&lt;/h2&gt;\n&lt;p&gt;以一个已经创建的实例作为原型，通过复制该原型对象来创建出对象，在使用对象时，使用者无需关心对象创建的细节。在iOS开发中：&lt;code&gt;copy&lt;/code&gt; 方法就是对原型设计模式的一种实现。主要是提供了一种大量创建复杂对象的方法。&lt;/p&gt;\n&lt;h3 id=\&#34;重构前\&#34;&gt;重构前&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;import Foundation\nclass Computer {\n    var cpu: String\n    var host: String\n    var screen: String\n    var uuid: String\n    init(cpu: String, host: String, screen: String) {\n        self.cpu = cpu\n        self.host = host\n        self.screen = screen\n        self.uuid = UUID().uuidString\n    }\n    func logUUID() {\n        print(uuid)\n    }\n}\nlet computer1 = Computer(cpu: &amp;quot;Intel core i7 7700K&amp;quot;, host: &amp;quot;GY088-GDF-60&amp;quot;, screen: &amp;quot;3008 x 1692&amp;quot;)\ncomputer1.logUUID()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此时若希望创建一台相同配置的电脑则只能使用重复的创建方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;let computer2 = Computer(cpu: &amp;quot;Intel core i7 7700K&amp;quot;, host: &amp;quot;GY088-GDF-60&amp;quot;, screen: &amp;quot;3008 x 1692&amp;quot;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;重构后\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;import Foundation\nclass Computer {\n    ...\n    \n    func copy() -&amp;gt; Computer {\n        return Computer(cpu: self.cpu, host: self.host, screen: self.screen)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;新增一个 copy() 方法，此时再创建相同配置的电脑只需调用原型的 copy() 方法即可，省去了配件的创建过程。&lt;br&gt;\n使用原型模式，一旦第一个对象被创建，后面的对象创建都将变得非常容易。其中，作为模板对象被称为原型，创建出来的对象拥有和模板对象一致的属性和方法。&lt;/p&gt;\n&lt;h2 id=\&#34;工厂方法模式\&#34;&gt;工厂方法模式&lt;/h2&gt;\n&lt;p&gt;工厂方法设计模式注重于将对象的创建过程封闭起来，通过定义抽象的工厂接口和商品接口来隐藏负责对象创建的具体类&lt;/p&gt;\n&lt;p&gt;对上述 Computer 类进行重构&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-2\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;enum Level {\n    case low\n    case high\n}\nprotocol ComputerFactoryProtol {\n    static func getComputer(level: Level) -&amp;gt; ComputerProtol\n}\nprotocol ComputerProtol {\n    var cpu: String { get }\n    var host: String { get }\n    var screen: String { get }\n    var uuid: String { get }\n    func logUUID()\n}\nclass Computer: ComputerProtol {\n    var cpu: String\n    var host: String\n    var screen: String\n    var uuid: String\n    init(cpu: String, host: String, screen: String) {\n        self.cpu = cpu\n        self.host = host\n        self.screen = screen\n        self.uuid = UUID().uuidString\n    }\n    func logUUID() {\n        print(uuid)\n    }\n}\nclass ComputerFactory: ComputerFactoryProtol {\n    static func getComputer(level: Level) -&amp;gt; ComputerProtol {\n        switch level {\n        case .low:\n            return Computer(cpu: &amp;quot;Intel core i5 3300K&amp;quot;, host: &amp;quot;GY088-GDF-10&amp;quot;, screen: &amp;quot;1920 x 1080&amp;quot;)\n        case .high:\n            return Computer(cpu: &amp;quot;Intel core i7 7700K&amp;quot;, host: &amp;quot;GY088-GDF-60&amp;quot;, screen: &amp;quot;3008 x 1692&amp;quot;)\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;引入的 ComputerFactory 即工厂设计模式的具体体现，外界不再指明具体的配置信息，只需要根据 level 即可创建指定配置的 Computer，&lt;br&gt;\n创建高配电脑，例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;let computer3 = ComputerFactory.getComputer(level: .high)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果新增加了一种创建方式完全不同的计算机，我们只需要新建一个遵守 &lt;code&gt;ComputerProtol&lt;/code&gt; 的计算机类，之后在 &lt;code&gt;ComputerFactory&lt;/code&gt; 中统一处理这种新增的计算机类型即可，对使用者完全隐藏。&lt;/p&gt;\n&lt;h2 id=\&#34;抽象工厂模式\&#34;&gt;抽象工厂模式&lt;/h2&gt;\n&lt;p&gt;抽象工厂是对工厂模式的一种升级，核心思路是为各种类型的对象提供一组统一的创建接口，使用者无需关心这些对象具体是如何创建的。&lt;/p&gt;\n&lt;p&gt;还是上述代码，若我们工厂方法即生产 &lt;code&gt;Computer&lt;/code&gt; 又可以生产 &lt;code&gt;TV&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-3\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;enum Level {\n    case low\n    case high\n}\nprotocol ComputerFactoryProtol {\n    static func getComputer(level: Level) -&amp;gt; ComputerProtol\n    static func getTV() -&amp;gt; TVProtol\n}\nprotocol TVProtol {\n    var name: String { get }\n    func logName()\n}\nclass TV: TVProtol {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    func logName() {\n        print(self.name)\n    }\n}\nprotocol ComputerProtol {\n    ...\n}\nclass Computer: ComputerProtol {\n    ...    \n}\nclass ComputerFactory: ComputerFactoryProtol {\n    static func getTV() -&amp;gt; TVProtol {\n        return TV(name: &amp;quot;海尔&amp;quot;)\n    }\n    static func getComputer(level: Level) -&amp;gt; ComputerProtol {\n        ...\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;重构后工厂类可以创建不同的对象，对于使用者无需关心创建的细节，抽象工厂将对象的创建和使用进行了完全分离。&lt;/p&gt;\n&lt;h2 id=\&#34;建造者模式\&#34;&gt;建造者模式&lt;/h2&gt;\n&lt;p&gt;建造者模式用于复杂对象的创建，使代码聚合性更强，逻辑更加清晰。建造者模式通常与工程模式配合使用，工厂着重于对象的创建，建造者着重于创建复杂对象过程中组成对象的每一部分创建和最终组装。&lt;br&gt;\n核心在于将复杂的对象拆解成多个简单对象，通过一步步构建简单对象最终组合成复杂对象。&lt;/p&gt;\n&lt;h3 id=\&#34;重构后-4\&#34;&gt;重构后&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;enum Foodtype {\n    case a\n    case b\n}\nenum Drink {\n    case cola\n    case juice\n}\nenum Staple {\n    case hamburger\n    case chickenRoll\n}\nclass FoodPackage {\n    var drink: Drink?\n    var staple: Staple?\n}\nclass BuildA {\n    var foodPackage = FoodPackage()\n    func build() -&amp;gt; FoodPackage {\n        foodPackage.drink = .cola\n        foodPackage.staple = .hamburger\n        return foodPackage\n    }\n}\nclass BuildB {\n    var foodPackage = FoodPackage()\n    func build() -&amp;gt; FoodPackage {\n        foodPackage.drink = .juice\n        foodPackage.staple = .chickenRoll\n        return foodPackage\n    }\n}\nclass FoodFactory {\n    static func buildFood(type: Foodtype) -&amp;gt; FoodPackage {\n        switch type {\n        case .a:\n            return BuildA().build()\n        case .b:\n            return BuildB().build()\n        }\n    }\n}\nlet foodPackage = FoodFactory.buildFood(type: .a)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中，一个完整的套餐对象由饮料对象、主食对象组成，&lt;code&gt;FoodFactory&lt;/code&gt; 为工厂方法，其中根据套餐类型创建不同的套餐对象，具体的套餐对象的组成则是由 &lt;code&gt;BuildA&lt;/code&gt; 和 &lt;code&gt;BuildB&lt;/code&gt; 来完成。  &lt;code&gt;BuildA&lt;/code&gt; 和 &lt;code&gt;BuildB&lt;/code&gt; 是建造者模式的核心类，充当建造者的角色。&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;单例模式：全局共享数据的最佳实践&lt;/li&gt;\n&lt;li&gt;原型模式：快速复制对象的便捷途径&lt;/li&gt;\n&lt;li&gt;工厂方法模式：将对象的创建与使用进行隔离&lt;/li&gt;\n&lt;li&gt;抽象工厂模式：提供一组接口创建不同类别的产品的实现方法&lt;/li&gt;\n&lt;li&gt;建造者模式：拆分复杂对象为多个简单对象进行创建&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;she-ji-mo-shi-chuang-jian-xing&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;设计模式-创建型\&#34;&gt;设计模式-创建型&lt;/h1&gt;\n&lt;p&gt;创建型设计模式包含：单例模式、原型模式、工厂方法模式、抽象工厂模式、建造者模式&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;设计模式-创建型&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-02-06 17:27:51&#34;,&#34;dateFormat&#34;:&#34;2023-02-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/she-ji-mo-shi-chuang-jian-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:401000,&#34;words&#34;:1587,&#34;minutes&#34;:7},&#34;description&#34;:&#34;设计模式-创建型\n创建型设计模式包含：单例模式、原型模式、工厂方法模式、抽象工厂模式、建造者模式\n\n单例模式\n单例模式在开发中也是最常见的一种设计模式之一，系统原生提供的很多类的设计都采用了单例模式，例如：\nFileManager.defa...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B\&#34;&gt;设计模式-创建型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\&#34;&gt;单例模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#swift-%E5%8D%95%E4%BE%8B\&#34;&gt;Swift 单例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#objective-c-%E5%8D%95%E4%BE%8B\&#34;&gt;Objective-C 单例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\&#34;&gt;原型模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%89%8D\&#34;&gt;重构前&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\&#34;&gt;工厂方法模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-2\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\&#34;&gt;抽象工厂模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-3\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\&#34;&gt;建造者模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%90%8E-4\&#34;&gt;重构后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;设计模式-软件设计的7个原则\&#34;&gt;设计模式-软件设计的7个原则&lt;/h1&gt;\n&lt;h3 id=\&#34;概述\&#34;&gt;概述&lt;/h3&gt;\n&lt;p&gt;在软件开发时为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，通常要遵守一定的设计原则：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;开闭原则&lt;/li&gt;\n&lt;li&gt;里式替换原则&lt;/li&gt;\n&lt;li&gt;依赖倒置原则&lt;/li&gt;\n&lt;li&gt;单一职责原则&lt;/li&gt;\n&lt;li&gt;接口隔离原则&lt;/li&gt;\n&lt;li&gt;迪米特原则&lt;/li&gt;\n&lt;li&gt;合成复用原则&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;1-开闭原则\&#34;&gt;1. 开闭原则&lt;/h3&gt;\n&lt;p&gt;软件实体应当对扩展开放，对修改关闭。&lt;br&gt;\n开闭原则是软件设计的终极目标，对扩展开放可以使软件具有一定的灵活性，同时对修改关闭又可以保证软件的稳定性。使用开闭原则设计的软件有如下优势：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;测试方便。由于开闭原则对修改关闭，因此软件实体是拥有稳定性的，测试时只需要对扩展代码进行测试即可；&lt;/li&gt;\n&lt;li&gt;更好地提高代码复用性。开闭原则通常采用抽象接口的方式来组织代码结构，抽象的编程本身就是对代码的复用性提高有很大的帮助；&lt;/li&gt;\n&lt;li&gt;提高软件的维护性和扩展性。由于开闭原则对扩展开放，因此当软件需要升级时，可以很容易地通过扩展来实现新功能，开发效率更高，代码也更易于维护。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在面向对象开发中，实现开闭原则可以通过继承父类和实现接口两种方式。&lt;br&gt;\n在开闭原则中，一个类只应该因为错误而修改，新加入的功能都不应该修改原始代码。&lt;/p&gt;\n&lt;h4 id=\&#34;重构前的代码\&#34;&gt;重构前的代码&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;enum Color: String {\n    case unknown\n    case black\n    case white\n    case gray\n    case blue\n    case red\n}\nclass Style {\n    var backgroudColor = Color.black\n    var textColor = Color.white\n    func apply() {\n        print(&amp;quot;皮肤 - 背景色: \\(self.backgroudColor), 文字颜色: \\(self.textColor)&amp;quot;)\n    }\n}\nlet baseStyle = Style()\nbaseStyle.apply()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此时，如果有一个新需求增加一个背景色为灰色，文字颜色为蓝并且按钮颜色为红的主题，如何修改？并且需要遵守开闭原则&lt;/p&gt;\n&lt;h4 id=\&#34;继承\&#34;&gt;继承&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class Custom1Style: Style {\n    var buttonColor = Color.red\n    override init() {\n        super.init()\n        backgroudColor = .gray\n        textColor = .blue\n    }\n    override func apply() {\n        print(&amp;quot;皮肤 - 背景色: \\(self.backgroudColor), 文字颜色: \\(self.textColor), 按钮颜色: \\(self.buttonColor)&amp;quot;)\n    }\n}\nlet custom1Style = Custom1Style()\ncustom1Style.apply()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过继承方式实现开闭原则并不彻底，通过接口可以更好的实现开闭原则。&lt;/p&gt;\n&lt;h4 id=\&#34;接口\&#34;&gt;接口&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;protocol StyleInterface {\n    var backgroudColor: Color { get }\n    var textColor: Color { get }\n    var buttonColor: Color { get }\n    func apply()\n}\nextension StyleInterface {\n    var buttonColor: Color {\n        get {\n            return .unknown\n        }\n    }\n}\nclass BaseStyle: StyleInterface {\n    var backgroudColor: Color = .black\n    var textColor: Color = .white\n    func apply() {\n        print(&amp;quot;皮肤 - 背景色: \\(self.backgroudColor), 文字颜色: \\(self.textColor)&amp;quot;)\n    }\n}\nclass Custom2Style: StyleInterface {\n    var backgroudColor: Color = .gray\n    var textColor: Color = .blue\n    var buttonColor: Color = .red\n    func apply() {\n        print(&amp;quot;皮肤 - 背景色: \\(self.backgroudColor), 文字颜色: \\(self.textColor), 按钮颜色: \\(self.buttonColor)&amp;quot;)\n    }\n}\nlet baseStyle2 = BaseStyle()\nlet custom2Style = Custom2Style()\nbaseStyle2.apply()\ncustom2Style.apply()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;StyleInterface 协议定义了与主题相关的属性和方法，方法需要扩展多个主题时，需要对接口进行不同的实现即可。&lt;/p&gt;\n&lt;h3 id=\&#34;2-里式替换原则\&#34;&gt;2. 里式替换原则&lt;/h3&gt;\n&lt;p&gt;继承必须保证超类所拥有的性质在子类中依然成立。即：在进行类的继承时，要保证子类不对父类的属性或方法进行重写，只是扩展父类的功能。&lt;br&gt;\n如果在设计时发现子类不得不重写父类的方法，则表明类的组织结构有问题，需要重新设计类的继承关系，比如将被重写的方法从父类抽离，仅在需要的子类声明。&lt;/p&gt;\n&lt;h3 id=\&#34;3-单一职责原则\&#34;&gt;3. 单一职责原则&lt;/h3&gt;\n&lt;p&gt;一个类只应该承担一项责任，在实际设计中，可以以是否只有一个引起类变化的原因作为准则如果不止一个原因会引起类的变化，则需要对类重新进行拆分。&lt;br&gt;\n如果一个类或对象承担了太多的责任，则其中一个责任的变化可以带来对其他责任的影响，且不利于代码的复用性，容易造成代码的冗余，遵守单一职责设计的程序有以下几个特点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;降低类的复杂度，一个类承担单一的职责，逻辑清晰，提高内聚，降低耦合&lt;/li&gt;\n&lt;li&gt;提高代码可读性和可复用性&lt;/li&gt;\n&lt;li&gt;增强代码可维护性和可扩展性&lt;/li&gt;\n&lt;li&gt;类的变更是必然的，功能的增加必然会产生类的变更，单一职责可以使变更带来的影响最小。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;4-接口隔离原则\&#34;&gt;4. 接口隔离原则&lt;/h3&gt;\n&lt;p&gt;将庞大的接口定义拆分为更小的和更具体的接口，其“隔离”的主要是指对接口依赖的隔离。例如 &lt;code&gt;UITableView&lt;/code&gt; 的 &lt;code&gt;UITableViewDataSource&lt;/code&gt; 和 &lt;code&gt;UITableViewDelegate&lt;/code&gt;。定义的各个接口各司其职，尽量少耦合其他业务逻辑。&lt;/p&gt;\n&lt;h3 id=\&#34;5-依赖倒置原则\&#34;&gt;5. 依赖倒置原则&lt;/h3&gt;\n&lt;p&gt;高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。与 开闭原则 的核心思路相同，都是要尽量减少对已有代码的修改，同时又易于进行扩展。优势：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;由于都对接口进行依赖，减少了类之间的耦合&lt;/li&gt;\n&lt;li&gt;封闭了对类实现的修改，增强了程序的稳定性&lt;/li&gt;\n&lt;li&gt;核心是面向接口开发，减少了并行开发的依赖于风险&lt;/li&gt;\n&lt;li&gt;提高代码可读性和可维护性&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;重构前的代码：&lt;br&gt;\n如下代码即上层依赖下层：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class FoodStore {\n    func sell(count: Int) {\n        print(&amp;quot;食品商店卖了\\(count)食物&amp;quot;)\n    }\n}\nclass Customer {\n    func buy(store: FoodStore, count: Int) {\n        print(&amp;quot;购物--&amp;quot;)\n        store.sell(count: count)\n    }\n}\nlet customer = Customer()\ncustomer.buy(store: FoodStore(), count: 4)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当有新的商店出现时就需要更改上层的 &lt;code&gt;Customer&lt;/code&gt; 类。&lt;br&gt;\n使用依赖倒置的原则进行重构，使 &lt;code&gt;Customer&lt;/code&gt; 只对抽象的接口进行依赖。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;protocol Store {\n    func sell(count: Int)\n}\nclass FoodStore: Store {\n    func sell(count: Int) {\n        print(&amp;quot;食品商店卖了\\(count)食物&amp;quot;)\n    }\n}\nclass ClothStore: Store {\n    func sell(count: Int) {\n        print(&amp;quot;服装商店卖了\\(count)服装&amp;quot;)\n    }\n}\nclass Customer {\n    func buy(store: Store, count: Int) {\n        print(&amp;quot;购物--&amp;quot;)\n        store.sell(count: count)\n    }\n}\nlet customer = Customer()\ncustomer.buy(store: FoodStore(), count: 4)\ncustomer.buy(store: ClothStore(), count: 2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;重构后的 &lt;code&gt;Customer&lt;/code&gt; 不再依赖具体的 &lt;code&gt;Store&lt;/code&gt; ，扩展也不需要更改其内部实现。&lt;/p&gt;\n&lt;h3 id=\&#34;6-迪米特原则\&#34;&gt;6. 迪米特原则&lt;/h3&gt;\n&lt;p&gt;又叫 “最小知识原则”。核心为一个类或对象尽可能少地与其他实体发生交互作用。通常，我们不会对单独的类使用迪米特原则，这样做的解耦效果并不明显，但是如果是模块之间的交互通过一个中介类来统一处理，那就可以大大减少模块间的耦合程度，例如在iOS组件化开发中的路由器，可以将模块之间的耦合通过路由进行隔离，降低模块间的耦合。&lt;/p&gt;\n&lt;h3 id=\&#34;7-合成复用原则\&#34;&gt;7. 合成复用原则&lt;/h3&gt;\n&lt;p&gt;在设计类的复用时，要尽量先使用组合或聚合的方式设计，尽量少使用继承。合成复用原则通过组合和聚合的方式实现复用，实现上通常使用属性、参数的方式引入其他实体进行通信。&lt;br&gt;\n重构前的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class Teacher {\n    var name: String\n    init(_ name: String) {\n        self.name = name\n    }\n    func teach() {\n        print(&amp;quot;讲课&amp;quot;)\n    }\n}\nclass MathTeacher: Teacher {\n    override func teach() {\n        print(&amp;quot;\\(name)讲数学课&amp;quot;)\n    }\n}\nclass EnglishTeacher: Teacher {\n    override func teach() {\n        print(&amp;quot;\\(name)讲英语课&amp;quot;)\n    }\n}\nlet james = MathTeacher(&amp;quot;james&amp;quot;)\njames.teach()\nlet davis = EnglishTeacher(&amp;quot;davis&amp;quot;)\ndavis.teach()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;根据合成复用原则，不使用继承，把学科封装为Teacher的一个属性。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-swift\&#34;&gt;class Suject {\n    var name: String\n    init(_ name: String) {\n        self.name = name\n    }\n}\nclass Teacher {\n    var name: String\n    var subject: Suject\n    init(_ name: String, subject: String) {\n        self.name = name\n        self.subject = Suject(subject)\n    }\n    func teach() {\n        print(&amp;quot;\\(name)讲\\(subject.name)课&amp;quot;)\n    }\n}\nlet james = Teacher(&amp;quot;james&amp;quot;, subject: &amp;quot;数学&amp;quot;)\njames.teach()\nlet davis = Teacher(&amp;quot;davis&amp;quot;, subject: &amp;quot;英语&amp;quot;)\ndavis.teach()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;总结\&#34;&gt;总结&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;开闭原则是核心，在设计软件时保持扩展的开放性和修改的封闭性&lt;/li&gt;\n&lt;li&gt;里式替换原则要求在继承时不要破坏父类的实现&lt;/li&gt;\n&lt;li&gt;单一职责原则要求类的功能要单一&lt;/li&gt;\n&lt;li&gt;接口隔离原则要求接口的设计要精简&lt;/li&gt;\n&lt;li&gt;依赖倒置原则要求面向抽象编程，即面向接口编程&lt;/li&gt;\n&lt;li&gt;迪米特原则提供一种降低系统耦合性的方式&lt;/li&gt;\n&lt;li&gt;合成复用原则要求组织类的关系时谨慎使用继承&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;7种基本设计原则\&#34;&gt;7种基本设计原则&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;开闭原则：软件设计的终极目标，对扩展开放，对修改关闭&lt;/li&gt;\n&lt;li&gt;里式替换原则：子类可以扩展父类方法，但不能修改父类原有方法本身行为&lt;/li&gt;\n&lt;li&gt;依赖倒置原则：面向协议编程，尽量依赖抽象&lt;/li&gt;\n&lt;li&gt;单一职责原则：降低类的复杂度，一个类只负责一种职责&lt;/li&gt;\n&lt;li&gt;接口隔离原则：精简接口，一个接口只负责一类职责&lt;/li&gt;\n&lt;li&gt;迪米特原则：简化类之间的交互，使用中介者统一处理&lt;/li&gt;\n&lt;li&gt;合成复用原则：使用组合或聚合代理继承&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;she-ji-mo-shi-ruan-jian-she-ji-de-7-ge-yuan-ze&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;设计模式-软件设计的7个原则\&#34;&gt;设计模式-软件设计的7个原则&lt;/h1&gt;\n&lt;h3 id=\&#34;概述\&#34;&gt;概述&lt;/h3&gt;\n&lt;p&gt;在软件开发时为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，通常要遵守一定的设计原则：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;开闭原则&lt;/li&gt;\n&lt;li&gt;里式替换原则&lt;/li&gt;\n&lt;li&gt;依赖倒置原则&lt;/li&gt;\n&lt;li&gt;单一职责原则&lt;/li&gt;\n&lt;li&gt;接口隔离原则&lt;/li&gt;\n&lt;li&gt;迪米特原则&lt;/li&gt;\n&lt;li&gt;合成复用原则&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;设计模式-软件设计的7个原则&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-01-30 15:34:51&#34;,&#34;dateFormat&#34;:&#34;2023-01-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/she-ji-mo-shi-ruan-jian-she-ji-de-7-ge-yuan-ze/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:517000,&#34;words&#34;:2259,&#34;minutes&#34;:9},&#34;description&#34;:&#34;设计模式-软件设计的7个原则\n概述\n在软件开发时为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，通常要遵守一定的设计原则：\n\n开闭原则\n里式替换原则\n依赖倒置原则\n单一职责原则\n接口隔离原则\n迪米特原则\n合成复用原则\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99\&#34;&gt;设计模式-软件设计的7个原则&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E8%BF%B0\&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\&#34;&gt;1. 开闭原则&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%9E%84%E5%89%8D%E7%9A%84%E4%BB%A3%E7%A0%81\&#34;&gt;重构前的代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%A7%E6%89%BF\&#34;&gt;继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3\&#34;&gt;接口&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99\&#34;&gt;2. 里式替换原则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99\&#34;&gt;3. 单一职责原则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99\&#34;&gt;4. 接口隔离原则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99\&#34;&gt;5. 依赖倒置原则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99\&#34;&gt;6. 迪米特原则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99\&#34;&gt;7. 合成复用原则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7%E7%A7%8D%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\&#34;&gt;7种基本设计原则&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;git-合并两个不同的仓库\&#34;&gt;Git-合并两个不同的仓库&lt;/h1&gt;\n&lt;p&gt;有时候我们需要合并两个不同地址的Git仓库，比如：其中一个仓库A我们在GitHub上部署，另外一个仓库B我们在国内的Coding上部署，两者为同一个工程，如果我们希望将仓库A的所有改动合并到仓库B上。&lt;/p&gt;\n&lt;p&gt;整个操作的思路是伪造伪造其中一个远程仓库作为另一个仓库的一个分支，然后进行分支合并。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h4 id=\&#34;背景\&#34;&gt;背景：&lt;/h4&gt;\n&lt;p&gt;A仓库地址为：git@github.com:qxuewei/notebook.git&lt;br&gt;\nB仓库地址为：git@e.coding.net:qxuewei/notebook/notebook.git&lt;br&gt;\n需要将A仓库改动合并到B仓库中，首先保证A仓库内所有的改动均已提交。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;另外一个前提是你需要有两个仓库的代码操作权限，否则无法合并。&lt;/strong&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;1-下载需要进行合并的仓库-b\&#34;&gt;1. 下载需要进行合并的仓库 B&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;git clone git@e.coding.net:qxuewei/notebook/notebook.git\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;2-添加需要被合并的远程仓库-a\&#34;&gt;2. 添加需要被合并的远程仓库 A&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;git remote add base git@github.com:qxuewei/notebook.git\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;将 base 作为远程仓库，添加到 本地仓库(origin)中，设置别名为 base(自定义，为了方便与本地仓库origin作区分)&lt;/p&gt;\n&lt;p&gt;此时使用 &lt;code&gt;git remote&lt;/code&gt; 查看所有远程仓库将看到两个 一个本地默认仓库origin 另外一个我们新增的 base&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426962995.16129414984288.jpg\&#34; alt=\&#34;-w772\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;3-把base远程仓库a中数据抓取到本仓库b\&#34;&gt;3. 把base远程仓库（A）中数据抓取到本仓库（B）&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;git fetch base\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第2步 &lt;code&gt;git remote add xxx&lt;/code&gt; 我们仅仅是新增了远程仓库的引用，这一步真正将远程仓库的数据抓取到本地，准备后续的更新。&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426963015.16129417088506.jpg\&#34; alt=\&#34;-w669\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;4-基于base仓库的master分支新建一个分支并切换到该分支命名为-githubb\&#34;&gt;4. 基于base仓库的master分支，新建一个分支，并切换到该分支，命名为 &amp;quot;githubB&amp;quot;&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;git checkout -b githubB base/master\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此时我们的仓库B就有了一个基于仓库A内容的分支 &amp;quot;githubB&amp;quot;，后续我们将 &amp;quot;githubB&amp;quot; 分支代码合并到master就可以了。&lt;/p&gt;\n&lt;p&gt;此时使用 &lt;code&gt;git branch&lt;/code&gt; 查看所有分支&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426963027.16129419488703.jpg\&#34; alt=\&#34;-w222\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;5-我们切换到需要合并的分支-master\&#34;&gt;5. 我们切换到需要合并的分支 master&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;git checkout master\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第 4 步我们创建了即将被合并分支 &amp;quot;githubB&amp;quot; ，默认是在当前分支上的，所以我们需要切换回我们的目标分支。&lt;/p&gt;\n&lt;h4 id=\&#34;6-合并\&#34;&gt;6. 合并&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;git merge githubB --allow-unrelated-histories\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果不加 &lt;code&gt;--allow-unrelated-histories&lt;/code&gt; 关键字会报错&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;fatal: refusing to merge unrelated histories\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果在流程中报上述错误加该关键词&lt;code&gt;--allow-unrelated-histories&lt;/code&gt;即可。&lt;/p&gt;\n&lt;p&gt;合并过程中可能会遇到各种冲突，如果有冲突解决就可以了。&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2021.02.10.16129426963038.16129425194956.jpg\&#34; alt=\&#34;-w817\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;7-提交\&#34;&gt;7. 提交&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;git push origin master\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最后提交，大功告成。👌&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;git-he-bing-liang-ge-bu-tong-de-cang-ku&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;git-合并两个不同的仓库\&#34;&gt;Git-合并两个不同的仓库&lt;/h1&gt;\n&lt;p&gt;有时候我们需要合并两个不同地址的Git仓库，比如：其中一个仓库A我们在GitHub上部署，另外一个仓库B我们在国内的Coding上部署，两者为同一个工程，如果我们希望将仓库A的所有改动合并到仓库B上。&lt;/p&gt;\n&lt;p&gt;整个操作的思路是伪造伪造其中一个远程仓库作为另一个仓库的一个分支，然后进行分支合并。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Git-合并两个不同的仓库&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-27 15:00:14&#34;,&#34;dateFormat&#34;:&#34;2021-04-27&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/pankaj-patel-ZV_64LdGoao-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/git-he-bing-liang-ge-bu-tong-de-cang-ku/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:150000,&#34;words&#34;:649,&#34;minutes&#34;:3},&#34;description&#34;:&#34;Git-合并两个不同的仓库\n有时候我们需要合并两个不同地址的Git仓库，比如：其中一个仓库A我们在GitHub上部署，另外一个仓库B我们在国内的Coding上部署，两者为同一个工程，如果我们希望将仓库A的所有改动合并到仓库B上。\n整个操作的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#git-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%93%E5%BA%93\&#34;&gt;Git-合并两个不同的仓库&lt;/a&gt;&lt;br&gt;\n*&lt;br&gt;\n*&lt;br&gt;\n* &lt;a href=\&#34;#%E8%83%8C%E6%99%AF\&#34;&gt;背景：&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#1-%E4%B8%8B%E8%BD%BD%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6%E7%9A%84%E4%BB%93%E5%BA%93-b\&#34;&gt;1. 下载需要进行合并的仓库 B&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#2-%E6%B7%BB%E5%8A%A0%E9%9C%80%E8%A6%81%E8%A2%AB%E5%90%88%E5%B9%B6%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-a\&#34;&gt;2. 添加需要被合并的远程仓库 A&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#3-%E6%8A%8Abase%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93a%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96%E5%88%B0%E6%9C%AC%E4%BB%93%E5%BA%93b\&#34;&gt;3. 把base远程仓库（A）中数据抓取到本仓库（B）&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#4-%E5%9F%BA%E4%BA%8Ebase%E4%BB%93%E5%BA%93%E7%9A%84master%E5%88%86%E6%94%AF%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E8%AF%A5%E5%88%86%E6%94%AF%E5%91%BD%E5%90%8D%E4%B8%BA-githubb\&#34;&gt;4. 基于base仓库的master分支，新建一个分支，并切换到该分支，命名为 &amp;quot;githubB&amp;quot;&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#5-%E6%88%91%E4%BB%AC%E5%88%87%E6%8D%A2%E5%88%B0%E9%9C%80%E8%A6%81%E5%90%88%E5%B9%B6%E7%9A%84%E5%88%86%E6%94%AF-master\&#34;&gt;5. 我们切换到需要合并的分支 master&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#6-%E5%90%88%E5%B9%B6\&#34;&gt;6. 合并&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#7-%E6%8F%90%E4%BA%A4\&#34;&gt;7. 提交&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;mysql-基础语法\&#34;&gt;MySQL - 基础语法&lt;/h1&gt;\n&lt;h2 id=\&#34;sql\&#34;&gt;SQL&lt;/h2&gt;\n&lt;p&gt;Structured Query Language：结构化查询语言&lt;br&gt;\n定义了了操作所有关系型数据库的规则&lt;/p&gt;\n&lt;h2 id=\&#34;sql-通用语法\&#34;&gt;SQL 通用语法&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;SQL 语句可以单行或多行书写，以分号结尾&lt;/li&gt;\n&lt;li&gt;可使用空格和缩进来增强语句的可读性&lt;/li&gt;\n&lt;li&gt;MySQL 数据库的SQL语句不区分大小写，关键字建议大写&lt;/li&gt;\n&lt;li&gt;注释：\n&lt;ol&gt;\n&lt;li&gt;单行注释：-- 注释内容 或 # 注释内容 （MySQL独有）&lt;/li&gt;\n&lt;li&gt;多行注释：/* 注释内容 */&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;sql-分类\&#34;&gt;SQL 分类&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;DDL（Date Definition Language） 数据库定义语言：定义数据库对象：数据库、表、列。关键字：&lt;code&gt;CREATE&lt;/code&gt;、&lt;code&gt;DROP&lt;/code&gt;、&lt;code&gt;ALTER&lt;/code&gt; 等&lt;/li&gt;\n&lt;li&gt;DML（Date Manipulation Language）数据库操作语言：对数据库表中的数据进行增删改。关键字：&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt; 等&lt;/li&gt;\n&lt;li&gt;DQL (Date Query Language) 数据库查询语言：用来查询数据库表中的数据。关键字：&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;WHERE&lt;/code&gt; 等&lt;/li&gt;\n&lt;li&gt;DCL (Date Control Language) 数据库控制语言：定于数据库的访问权限和安全级别。关键字：&lt;code&gt;CRANT&lt;/code&gt;、&lt;code&gt;REVOKE&lt;/code&gt; 等&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;ddl\&#34;&gt;DDL&lt;/h3&gt;\n&lt;h4 id=\&#34;操作数据库\&#34;&gt;操作数据库&lt;/h4&gt;\n&lt;h5 id=\&#34;c-create-创建\&#34;&gt;C (Create) - 创建&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;创建数据库：&lt;code&gt;CREATE DATABASE 数据库名称;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;创建数据库-不存在再创建：&lt;code&gt;CREATE DATABASE IF NOT EXISTS 数据库名称;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;创建数据库-指定字符集：&lt;code&gt;CREATE DATABASE 数据库名称 CHARACTER SET 字符集名;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;r-retrieve-查询\&#34;&gt;R (Retrieve) - 查询&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;查询所有数据库名称：&lt;code&gt;SHOW DATABASE;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;查询某个数据库的字符集：查询某个数据库的创建语句：&lt;code&gt;SHOW CREATE DATABASE 数据库名称;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;u-update-修改\&#34;&gt;U (Update) - 修改&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;修改数据库的字符集：&lt;code&gt;ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;d-delete-删除\&#34;&gt;D (Delete) - 删除&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;删除数据库：&lt;code&gt;DROP DATABASE 数据库名称&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;删除数据库-存在再删除：&lt;code&gt;DROP DATABASE IF EXISTS 数据库名称&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;使用数据库\&#34;&gt;使用数据库&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;查询当前正在使用的数据库名称：&lt;code&gt;SELECT DATABASE();&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;使用数据库：&lt;code&gt;USE 数据库名称;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;操作表\&#34;&gt;操作表&lt;/h4&gt;\n&lt;h5 id=\&#34;c-create-创建-2\&#34;&gt;C (Create) - 创建&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;CREAT TABLE 表名(\n    列名1 数据类型1,\n    列名2 数据类型2,\n    ...\n    列名n 数据类型n\n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;常用表类型：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;int: &lt;code&gt;age INT,&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;double: &lt;code&gt;score DOUBLE(5,2), # 最多5位，保留2位小数 99.12&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;date: 日期，只包含年月日，yyyy-MM-dd&lt;/li&gt;\n&lt;li&gt;datetime: 日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss&lt;/li&gt;\n&lt;li&gt;timestamp: 时间戳，包含年月日时分秒，yyyy-MM-dd HH:mm:ss，如果不给其赋值，或赋值为null，则默认使用当前系统时间自动赋值，常用语 创建时间 字段&lt;/li&gt;\n&lt;li&gt;varchar: 字符串，&lt;code&gt;name VARCHAR(20) # 最大20字符的姓名&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;复制表：&lt;code&gt;CREATE TABLE 新表名 LIKE 旧表名;&lt;/code&gt;&lt;/p&gt;\n&lt;h5 id=\&#34;r-retrieve-查询-2\&#34;&gt;R (Retrieve) - 查询&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;查询某个数据库中所有的表名称：&lt;code&gt;SHOW TABLES;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;查询表结构：&lt;code&gt;DESC 表名称;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;查询建表语句：&lt;code&gt;SHOW CREATE TABLE 表名;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;u-update-修改-2\&#34;&gt;U (Update) - 修改&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;修改表名：&lt;code&gt;ALTER TABLE 旧表名 RENAME TO 新表名;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;修改表字符集：&lt;code&gt;ALTER TABLE 表名 CHARACTER SET 字符集名称;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;添加一列：&lt;code&gt;ALTER TABLE 表名 ADD 列名 数据类型;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;修改列名称和数据类型：\n&lt;ul&gt;\n&lt;li&gt;即修改名称也修改数据类型：&lt;code&gt;ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;只修改数据类型：&lt;code&gt;ALTER TABLE 表名 MODIFY 列名 新数据类型;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;删除列：&lt;code&gt;ALTER TABLE 表名 DROP 列名;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;d-delete-删除-2\&#34;&gt;D (Delete) - 删除&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;删除表：&lt;code&gt;DROP TABLE 表名;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;删除表-存在再删：&lt;code&gt;DROP TABLE IF EXISTS 表名;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;dml\&#34;&gt;DML&lt;/h3&gt;\n&lt;h4 id=\&#34;添加数据\&#34;&gt;添加数据&lt;/h4&gt;\n&lt;p&gt;语法：&lt;code&gt;INSTER INTO 表名(列名1,列名2,...,列名n) VALUES(值1,值2,...,值n);&lt;/code&gt;&lt;br&gt;\n注意：1. 列名和值要一一对应。2.如果表名后，不定义列名，则默认给所列添加值(&lt;code&gt;INSERT INTO 表名 VALUES(值1,值2,...,值n)&lt;/code&gt;)。3.除了数字类型，其他类型需要使用引号（单引号、双引号都行）引起来&lt;/p&gt;\n&lt;h4 id=\&#34;删除数据\&#34;&gt;删除数据&lt;/h4&gt;\n&lt;p&gt;语法：&lt;code&gt;DELETE FROM 表名 [WHERE 条件]&lt;/code&gt;&lt;br&gt;\n注意：1. 如果不加条件（&lt;code&gt;DELETE FORM 表名;&lt;/code&gt;），删除表中所有记录。如果不加 WHERE 则删除整个表中所有数据(会执行n次删除操作)。2. 如果想删除整个表中所有数据，建议使用&lt;code&gt;TRUNCATE TABLE 表名; (删除表，然后创建一个同名空表)&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;修改数据\&#34;&gt;修改数据&lt;/h4&gt;\n&lt;p&gt;语法：&lt;code&gt;UPDATE 表名 SET 列名1=值1, 列名2=值2, ... [WHERE 条件];&lt;/code&gt;&lt;br&gt;\n注意：1. 如果不加条件（&lt;code&gt;UPDATE 表名 SET 列名1=值1, 列名2=值2, ...&lt;/code&gt;）,则会将表中所有记录全部修改。&lt;/p&gt;\n&lt;h3 id=\&#34;dql\&#34;&gt;DQL&lt;/h3&gt;\n&lt;p&gt;查询表中的记录：&lt;code&gt;SELECT * FROM 表名;&lt;/code&gt;&lt;br&gt;\n语法：&lt;code&gt;SELECT 字段列表 FROM 表名列表 WHERE 条件列表  GROUP BY 分组字段 HAVING 分组之后的条件 ORDER BY 排序 LIMIT 分页限定&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;基础查询\&#34;&gt;基础查询&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;多个字段的查询\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;SELECT 字段名1，字段名2，... FROM 表名;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;注意：如果查询所有字段，则可以使用 * 来替代字段列表&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;去除重复\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;DISTINCT&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;eg: &lt;code&gt;SELECT DISTINCT address FROM student;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;计算列\n&lt;ol&gt;\n&lt;li&gt;一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\n&lt;ul&gt;\n&lt;li&gt;eg: &lt;code&gt;SELECT name,math,english,math + english FROM student;&lt;/code&gt; # (查询每个人的各科成绩和总分)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;ifnull(表达式1，表达式2)：null 参与的运算，计算结果都为null\n&lt;ol&gt;\n&lt;li&gt;表达式1：哪个字段需要判断是否为 null&lt;/li&gt;\n&lt;li&gt;表达式2：如果1字段为null后替换的新值&lt;/li&gt;\n&lt;li&gt;eg: &lt;code&gt;SELECT name,math,english,math + IFNULL(english, 0) FROM student;&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;起别名\n&lt;ol&gt;\n&lt;li&gt;as: as 可以省略&lt;/li&gt;\n&lt;li&gt;eg: &lt;code&gt;SELECT name,math AS 数学,english AS 英语,math + IFNULL(english, 0) AS 总分 FROM student;&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;条件查询\&#34;&gt;条件查询&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;WHERERE&lt;/code&gt; 子句后跟条件&lt;/li&gt;\n&lt;li&gt;运算符\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;&amp;gt;、 &amp;lt;、 &amp;lt;=、 &amp;gt;=、 =、 &amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;BETWEEN...AND&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;IN (集合)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;IS NULL&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;AND 或 &amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;OR 或 ||&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NOT 或 !&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt;\n&lt;ol&gt;\n&lt;li&gt;占位符\n&lt;ol&gt;\n&lt;li&gt;_: 单个任意字符&lt;/li&gt;\n&lt;li&gt;%: 多个任意字符&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h5 id=\&#34;eg\&#34;&gt;eg:&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;-- 查询年龄大于20岁\nSELECT * FROM student WHERE age &amp;gt; 20;\n\n-- 查询年龄大于等于20岁\nSELECT * FROM student WHERE age &amp;gt;= 20;\n\t\n-- 查询年龄等于20岁\nSELECT * FROM student WHERE age = 20;\n\t\n-- 查询年龄不等于20岁\nSELECT * FROM student WHERE age != 20;\nSELECT * FROM student WHERE age &amp;lt;&amp;gt; 20;\n\t\n-- 查询年龄大于等于20 小于等于30\nSELECT * FROM student WHERE age &amp;gt;= 20 &amp;amp;&amp;amp;  age &amp;lt;=30;\nSELECT * FROM student WHERE age &amp;gt;= 20 AND  age &amp;lt;=30;\nSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n\t\n-- 查询年龄22岁，18岁，25岁的信息\nSELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\nSELECT * FROM student WHERE age IN (22,18,25);\n\t\n-- 查询英语成绩为null\nSELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断\nSELECT * FROM student WHERE english IS NULL;\n\t\n-- 查询英语成绩不为null\nSELECT * FROM student WHERE english  IS NOT NULL;\n\n-- 查询姓马的有哪些？ like\nSELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n\n-- 查询姓名第二个字是化的人\nSELECT * FROM student WHERE NAME LIKE &amp;quot;_化%&amp;quot;;\n\t\n-- 查询姓名是3个字的人\nSELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n\t\t\t\t\n-- 查询姓名中包含德的人\nSELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;排序查询\&#34;&gt;排序查询&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;语法：&lt;code&gt;ORDER BY 子句&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;ORDER BY 排序字段1 排序方式1, 排序字段2 排序方式2...;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;排序方式：\n&lt;ul&gt;\n&lt;li&gt;ASC：升序 （默认）&lt;/li&gt;\n&lt;li&gt;DESC：降序&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;注意：\n&lt;ul&gt;\n&lt;li&gt;如果有多个排序条件，则当前面条件值一致时，才会判断第二条件。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;聚合函数\&#34;&gt;聚合函数&lt;/h4&gt;\n&lt;p&gt;将一列数据作为一个整体，进行纵向计算。&lt;br&gt;\n注意：聚合函数的计算时，默认排除null值&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;COUNT&lt;/code&gt;: 计算个数\n&lt;ul&gt;\n&lt;li&gt;一般选择非空的列：主键&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;COUNT(*)&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;MAX&lt;/code&gt;: 最大值&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;MIN&lt;/code&gt;: 最小值&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;SUM&lt;/code&gt;: 和&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;AVG&lt;/code&gt;: 平均值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;分组查询\&#34;&gt;分组查询&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;语法：&lt;code&gt;GROUP BY 分组字段;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;注意：\n&lt;ul&gt;\n&lt;li&gt;分组之后查询的字段只能是: 分组字段和聚合函数&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 和 &lt;code&gt;HAVING&lt;/code&gt; 的区别？\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 在分组之前进行限定，如果不满足条件，则不参与分组。&lt;code&gt;HAVING&lt;/code&gt; 在分组之后限定，如果不满足结果，则不会被查询出来。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 后不可以跟聚合函数，&lt;code&gt;HAVING&lt;/code&gt; 可以进行聚合函数的判断。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;eg-2\&#34;&gt;eg:&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;-- 按照性别分组。分别查询男、女同学的平均分\nSELECT sex , AVG(math) FROM student GROUP BY sex;\n\t\n-- 按照性别分组。分别查询男、女同学的平均分,人数\nSELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;\n\t\n--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组\nSELECT sex , AVG(math),COUNT(id) FROM student WHERE math &amp;gt; 70 GROUP BY sex;\n\t\n--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人\nSELECT sex , AVG(math),COUNT(id) FROM student WHERE math &amp;gt; 70 GROUP BY sex HAVING COUNT(id) &amp;gt; 2;\n\nSELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &amp;gt; 70 GROUP BY sex HAVING 人数 &amp;gt; 2;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;分页查询\&#34;&gt;分页查询&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;语法：&lt;code&gt;LIMIT&lt;/code&gt; 开始的索引，每页查询的条数；&lt;/li&gt;\n&lt;li&gt;公式：开始的索引 = （当前的页码-1） * 每页显示的条数&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;LIMIT&lt;/code&gt; 是一个MYSQL的特有关键字&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;dcl\&#34;&gt;DCL&lt;/h3&gt;\n&lt;p&gt;管理用户，授权。&lt;/p&gt;\n&lt;h4 id=\&#34;管理用户\&#34;&gt;管理用户&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;添加用户：&lt;code&gt;CREATE USER &#39;用户名&#39;@&#39;主机名&#39; INDENTIFIED&#39; BY &#39;密码&#39;;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;删除用户：&lt;code&gt;DROP USER &#39;用户名&#39;@&#39;主机名&#39;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;修改用户密码：&lt;code&gt;UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;&lt;/code&gt; 或 &lt;code&gt;SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;权限管理\&#34;&gt;权限管理&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;查询权限: &lt;code&gt;SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;授予权限：&lt;code&gt;GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;; -- 为张三授予root权限&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;撤销权限：&lt;code&gt;REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;REVOKE UPDATE ON db3.&lt;/code&gt;account&lt;code&gt; FROM &#39;lisi&#39;@&#39;%&#39;; -- 撤销李四db3的account表的操作权限&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;eg-3\&#34;&gt;eg:&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;-- 每页显示3条记录 \nSELECT * FROM student LIMIT 0,3; -- 第1页\nSELECT * FROM student LIMIT 3,3; -- 第2页\nSELECT * FROM student LIMIT 6,3; -- 第3页\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;约束\&#34;&gt;约束&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。&lt;/li&gt;\n&lt;li&gt;分类：\n&lt;ul&gt;\n&lt;li&gt;主键：&lt;code&gt;PRIMARY KEY&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;非空：&lt;code&gt;NOT NULL&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;唯一：&lt;code&gt;UNIQUE&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;外键：&lt;code&gt;FOREIGN KEY&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;非空not-null-某一列的值不能为-null\&#34;&gt;非空：&lt;code&gt;NOT NULL&lt;/code&gt;, 某一列的值不能为 null&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;创建表时添加非空约束&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;CREAT TABLE student (\n    id INT,\n    NAME VARCHAR(20) NOT NULL -- name 不为空    \n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建完表后，添加非空约束&lt;br&gt;\n&lt;code&gt;ALTER TABLE student MODIFY NAME VARCHAR(20) NOT NULL;&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建完表后，删除非空约束&lt;br&gt;\n&lt;code&gt;ALTER TABLE student MODIFY NAME VARCHAR(20);&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;唯一约束unique-某一列的值不能重复\&#34;&gt;唯一约束：&lt;code&gt;UNIQUE&lt;/code&gt; 某一列的值不能重复&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;注意：唯一约束可以有 NULL 值，但只能有一条记录为 NULL&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建表时添加唯一约束&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;CREAT TABLE student (\nid INT,\nphoneNumber VARCHAR(20) UNIQUE -- 手机号 不可重复    \n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建完表后，添加唯一约束&lt;br&gt;\n&lt;code&gt;ALTER TABLE student MODIFY phoneNumber VARCHAR(20) UNIQUE;&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建完表后，删除唯一约束&lt;br&gt;\n&lt;code&gt;ALTER TABLE student DROP INDEX phoneNumber;&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;主键约束primary-key\&#34;&gt;主键约束：&lt;code&gt;PRIMARY KEY&lt;/code&gt;&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;注意：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;含义：非空且唯一&lt;/li&gt;\n&lt;li&gt;一张表只能有一个字段为主键&lt;/li&gt;\n&lt;li&gt;主键就是表中记录的唯一标识&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在创建表时，添加主键约束&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;CREAT TABLE student(\n    id INT PRIMARY KEY, -- 给id添加主键约束\n    name VARCHAR(20)\n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除主键约束&lt;br&gt;\n&lt;code&gt;ALTER TABLE student DROP PRIMARY KEY;&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建完表后，添加主键&lt;br&gt;\n&lt;code&gt;ALTER TABLE student MODIFY id INT PRIMARY KEY;&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;自动增长：如果某一列是数值类型，使用 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 可以完成值的自动增长。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;在创建表时，添加主键约束，并且完成主键自增长&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;CREATE TABLE student (\n    id INT PRIMARY KEY AUTO_INCREMENT, -- 给id添加主键约束\n    name VARCHAR(20)\n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除自动增长&lt;br&gt;\n&lt;code&gt;ALTER TABLE student MODIFY id INT&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;添加自动增长&lt;br&gt;\n&lt;code&gt;ALTER TABLE student MODIFY id INT AUTO_INCREMENT&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;外键约束foreign-key\&#34;&gt;外键约束：&lt;code&gt;FOREIGN KEY&lt;/code&gt;&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;在创建表时，可以添加外键&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;注意：外键可以为null，但不能为不存在的值&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;语法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;CREATE TABLE 表名(\n\t....\n\t外键列\n    CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称)\n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除外键&lt;br&gt;\n&lt;code&gt;ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建表之后，添加外键&lt;br&gt;\n&lt;code&gt;ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名称);&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;级联操作&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;添加级联操作&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;分类：\n&lt;ol&gt;\n&lt;li&gt;级联更新：ON UPDATE CASCADE&lt;/li&gt;\n&lt;li&gt;级联删除：ON DELETE CASCADE&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;语法：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;ALTER TABLE 表名 ADD CONSTRAINT 外键名称 \nFOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE / ON DELETE CASCADE;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;数据库的设计\&#34;&gt;数据库的设计&lt;/h2&gt;\n&lt;h3 id=\&#34;多表之间的关系\&#34;&gt;多表之间的关系&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;一对一：eg: 人和身份证&lt;/li&gt;\n&lt;li&gt;一对多：eg: 部门和员工\n&lt;ul&gt;\n&lt;li&gt;实现方式：在&amp;quot;多&amp;quot;的一方建立外键，指向&amp;quot;一&amp;quot;的一方的主键&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;多对多：eg: 学生和课程\n&lt;ul&gt;\n&lt;li&gt;实现方式：借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;案例\&#34;&gt;案例&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;-- 创建旅游线路分类表 tab_category\n-- cid 旅游线路分类主键，自动增长\n-- cname 旅游线路分类名称非空，唯一，字符串 100\nCREATE TABLE tab_category (\n    cid INT PRIMARY KEY AUTO_INCREMENT,\n    cname VARCHAR(100) NOT NULL UNIQUE\n);\n\t\n-- 创建旅游线路表 tab_route\n/*\nrid 旅游线路主键，自动增长\nrname 旅游线路名称非空，唯一，字符串 100\nprice 价格\nrdate 上架时间，日期类型\ncid 外键，所属分类\n*/\nCREATE TABLE tab_route(\n    rid INT PRIMARY KEY AUTO_INCREMENT,\n    rname VARCHAR(100) NOT NULL UNIQUE,\n    price DOUBLE,\n    rdate DATE,\n    cid INT,\n    FOREIGN KEY (cid) REFERENCES tab_category(cid)\n);\n\t\n/*创建用户表 tab_user\nuid 用户主键，自增长\nusername 用户名长度 100，唯一，非空\npassword 密码长度 30，非空\nname 真实姓名长度 100\nbirthday 生日\nsex 性别，定长字符串 1\ntelephone 手机号，字符串 11\nemail 邮箱，字符串长度 100\n*/\nCREATE TABLE tab_user (\n    uid INT PRIMARY KEY AUTO_INCREMENT,\n    username VARCHAR(100) UNIQUE NOT NULL,\n    PASSWORD VARCHAR(30) NOT NULL,\n    NAME VARCHAR(100),\n    birthday DATE,\n    sex CHAR(1) DEFAULT &#39;男&#39;,\n    telephone VARCHAR(11),\n    email VARCHAR(100)\n);\n\t\n/*\n创建收藏表 tab_favorite\nrid 旅游线路 id，外键\ndate 收藏时间\nuid 用户 id，外键\nrid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次\n*/\nCREATE TABLE tab_favorite (\n    rid INT, -- 线路id\n    DATE DATETIME,\n    uid INT, -- 用户id\n    -- 创建复合主键\n    PRIMARY KEY(rid,uid), -- 联合主键\n    FOREIGN KEY (rid) REFERENCES tab_route(rid),\n    FOREIGN KEY(uid) REFERENCES tab_user(uid)\n);\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;数据库设计的范式\&#34;&gt;数据库设计的范式&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  \t设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\n  \t目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;分类：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;第一范式（1NF）：每一列都是不可分割的原子数据项&lt;/li&gt;\n&lt;li&gt;第二范式（2NF）：在第一范式的基础上，非码属性必须完全依赖于码。（在1NF基础上消除非主属性对码的部分函数依赖）\n&lt;ul&gt;\n&lt;li&gt;函数依赖：A-&amp;gt;B, 如果通过A属性（属性组）的值，可以确定唯一B属性的值，则称B依赖于A。eg: 学号-&amp;gt;姓名，（学号，课程名称）-&amp;gt; 分数\n&lt;ul&gt;\n&lt;li&gt;完全函数依赖：A-&amp;gt;B，如果A是一个属性组，则B属性的值需要依赖于A属性组中的所有元素值。eg:（学号，课程名称）-&amp;gt; 分数&lt;/li&gt;\n&lt;li&gt;部分函数依赖：A-&amp;gt;B，如果A是一个属性组，则B属性值只需要依赖A属性组中的某一些值即可。eg:（学号，课程名称）-&amp;gt; 姓名&lt;/li&gt;\n&lt;li&gt;传递函数依赖：A-&amp;gt;B, B-&amp;gt;C，如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性（属性组）的值可以确定唯一C属性的值，则称C传递依赖于A。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;码：如果在一张表中，一个属性（属性组）被其他所有属性完全依赖，则称这个属性（属性组）为该表的码。eg: （学号，课程名称）\n&lt;ul&gt;\n&lt;li&gt;主属性：码属性（组）中所有的属性&lt;/li&gt;\n&lt;li&gt;非主属性：除码属性（组）外的属性&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;第三范式（3NF）：在2NF的基础上，任何非主属性不依赖于其他非主属性。（在2NF基础上消除传递依赖）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;数据库的备份和还原\&#34;&gt;数据库的备份和还原&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;命令行：\n&lt;ul&gt;\n&lt;li&gt;备份语法：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名称 &amp;gt; 保存的位置&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;还原方式：\n&lt;ul&gt;\n&lt;li&gt;登录数据库&lt;/li&gt;\n&lt;li&gt;创建数据库&lt;/li&gt;\n&lt;li&gt;使用数据库&lt;/li&gt;\n&lt;li&gt;执行文件 （之前保存的文件路径）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;多表查询\&#34;&gt;多表查询&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;笛卡尔积：有两个集合A、B, 取这两个集合的所有组成情况&lt;/li&gt;\n&lt;li&gt;要完成多表查询，需要消除无用的数据&lt;/li&gt;\n&lt;li&gt;语法：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;SELECT\n    列名列表\nFROM\n    表名列表\nWHERE\n    条件\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;练习：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;# 创建部门表\nCREATE TABLE dept(\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(20)\n);\nINSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);\n# 创建员工表\nCREATE TABLE emp (\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(10),\n\tgender CHAR(1), -- 性别\n\tsalary DOUBLE, -- 工资\n\tjoin_date DATE, -- 入职日期\n\tdept_id INT,\n\tFOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)\n);\nINSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);\nINSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);\nINSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);\nINSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);\nINSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;多表查询的分类\&#34;&gt;多表查询的分类&lt;/h3&gt;\n&lt;h4 id=\&#34;内连接查询\&#34;&gt;内连接查询&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;1. 从哪些表中查询数据\n2. 条件是什么\n3. 查询哪些字段\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;隐式内连接\&#34;&gt;隐式内连接&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;-- 查询所有员工信息和对应的部门信息\nSELECT * FROM emp,dept WHERE emp.dept_id = dept.id;\n    \n-- 查询员工表的名称，性别。部门表的名称\n-- 查询员工表的名称，性别。部门表的名称\nSELECT\n\tt1.`NAME`,\n\tt1.gender,\n\tt2.`NAME`\nFROM\n\temp t1,\t\t-- 员工表\n\tdept t2\t\t-- 部门表\nWHERE\n\tt1.dept_id = t2.id\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;显式内连接\&#34;&gt;显式内连接&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;语法：&lt;code&gt;SELECT 字段名称 FROM 表名1 [INNER] JOIN 表名2 ON 条件;&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;例如 &lt;code&gt;SELECT * FROM emp JOIN dept ON emp.dept_id = dept.id;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;外连接查询\&#34;&gt;外连接查询&lt;/h4&gt;\n&lt;h5 id=\&#34;左外连接\&#34;&gt;左外连接&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;语法：&lt;code&gt;SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;含义：查询左表所有的数据与有表有交集的部分&lt;/li&gt;\n&lt;li&gt;实例：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称\nSELECT\n\tt1.*,\n\tt2.`NAME`\nFROM\n\temp t1\nLEFT JOIN\n\tdept t2\nON\n\tt1.dept_id = t2.id\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;子查询\&#34;&gt;子查询&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;概念：查询中嵌套查询，成嵌套查询为子查询。&lt;/li&gt;\n&lt;li&gt;实例：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-SQL\&#34;&gt;-- 查询工资最高的员工信息\nSELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);\n\n-- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息\nSELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);\n\n-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息\nSELECT \n    * \nFROM \n    dept t1 ,\n    (SELECT * FROM emp WHERE emp.`join_date` &amp;gt; &#39;2011-11-11&#39;) t2\nWHERE \n    t1.id = t2.dept_id;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;事务\&#34;&gt;事务&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。&lt;/li&gt;\n&lt;li&gt;操作:\n&lt;ul&gt;\n&lt;li&gt;开启事务：&lt;code&gt;START TRANSACTION;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;回滚：&lt;code&gt;ROLLBACK&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;提交：&lt;code&gt;COMMIT&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;MySQL 中事务是默认自动提交。（运行一条DML(增删改)语句就会自动提交一次事务）&lt;/li&gt;\n&lt;li&gt;Oracle 数据库是默认手动提交事务，需要先开启事务，再提交。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;事务的四大特征\&#34;&gt;事务的四大特征：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。&lt;/li&gt;\n&lt;li&gt;持久性：当事务提交或回滚后，数据库会持久化的保存数据。&lt;/li&gt;\n&lt;li&gt;隔离性：多个事务之间。相互独立。&lt;/li&gt;\n&lt;li&gt;一致性：事务操作前后，数据总量不变&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-ji-chu-yu-fa&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;mysql-基础语法\&#34;&gt;MySQL - 基础语法&lt;/h1&gt;\n&lt;h2 id=\&#34;sql\&#34;&gt;SQL&lt;/h2&gt;\n&lt;p&gt;Structured Query Language：结构化查询语言&lt;br&gt;\n定义了了操作所有关系型数据库的规则&lt;/p&gt;\n&lt;h2 id=\&#34;sql-通用语法\&#34;&gt;SQL 通用语法&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;SQL 语句可以单行或多行书写，以分号结尾&lt;/li&gt;\n&lt;li&gt;可使用空格和缩进来增强语句的可读性&lt;/li&gt;\n&lt;li&gt;MySQL 数据库的SQL语句不区分大小写，关键字建议大写&lt;/li&gt;\n&lt;li&gt;注释：\n&lt;ol&gt;\n&lt;li&gt;单行注释：-- 注释内容 或 # 注释内容 （MySQL独有）&lt;/li&gt;\n&lt;li&gt;多行注释：/* 注释内容 */&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;MySQL - 基础语法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;数据库&#34;,&#34;slug&#34;:&#34;u6X-XcnSO&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/u6X-XcnSO/&#34;}],&#34;date&#34;:&#34;2020-06-30 16:27:49&#34;,&#34;dateFormat&#34;:&#34;2020-06-30&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2020.06.30.15935112492167.michael-dziedzic-dSyhpTGhNHg-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/mysql-ji-chu-yu-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;20 min read&#34;,&#34;time&#34;:1173000,&#34;words&#34;:4807,&#34;minutes&#34;:20},&#34;description&#34;:&#34;MySQL - 基础语法\nSQL\nStructured Query Language：结构化查询语言\n定义了了操作所有关系型数据库的规则\nSQL 通用语法\n\nSQL 语句可以单行或多行书写，以分号结尾\n可使用空格和缩进来增强语句的可读性\nM...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#mysql-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\&#34;&gt;MySQL - 基础语法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#sql\&#34;&gt;SQL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sql-%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95\&#34;&gt;SQL 通用语法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sql-%E5%88%86%E7%B1%BB\&#34;&gt;SQL 分类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ddl\&#34;&gt;DDL&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;操作数据库&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#c-create-%E5%88%9B%E5%BB%BA\&#34;&gt;C (Create) - 创建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#r-retrieve-%E6%9F%A5%E8%AF%A2\&#34;&gt;R (Retrieve) - 查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#u-update-%E4%BF%AE%E6%94%B9\&#34;&gt;U (Update) - 修改&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#d-delete-%E5%88%A0%E9%99%A4\&#34;&gt;D (Delete) - 删除&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;使用数据库&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%93%8D%E4%BD%9C%E8%A1%A8\&#34;&gt;操作表&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#c-create-%E5%88%9B%E5%BB%BA-2\&#34;&gt;C (Create) - 创建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#r-retrieve-%E6%9F%A5%E8%AF%A2-2\&#34;&gt;R (Retrieve) - 查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#u-update-%E4%BF%AE%E6%94%B9-2\&#34;&gt;U (Update) - 修改&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#d-delete-%E5%88%A0%E9%99%A4-2\&#34;&gt;D (Delete) - 删除&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dml\&#34;&gt;DML&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE\&#34;&gt;添加数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\&#34;&gt;删除数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE\&#34;&gt;修改数据&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dql\&#34;&gt;DQL&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2\&#34;&gt;基础查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2\&#34;&gt;条件查询&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#eg\&#34;&gt;eg:&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2\&#34;&gt;排序查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0\&#34;&gt;聚合函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2\&#34;&gt;分组查询&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#eg-2\&#34;&gt;eg:&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2\&#34;&gt;分页查询&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dcl\&#34;&gt;DCL&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7\&#34;&gt;管理用户&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86\&#34;&gt;权限管理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#eg-3\&#34;&gt;eg:&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%A6%E6%9D%9F\&#34;&gt;约束&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%9E%E7%A9%BAnot-null-%E6%9F%90%E4%B8%80%E5%88%97%E7%9A%84%E5%80%BC%E4%B8%8D%E8%83%BD%E4%B8%BA-null\&#34;&gt;非空：&lt;code&gt;NOT NULL&lt;/code&gt;, 某一列的值不能为 null&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9Funique-%E6%9F%90%E4%B8%80%E5%88%97%E7%9A%84%E5%80%BC%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D\&#34;&gt;唯一约束：&lt;code&gt;UNIQUE&lt;/code&gt; 某一列的值不能重复&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9Fprimary-key\&#34;&gt;主键约束：&lt;code&gt;PRIMARY KEY&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9Fforeign-key\&#34;&gt;外键约束：&lt;code&gt;FOREIGN KEY&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1\&#34;&gt;数据库的设计&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\&#34;&gt;多表之间的关系&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A1%88%E4%BE%8B\&#34;&gt;案例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%8C%83%E5%BC%8F\&#34;&gt;数据库设计的范式&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F\&#34;&gt;数据库的备份和还原&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2\&#34;&gt;多表查询&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB\&#34;&gt;多表查询的分类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2\&#34;&gt;内连接查询&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9A%90%E5%BC%8F%E5%86%85%E8%BF%9E%E6%8E%A5\&#34;&gt;隐式内连接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%98%BE%E5%BC%8F%E5%86%85%E8%BF%9E%E6%8E%A5\&#34;&gt;显式内连接&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%96%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2\&#34;&gt;外连接查询&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5\&#34;&gt;左外连接&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%90%E6%9F%A5%E8%AF%A2\&#34;&gt;子查询&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8B%E5%8A%A1\&#34;&gt;事务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81\&#34;&gt;事务的四大特征：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;ios-runtime-详解\&#34;&gt;iOS - Runtime 详解&lt;/h1&gt;\n&lt;h2 id=\&#34;0-概述\&#34;&gt;0. 概述&lt;/h2&gt;\n&lt;p&gt;Objective-C Runtime 使得C具有了面向对象的能力，在程序运行时创建，检查，修改类，对象和它们的方法。Runtime 是 C和汇编写的，这里&lt;a href=\&#34;http://www.opensource.apple.com/source/objc4/\&#34;&gt;http://www.opensource.apple.com/source/objc4/&lt;/a&gt;可以下载Apple维护的开源代码，GUN也有一个开源的Runtime版本，它们都努力保持一致。&lt;a href=\&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048\&#34;&gt;Apple官方的runtime编程指南&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;对于 C 语言，函数的调用会在编译期就已经决定好，在编译完成后直接顺序执行。但是 OC 是一门动态语言，函数调用变成了消息发送，在编译期不能知道调用哪个函数，Runtime 就是去解决如何在运行时期找到调用方法的问题。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;1-runtime-函数\&#34;&gt;1、Runtime 函数&lt;/h2&gt;\n&lt;p&gt;Runtime 系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/user/includeobjc 目录下可以看到头文件，可以用到其中一些函数通过C语言实现Objective-C中一样的功能。&lt;a href=\&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html\&#34;&gt;苹果官方文档&lt;/a&gt;  里有详细的Runtime 函数文档。&lt;/p&gt;\n&lt;h2 id=\&#34;2-class-和-nsobject-基础数据结构\&#34;&gt;2. Class 和 NSObject 基础数据结构&lt;/h2&gt;\n&lt;h3 id=\&#34;21-class\&#34;&gt;2.1 Class&lt;/h3&gt;\n&lt;p&gt;objc_class 结构体的定义如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C\&#34;&gt;//-------- [file:objc-runtime-new.h] --------\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n    ......\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;22-objc_object\&#34;&gt;2.2 objc_object&lt;/h3&gt;\n&lt;p&gt;objc_object 是一个类的实例结构体，objc/objc.h 中 objc_object是一个类的实例结构体定义如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C\&#34;&gt;//-------- [file:objc-private.h] --------\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;\n\nstruct objc_object {\nprivate:\n    isa_t isa;\n    ......\n}\n\nunion isa_t \n{\n    ......\n    Class cls;\n    uintptr_t bits;\n    ......\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;向object发送消息时，Runtime 库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类的方法列表中寻找对应的方法运行。id 是一个objc_object结构类型的指针，这个类型的对象能转换成任何一种对象。&lt;/p&gt;\n&lt;h3 id=\&#34;23-cache_t\&#34;&gt;2.3 cache_t&lt;/h3&gt;\n&lt;p&gt;cache_t 结构体中cache字段用于缓存调用过的method。cache指针指向cache_t结构体，这个结构体定义如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C\&#34;&gt;struct cache_t {\n    struct bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;24-meta-class\&#34;&gt;2.4 Meta Class&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;meta class&lt;/code&gt; 是一个类对象的类，&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;当向对象发送消息时，runtime 会在这个对象所属类方法列表中查找发送消息对应的方法;&lt;/li&gt;\n&lt;li&gt;但当向类发送消息时，runtime 就会在这个类的 &lt;code&gt;meta class&lt;/code&gt; 方法列表中查找。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;所有的 &lt;code&gt;meta class&lt;/code&gt;，包括&lt;code&gt;Root class&lt;/code&gt;，&lt;code&gt;SuperClass&lt;/code&gt;, &lt;code&gt;SubClass&lt;/code&gt;的&lt;code&gt;isa&lt;/code&gt;都指向 &lt;code&gt;Root class&lt;/code&gt; 的 &lt;code&gt;meta class&lt;/code&gt;，这样能够形成一个闭环。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://raw.githubusercontent.com/qxuewei/XWResources/master/images/metaClass.png\&#34; alt=\&#34;meta class 关系图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;3runtime-类与对象操作函数\&#34;&gt;3.Runtime 类与对象操作函数&lt;/h2&gt;\n&lt;p&gt;Runtime 有很多函数可以操作类和对象。类相关的是class为前缀，对象相关相关的函数是 objc 或者 object 为前缀。&lt;/p&gt;\n&lt;h3 id=\&#34;31类相关操作函数\&#34;&gt;3.1类相关操作函数&lt;/h3&gt;\n&lt;h4 id=\&#34;name\&#34;&gt;name&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取类的类名\nconst cahr * class_getName (Class cls);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;super_class-和-meta_class\&#34;&gt;super_class 和 meta_class&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取类的父类\nClass class_getSuperclass (Class cls);\n\n// 判断给定的Class是否是一个meta class\nBOOL class_isMetaClass (Class cls);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;instance_size\&#34;&gt;instance_size&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取实例大小\nsize_t class_getInstanceSize (Class cls);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;32-成员变量ivars及属性\&#34;&gt;3.2 成员变量（ivars）及属性&lt;/h3&gt;\n&lt;h4 id=\&#34;321-成员变量操作函数\&#34;&gt;3.2.1 成员变量操作函数&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取类中指定名称实例成员变量的信息\nIvar class_getInstanceVariable (Class cls, const char *name);\n\n// 获取类成员变量的信息\nIvar class_getClassVariable (Class cls, const char *name);\n\n// 添加成员变量\nBOOL class_addIvar (Class cls, const char *name, size_t size, uint8_t alignment, const char *types);  //只能向在runtime时创建的类添加成员变量，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。\n\n// 获取整个成员变量列表\nIvar * class_copyIvarList (Class cls, unsigned int *outCount); // 必须使用free()来释放这个数组\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试成员变量&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;//成员变量\n- (void)testIvar {\n    BOOL isSuccessAddIvar = class_addIvar([NSString class], &amp;quot;_phone&amp;quot;, sizeof(id), log2(sizeof(id)), &amp;quot;@&amp;quot;);\n    if (isSuccessAddIvar) {\n        NSLog(@&amp;quot;Add Ivar success&amp;quot;);\n    }else{\n        NSLog(@&amp;quot;Add Ivar error&amp;quot;);\n    }\n    unsigned int outCount;\n    Ivar *ivarList = class_copyIvarList([People class], &amp;amp;outCount);\n    for (int i = 0; i &amp;lt; outCount; i++) {\n        Ivar ivar = ivarList[i];\n        const char *ivarName = ivar_getName(ivar);\n        const char *type = ivar_getTypeEncoding(ivar);\n        ptrdiff_t offset = ivar_getOffset(ivar);\n        NSLog(@&amp;quot;ivar:%s, offset:%zd, type:%s&amp;quot;, ivarName, offset, type);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;322-属性操作函数\&#34;&gt;3.2.2 属性操作函数&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取指定的属性\nobjc_property_t class_getProperty(Class cls, const char *name);\n\n// 获取属性列表\nobjc_property_t * class_copyPropertyList(Class cls, unsigned int *outCount);\n\n// 为类添加属性\nBOOL class_addProperty (Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);\n\n// 替换类的属性\nvoid class_replaceProperty (Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;针对ivar来操作的，不过它只操作那些property的值，包括扩展中的property。&lt;/p&gt;\n&lt;p&gt;测试属性&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;- (void)testProperty {    \n    objc_property_attribute_t attribute1 = {&amp;quot;T&amp;quot;, &amp;quot;@\\&amp;quot;NSString\\&amp;quot;&amp;quot;};\n    objc_property_attribute_t attribute2 = {&amp;quot;C&amp;quot;, &amp;quot;&amp;quot;};\n    objc_property_attribute_t attribute3 = {&amp;quot;N&amp;quot;, &amp;quot;&amp;quot;};\n    objc_property_attribute_t attribute4 = {&amp;quot;V&amp;quot;, &amp;quot;_addProperty&amp;quot;};\n    objc_property_attribute_t attributesList[] = {attribute1, attribute2, attribute3, attribute4};\n    BOOL isSuccessAddProperty = class_addProperty([People class], &amp;quot;addProperty&amp;quot;, attributesList, 4);\n    if (isSuccessAddProperty) {\n        NSLog(@&amp;quot;Add Property Success&amp;quot;);\n    }else{\n        NSLog(@&amp;quot;Add Property Error&amp;quot;);\n    }\n    unsigned int outCount;\n    objc_property_t * propertyList = class_copyPropertyList([People class], &amp;amp;outCount);\n    for (unsigned int i = 0; i &amp;lt; outCount; i++) {\n        objc_property_t property = propertyList[i];\n        const char *propertyName = property_getName(property);\n        const char *attribute = property_getAttributes(property);\n        NSLog(@&amp;quot;propertyName: %s, attribute: %s&amp;quot;, propertyName, attribute);\n        unsigned int attributeCount;\n        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;amp;attributeCount);\n        for (unsigned int i = 0; i &amp;lt; attributeCount; i++) {\n            objc_property_attribute_t attribute = attributeList[i];\n            const char *name = attribute.name;\n            const char *value = attribute.value;\n            NSLog(@&amp;quot;attribute name: %s, value: %s&amp;quot;,name,value);\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;2018-05-01 17:14:52.957653+0800 RuntimeDemo[24515:910260] Add Property Success\n2018-05-01 17:14:52.957871+0800 RuntimeDemo[24515:910260] propertyName: addProperty, attribute: T@&amp;quot;NSString&amp;quot;,C,N,V_addProperty\n2018-05-01 17:14:52.958034+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSString&amp;quot;\n2018-05-01 17:14:52.958175+0800 RuntimeDemo[24515:910260] attribute name: C, value:\n2018-05-01 17:14:52.958309+0800 RuntimeDemo[24515:910260] attribute name: N, value:\n2018-05-01 17:14:52.958452+0800 RuntimeDemo[24515:910260] attribute name: V, value: _addProperty\n2018-05-01 17:14:52.958575+0800 RuntimeDemo[24515:910260] propertyName: name, attribute: T@&amp;quot;NSString&amp;quot;,C,N,V_name\n2018-05-01 17:14:52.958732+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSString&amp;quot;\n2018-05-01 17:14:52.958850+0800 RuntimeDemo[24515:910260] attribute name: C, value:\n2018-05-01 17:14:52.958983+0800 RuntimeDemo[24515:910260] attribute name: N, value:\n2018-05-01 17:14:52.959096+0800 RuntimeDemo[24515:910260] attribute name: V, value: _name\n2018-05-01 17:14:52.959225+0800 RuntimeDemo[24515:910260] propertyName: age, attribute: T@&amp;quot;NSNumber&amp;quot;,&amp;amp;,N,V_age\n2018-05-01 17:14:52.959319+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSNumber&amp;quot;\n2018-05-01 17:14:52.959420+0800 RuntimeDemo[24515:910260] attribute name: &amp;amp;, value:\n2018-05-01 17:14:52.959646+0800 RuntimeDemo[24515:910260] attribute name: N, value:\n2018-05-01 17:14:52.959847+0800 RuntimeDemo[24515:910260] attribute name: V, value: _age\n2018-05-01 17:14:52.960024+0800 RuntimeDemo[24515:910260] propertyName: sex, attribute: TQ,N,V_sex\n2018-05-01 17:14:52.960186+0800 RuntimeDemo[24515:910260] attribute name: T, value: Q\n2018-05-01 17:14:52.960365+0800 RuntimeDemo[24515:910260] attribute name: N, value:\n2018-05-01 17:14:52.960584+0800 RuntimeDemo[24515:910260] attribute name: V, value: _sex\n2018-05-01 17:14:52.960737+0800 RuntimeDemo[24515:910260] propertyName: address, attribute: T@&amp;quot;NSString&amp;quot;,C,N,V_address\n2018-05-01 17:14:52.960928+0800 RuntimeDemo[24515:910260] attribute name: T, value: @&amp;quot;NSString&amp;quot;\n2018-05-01 17:14:52.961101+0800 RuntimeDemo[24515:910260] attribute name: C, value:\n2018-05-01 17:14:52.961274+0800 RuntimeDemo[24515:910260] attribute name: N, value:\n2018-05-01 17:14:52.961463+0800 RuntimeDemo[24515:910260] attribute name: V, value: _address\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;T 是固定的，放在第一个\n@”NSString” 代表这个property是一个字符串对象\n&amp;amp; 代表强引用，其中与之并列的是：’C’代表Copy，’&amp;amp;’代表强引用，’W’表示weak，assign为空，默认为assign。R 代表readOnly属性，readwrite时为空\nN 区分的nonatomic和atomic，默认为atomic，atomic为空，’N’代表是nonatomic\nV_exprice V代表变量，后面紧跟着的是成员变量名，代表这个property的成员变量名为_exprice\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://raw.githubusercontent.com/qxuewei/XWResources/master/images/runtime_property_attrit.png\&#34; alt=\&#34;property_getAttributes 说明\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;323-协议相关函数\&#34;&gt;3.2.3 协议相关函数&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 添加协议\nBOOL class_addProtocol ( Class cls, Protocol *protocol );\n \n// 返回类是否实现指定的协议\nBOOL class_conformsToProtocol ( Class cls, Protocol *protocol );\n \n// 返回类实现的协议列表\nProtocol * class_copyProtocolList ( Class cls, unsigned int *outCount );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试协议&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;@protocol PeopleProcol &amp;lt;NSObject&amp;gt;\n@end\n\n- (void)testProtocol {\n    // 添加协议\n    Protocol *p = @protocol(PeopleProcol);\n    if (class_addProtocol([People class], p)) {\n        NSLog(@&amp;quot;Add Protoclol Success&amp;quot;);\n    }else{\n        NSLog(@&amp;quot;Add protocol Fail&amp;quot;);\n    }\n    if (class_conformsToProtocol([People class], p)) {\n        NSLog(@&amp;quot;实现了 PeopleProcol 协议&amp;quot;);\n    }else{\n        NSLog(@&amp;quot;没有实现 PeopleProcol 协议&amp;quot;);\n    }\n    unsigned int outCount;\n    Protocol *__unsafe_unretained *protocolList = class_copyProtocolList([People class], &amp;amp;outCount);\n    for (unsigned int i = 0; i &amp;lt; outCount; i++) {\n        Protocol *p = protocolList[i];\n        const char *protocolName = protocol_getName(p);\n        NSLog(@&amp;quot;协议名称: %s&amp;quot;,protocolName);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\n2018-05-01 17:29:12.580433+0800 RuntimeDemo[25007:940310] Add Protoclol Success\n2018-05-01 17:29:12.580591+0800 RuntimeDemo[25007:940310] 实现了 PeopleProcol 协议\n2018-05-01 17:29:12.580707+0800 RuntimeDemo[25007:940310] 协议名称: PeopleProcol\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;324-版本号\&#34;&gt;3.2.4 版本号&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;- (void)testVersion {\n    int version = class_getVersion([People class]);\n    NSLog(@&amp;quot;version %d&amp;quot;,version);\n    \n    class_setVersion([People class], 10086);\n    \n    int nerVersion = class_getVersion([People class]);\n    NSLog(@&amp;quot;nerVersion %d&amp;quot;,nerVersion);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;2018-05-01 17:38:29.593821+0800 RuntimeDemo[25266:956588] version 0\n2018-05-01 17:38:29.593972+0800 RuntimeDemo[25266:956588] nerVersion 10086\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;33-动态创建类和对象\&#34;&gt;3.3 动态创建类和对象&lt;/h3&gt;\n&lt;h4 id=\&#34;331-动态创建类\&#34;&gt;3.3.1. 动态创建类&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 创建一个新类和元类\nClass objc_allocateClassPair (Class superclass, const char *name, size_t extraBytes);\n\n// 销魂一个类及其相关联的类\nvoid objc_disposeClassPair (Class cls);\n\n// 在应用中注册由objc_allocateClassPair创建类\nvoid objc_registerClassPair (Class cls);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中：&lt;/p&gt;\n&lt;p&gt;（1）objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。&lt;/p&gt;\n&lt;p&gt;（2）为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。&lt;/p&gt;\n&lt;p&gt;（3）实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。&lt;/p&gt;\n&lt;p&gt;（4）objc_disposeClassPair只能销毁由objc_allocateClassPair创建的类，当有实例存在或者它的子类存在时，调用这个函数会抛出异常。&lt;/p&gt;\n&lt;p&gt;测试代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objctive-c\&#34;&gt;- (void)testAddClass {\n    Class TestClass = objc_allocateClassPair([NSObject class], &amp;quot;myClass&amp;quot;, 0);\n    if (class_addIvar(TestClass, &amp;quot;myIvar&amp;quot;, sizeof(NSString *), sizeof(NSString *), &amp;quot;@&amp;quot;)) {\n        NSLog(@&amp;quot;Add Ivar Success&amp;quot;);\n    }\n    class_addMethod(TestClass, @selector(method1:), (IMP)method0, &amp;quot;v@:&amp;quot;);\n    // 注册这个类到runtime才可使用\n    objc_registerClassPair(TestClass);\n    \n    // 生成一个实例化对象\n    id myObjc = [[TestClass alloc] init];\n    NSString *str = @&amp;quot;qiuxuewei&amp;quot;;\n    //给刚刚添加的变量赋值\n    //object_setInstanceVariable(myobj, &amp;quot;myIvar&amp;quot;, (void *)&amp;amp;str);在ARC下不允许使用\n    [myObjc setValue:str forKey:@&amp;quot;myIvar&amp;quot;];\n    [myObjc method1:10086];\n}\n- (void)method1:(int)a {\n}\nvoid method0(id self, SEL _cmd, int a) {\n    Ivar v = class_getInstanceVariable([self class], &amp;quot;myIvar&amp;quot;);\n    id o = object_getIvar(self, v);\n    NSLog(@&amp;quot;%@ \\n int a is %d&amp;quot;, o,a);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;2018-05-01 22:30:30.159096+0800 RuntimeDemo[31292:1162987] Add Ivar Success\n2018-05-01 22:30:30.159344+0800 RuntimeDemo[31292:1162987] qiuxuewei \n int a is 10086\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;332-动态创建对象\&#34;&gt;3.3.2. 动态创建对象&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 创建类的实例\nid class_createInstance (Class cls, size_t extraBytes);\n\n// 在指定位置创建类实例\nid objc_constructInstance (Class cls, void *bytes);\n\n// 销毁类实例\nvoid * objc_destructInstance (id obj);\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。&lt;/p&gt;\n&lt;p&gt;调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。&lt;/p&gt;\n&lt;p&gt;测试代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (void)testCreteInstance {\n    id testInstance = class_createInstance([NSString class], sizeof(unsigned));\n    id str1 = [testInstance init];\n    NSLog(@&amp;quot;%@&amp;quot;,[str1 class]);\n    id str2 = [[NSString alloc] initWithString: @&amp;quot;Test&amp;quot;];\n    NSLog(@&amp;quot;%@&amp;quot;,[str2 class]);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;2018-05-01 23:43:25.941205+0800 RuntimeDemo[32783:1223167] NSString\n2018-05-01 23:43:25.941364+0800 RuntimeDemo[32783:1223167] __NSCFConstantString\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;333-其他类和对象相关的操作函数\&#34;&gt;3.3.3. 其他类和对象相关的操作函数&lt;/h4&gt;\n&lt;p&gt;类&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取已注册的类定义的列表\nint objc_getClassList(Class *buffer, int bufferCount);\n\n// 创建并返回一个指向所有已注册类的指针列表\nClass * objc_copyClassList (unsigned int * outCount);\n\n// 返回指定类的类定义\nClass objc_lookUpClass ( const char *name );\nClass objc_getClass ( const char *name );\nClass objc_getRequiredClass ( const char *name );\n \n// 返回指定类的元类\nClass objc_getMetaClass ( const char *name );\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对象&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;\n// 返回指定对象的一份拷贝\nid object_copy ( id obj, size_t size );\n \n// 释放指定对象占用的内存\nid object_dispose ( id obj );\n\n// 修改类实例的实例变量的值\nIvar object_setInstanceVariable ( id obj, const char *name, void *value );\n \n// 获取对象实例变量的值\nIvar object_getInstanceVariable ( id obj, const char *name, void **outValue );\n \n// 返回指向给定对象分配的任何额外字节的指针\nvoid * object_getIndexedIvars ( id obj );\n \n// 返回对象中实例变量的值\nid object_getIvar ( id obj, Ivar ivar );\n \n// 设置对象中实例变量的值\nvoid object_setIvar ( id obj, Ivar ivar, id value );\n\n// 返回给定对象的类名\nconst char * object_getClassName ( id obj );\n \n// 返回对象的类\nClass object_getClass ( id obj );\n \n// 设置对象的类\nClass object_setClass ( id obj, Class cls );\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;获取类的定义&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取已注册的类定义的列表\nint objc_getClassList (Class *)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;334-应用实例\&#34;&gt;3.3.4. 应用实例&lt;/h4&gt;\n&lt;h5 id=\&#34;1-json-转-model\&#34;&gt;1. Json 转 Model&lt;/h5&gt;\n&lt;p&gt;操作函数&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (instancetype)initWithDict:(NSDictionary *)dict {\n    if (self = [self init]) {\n        NSMutableArray &amp;lt;NSString *&amp;gt;*keys = [NSMutableArray array];\n        NSMutableArray &amp;lt;NSString *&amp;gt;*attributes = [NSMutableArray array];\n        \n        unsigned int outCount;\n        objc_property_t * propertyList = class_copyPropertyList([self class], &amp;amp;outCount);\n        for (unsigned int i = 0; i &amp;lt; outCount; i++) {\n            objc_property_t property = propertyList[i];\n            const char *name = property_getName(property);\n            NSString *propertyName = [NSString stringWithCString:name encoding:NSUTF8StringEncoding];\n            [keys addObject:propertyName];\n            \n            const char *attribute = property_getAttributes(property);\n            NSString *attributeName = [NSString stringWithCString:attribute encoding:NSUTF8StringEncoding];\n            [attributes addObject:attributeName];\n        }\n        free(propertyList);\n        for (NSString *key in keys) {\n            if ([dict valueForKey:key]) {\n                [self setValue:[dict valueForKey:key] forKey:key];\n            }\n        }\n    }\n    return self;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;2-快速归解档\&#34;&gt;2. 快速归解档&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;遵循 NSCoding 协议\n// 归档\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if (self = [super init]) {\n        unsigned int outCount;\n        Ivar * ivarList = class_copyIvarList([self class], &amp;amp;outCount);\n        for (unsigned int i = 0; i &amp;lt; outCount; i++) {\n            Ivar ivar = ivarList[i];\n            NSString *key = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding];\n            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];\n        }\n    }\n    return self;\n}\n// 解档\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n    unsigned int outCount;\n    Ivar * ivarList = class_copyIvarList([self class], &amp;amp;outCount);\n    for (unsigned int i = 0; i &amp;lt; outCount; i++) {\n        Ivar ivar = ivarList[i];\n        NSString *key = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding];\n        [aCoder encodeObject:[self valueForKey:key] forKey:key];\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (void)testCoder {\n    NSString *key = @&amp;quot;peopleKey&amp;quot;;\n    People * people = [[People alloc] init];\n    people.name = @&amp;quot;邱学伟&amp;quot;;\n    people.age = @18;\n    NSData *peopleData = [NSKeyedArchiver archivedDataWithRootObject:people];\n    [[NSUserDefaults standardUserDefaults] setObject:peopleData forKey:key];\n    \n    NSData *testData = [[NSUserDefaults standardUserDefaults] objectForKey:key];\n    People *testPeople = [NSKeyedUnarchiver unarchiveObjectWithData:testData];\n    NSLog(@&amp;quot;%@&amp;quot;,testPeople.name);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;3-关联对象\&#34;&gt;3. 关联对象&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 关联对象\nvoid objc_setAssociatedObject (id object, const void * key, id value, objc_AssociationPolicy policy);\n\n// 获取关联的对象\nid objc_getAssociatedObject (id object, const void * key);\n\n// 移除关联的对象\nvoid objc_removeAssociatedObjects (id object);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;参数说明&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;id object : 被关联的对象 \nconst void *key : 关联的key， set和get 需统一\nid value : 关联的对象\nobjc_AssociationPolicy policy : 内存管理的策略\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;objc_AssociationPolicy policy的enum值有：、&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**&amp;lt; Specifies a weak reference to the associated object. */\n    \n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&amp;lt; Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    \n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&amp;lt; Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    \n    OBJC_ASSOCIATION_RETAIN = 01401,       /**&amp;lt; Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    \n    OBJC_ASSOCIATION_COPY = 01403          /**&amp;lt; Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n\n};\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;应用实例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;//\n//  People+Category.h\n//  RuntimeDemo\n//\n//  Created by 邱学伟 on 2018/5/3.\n//  Copyright © 2018年 邱学伟. All rights reserved.\n//\n\n#import &amp;quot;People.h&amp;quot;\n@interface People (Category)\n/**\n 新增属性\n */\n@property (nonatomic, copy) NSString *blog;\n@end\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;//\n//  People+Category.m\n//  RuntimeDemo\n//\n//  Created by 邱学伟 on 2018/5/3.\n//  Copyright © 2018年 邱学伟. All rights reserved.\n//\n\n#import &amp;quot;People+Category.h&amp;quot;\n#import &amp;lt;objc/runtime.h&amp;gt;\n@implementation People (Category)\nstatic const char * cPeopleBlogKey = &amp;quot;cPeopleBlogKey&amp;quot;;\n- (NSString *)blog {\n    return objc_getAssociatedObject(self, cPeopleBlogKey);\n}\n- (void)setBlog:(NSString *)blog {\n    objc_setAssociatedObject(self, cPeopleBlogKey, blog, OBJC_ASSOCIATION_COPY);\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;4-方法与消息\&#34;&gt;4. 方法与消息&lt;/h2&gt;\n&lt;h3 id=\&#34;41-sel\&#34;&gt;4.1 SEL&lt;/h3&gt;\n&lt;p&gt;SEL 又叫方法选择器， 是表示一个方法的selector的指针，其定义如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;typedef  struct objc_selector *SEL;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;方法的selector用于表示运行时方法的名字，Objective-C在编译时，会根据每一个方法的名字，参数序列，生成一个唯一的整型标示（Int类型的地址），这个标识就是SEL. 如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;+ (void)load {\n    SEL sel = @selector(testMethod);\n    NSLog(@&amp;quot;Programmer sel = %p&amp;quot;,sel);\n}\n- (void)testMethod {\n    NSLog(@&amp;quot;testMethod&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差.&lt;br&gt;\n当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。&lt;/p&gt;\n&lt;p&gt;本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。&lt;/p&gt;\n&lt;p&gt;我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:&lt;/p&gt;\n&lt;p&gt;（1）sel_registerName函数&lt;/p&gt;\n&lt;p&gt;（2）Objective-C编译器提供的@selector()&lt;/p&gt;\n&lt;p&gt;（3）NSSelectorFromString()方法&lt;/p&gt;\n&lt;h3 id=\&#34;42-imp\&#34;&gt;4.2 IMP&lt;/h3&gt;\n&lt;p&gt;IMP 是一个函数指针，指向方法实现的首地址。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;id (*IMP)(id,SEL,...)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。&lt;/p&gt;\n&lt;p&gt;前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。&lt;/p&gt;\n&lt;p&gt;通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。&lt;/p&gt;\n&lt;h3 id=\&#34;43-method\&#34;&gt;4.3 Method&lt;/h3&gt;\n&lt;p&gt;Method 用于表示类定义中的方法，定义如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;typedef struct objc_method *Method;\n\nstruct objc_method {\n     SEL method_name OBJC2_UNAVAILABLE; // 方法名\n     char *method_types OBJC2_UNAVAILABLE; //是个char指针，存储着方法的参数类型和返回值类型\n     IMP method_imp OBJC2_UNAVAILABLE; // 方法实现，函数指针\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。&lt;/p&gt;\n&lt;h3 id=\&#34;44-objc_method_description\&#34;&gt;4.4 objc_method_description&lt;/h3&gt;\n&lt;p&gt;objc_method_description定义了一个Objective-C方法，其定义如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;struct objc_method_description { SEL name; char *types; };\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;45-method-相关操作函数\&#34;&gt;4.5 Method 相关操作函数&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt; // 调用指定方法的实现\n    id method_invoke (id receiver, Method m, ...);\n    \n    // 调用返回一个数据结构的方法的实现\n    void method_invoke_stret (id receiver, Method m, ...);\n    \n    // 获取方法名\n    SEL method_getName (Method m);\n    \n    // 获取方法的实现\n    IMP method_getImplementation (Method m);\n    \n    // 获取描述方法参数和返回值类型的字符串\n    const char * method_getTypeEncoding (Method m);\n    \n    // 获取方法的返回值类型的字符串\n    char * method_copyReturnType ( Method m );\n    \n    // 获取方法的指定位置参数的类型字符串\n    char * method_copyArgumentType ( Method m, unsigned int index );\n    \n    // 通过引用返回方法的返回值类型字符串\n    void method_getReturnType ( Method m, char *dst, size_t dst_len );\n    \n    // 返回方法的参数的个数\n    unsigned int method_getNumberOfArguments ( Method m );\n    \n    // 通过引用返回方法指定位置参数的类型字符串\n    void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );\n    \n    // 返回指定方法的方法描述结构体\n    struct objc_method_description * method_getDescription ( Method m );\n    \n    // 设置方法的实现\n    IMP method_setImplementation ( Method m, IMP imp );\n    \n    // 交换两个方法的实现\n    void method_exchangeImplementations ( Method m1, Method m2 );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;（1）method_invoke函数，返回的是实际实现的返回值。参数receiver不能为空。这个方法的效率会比method_getImplementation和method_getName更快。&lt;/p&gt;\n&lt;p&gt;（2）method_getName函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用sel_getName(method_getName(method))。&lt;/p&gt;\n&lt;p&gt;（3）method_getReturnType函数，类型字符串会被拷贝到dst中。&lt;/p&gt;\n&lt;p&gt;（4）method_setImplementation函数，注意该函数返回值是方法之前的实现。&lt;/p&gt;\n&lt;h3 id=\&#34;46-方法选择器\&#34;&gt;4.6 方法选择器&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 返回给定选择器指定的方法的名称\nconst char * sel_getName ( SEL sel );\n\n// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器\nSEL sel_registerName ( const char *str );\n\n// 在Objective-C Runtime系统中注册一个方法\nSEL sel_getUid ( const char *str );\n\n// 比较两个选择器\nBOOL sel_isEqual ( SEL lhs, SEL rhs );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;sel_registerName函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。&lt;/p&gt;\n&lt;h3 id=\&#34;47-方法调用流程\&#34;&gt;4.7 方法调用流程&lt;/h3&gt;\n&lt;h4 id=\&#34;1-消息发送\&#34;&gt;1. 消息发送&lt;/h4&gt;\n&lt;p&gt;在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;objc_msgSend(receiver, selector)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果消息中还有其他参数，则该方法的形式如下所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;objc_msgSend(receiver, selector，arg1, arg2, ...);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个函数完成了动态绑定的所有事情：&lt;/p&gt;\n&lt;p&gt;（1）首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。&lt;/p&gt;\n&lt;p&gt;（2）它调用方法实现，并将接收者对象及方法的所有参数传给它。&lt;/p&gt;\n&lt;p&gt;（3）最后，它将实现返回的值作为它自己的返回值。&lt;/p&gt;\n&lt;p&gt;消息的关键在于结构体 objc_class, 这个结构体有两个字段是我们在分发消息的时候关注的：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;指向父类的指针。&lt;/li&gt;\n&lt;li&gt;一个类的方法分发表，即methodLists&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。&lt;/p&gt;\n&lt;p&gt;下图演示了这样一个消息的基本框架：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://raw.githubusercontent.com/qxuewei/XWResources/master/images/runtime_msgSend.gif\&#34; alt=\&#34;消息的基本框架\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程&lt;/p&gt;\n&lt;h4 id=\&#34;2-隐藏参数\&#34;&gt;2. 隐藏参数&lt;/h4&gt;\n&lt;p&gt;objc_msgSend 有两个隐藏参数&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;消息接收对象&lt;/li&gt;\n&lt;li&gt;方法的selector&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为他们在定义方法的源代码中没有声明。他们是在编译时被插入实现代码的。&lt;/p&gt;\n&lt;p&gt;虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用_cmd 来引用选择器。如下代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- strange\n{\n    id  target = getTheReceiver();\n    SEL method = getTheMethod();\n    if ( target == self || method == _cmd )\n        return nil;\n    return [target performSelector:method];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当然，这两个参数我们用的比较多的是self，_cmd 在实际中用得比较少。&lt;/p&gt;\n&lt;h4 id=\&#34;3-获取方法地址\&#34;&gt;3. 获取方法地址&lt;/h4&gt;\n&lt;p&gt;Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。&lt;/p&gt;\n&lt;p&gt;我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。&lt;/p&gt;\n&lt;p&gt;NSObject类提供了methodForSelector:方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将methodForSelector:返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。&lt;/p&gt;\n&lt;p&gt;这里需要注意的就是函数指针的前两个参数必须是id和SEL。&lt;/p&gt;\n&lt;p&gt;当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，methodForSelector:是由Cocoa运行时提供的；它不是Objective-C语言的特性。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (void)testCommonMethod {\n    for (int i = 0; i &amp;lt; 10000; i++) {\n        [self logMethod:i];\n    }\n    //执行时长: Test Case &#39;-[RuntimeDemoTests testCommonMethod]&#39; passed (2.311 seconds).\n}\n\n- (void)testRuntimeMethod {\n    void(*logM)(id, SEL, int);\n    IMP imp = [self methodForSelector:@selector(logMethod:)];\n    logM = (void(*)(id, SEL, int))imp;\n    for (int i = 0; i &amp;lt; 10000; i++) {\n        logM(self, @selector(logMethod:), i);\n    }\n    //执行时长: Test Case &#39;-[RuntimeDemoTests testRuntimeMethod]&#39; passed (2.199 seconds).\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;4-消息转发\&#34;&gt;4. 消息转发&lt;/h4&gt;\n&lt;p&gt;当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。&lt;/p&gt;\n&lt;p&gt;通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// perform方法要求传入参数必须是对象，如果方法本身的参数是int，直接传NSNumber会导致得到的int参数不正确\nif ([self respondsToSelector:@selector(logMethod:)]) {\n        [self performSelector:@selector(logMethod:) withObject:[NSNumber numberWithInt:10086]];\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当一个对象无法接收某一消息时，就会启动所谓”消息转发(message forwarding)“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;unrecognized selector sent to instance 0x100111940&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。&lt;/p&gt;\n&lt;p&gt;消息转发机制基本上分为三个步骤：&lt;/p&gt;\n&lt;p&gt;（1）动态方法解析&lt;/p&gt;\n&lt;p&gt;（2）备用接收者&lt;/p&gt;\n&lt;p&gt;（3）完整转发&lt;/p&gt;\n&lt;h5 id=\&#34;1-动态方法解析\&#34;&gt;1.  动态方法解析&lt;/h5&gt;\n&lt;pre&gt;&lt;code&gt;对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示：\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;void functionForMethod (id self, SEL _cmd) {\n    NSLog(@&amp;quot;functionForMethod&amp;quot;);\n}\n/// 调用未实现对象方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    NSString *selName = NSStringFromSelector(sel);\n    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {\n        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n/// 调用未实现类方法\n+ (BOOL)resolveClassMethod:(SEL)sel {\n    NSString *selName = NSStringFromSelector(sel);\n    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {\n        //v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\n        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;2-备用接受者\&#34;&gt;2.  备用接受者&lt;/h5&gt;\n&lt;pre&gt;&lt;code&gt;如果在上一步无法处理消息，则Runtime会继续调以下方法：\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。&lt;/p&gt;\n&lt;p&gt;使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;//\n//  People.m\n//  RuntimeDemo\n//\n//  Created by 邱学伟 on 2018/4/27.\n//  Copyright © 2018年 邱学伟. All rights reserved.\n//\n\n#import &amp;quot;People.h&amp;quot;\n#import &amp;lt;objc/runtime.h&amp;gt;\n\n@interface XWPeople : NSObject\n- (void)people2log;\n@end\n@implementation XWPeople\n- (void)people2log {\n    NSLog(@&amp;quot;people2log&amp;quot;);\n}\n@end\n\n@interface People () &amp;lt;NSCoding&amp;gt; {\n}\n@property (nonatomic, strong) XWPeople *xw_people;\n@end\n@implementation People\n\n//// 1 级处理\nvoid functionForMethod (id self, SEL _cmd) {\n    NSLog(@&amp;quot;functionForMethod&amp;quot;);\n}\n/// 调用未实现对象方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    NSString *selName = NSStringFromSelector(sel);\n    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {\n        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n/// 调用未实现类方法\n+ (BOOL)resolveClassMethod:(SEL)sel {\n    NSString *selName = NSStringFromSelector(sel);\n    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {\n        //v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\n        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n\n/// 2 级处理\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    NSString *selName = NSStringFromSelector(aSelector);\n    if ([selName isEqualToString:@&amp;quot;people2log&amp;quot;]) {\n        return self.xw_people;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n- (XWPeople *)xw_people {\n    if(!_xw_people){\n        _xw_people = [[XWPeople alloc] init];\n    }\n    return _xw_people;\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。&lt;/p&gt;\n&lt;h5 id=\&#34;3-完整转发\&#34;&gt;3.  完整转发&lt;/h5&gt;\n&lt;p&gt;如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象。&lt;/p&gt;\n&lt;p&gt;forwardInvocation:方法的实现有两个任务：&lt;/p&gt;\n&lt;p&gt;（1）定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。&lt;/p&gt;\n&lt;p&gt;（2）使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。&lt;/p&gt;\n&lt;p&gt;不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。&lt;/p&gt;\n&lt;p&gt;还有一个很重要的问题，我们必须重写以下方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。&lt;/p&gt;\n&lt;p&gt;完整的示例如下所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;//\n//  People.m\n//  RuntimeDemo\n//\n//  Created by 邱学伟 on 2018/4/27.\n//  Copyright © 2018年 邱学伟. All rights reserved.\n//\n\n#import &amp;quot;People.h&amp;quot;\n#import &amp;lt;objc/runtime.h&amp;gt;\n\n@interface XWPeople : NSObject\n- (void)people2log;\n- (void)people3log;\n@end\n@implementation XWPeople\n- (void)people2log {\n    NSLog(@&amp;quot;people2log&amp;quot;);\n}\n\n- (void)people3log {\n    NSLog(@&amp;quot;people3log&amp;quot;);\n}\n@end\n\n@interface People () &amp;lt;NSCoding&amp;gt; {\n}\n@property (nonatomic, strong) XWPeople *xw_people;\n@end\n@implementation People\n\n//// 1 级处理\nvoid functionForMethod (id self, SEL _cmd) {\n    NSLog(@&amp;quot;functionForMethod&amp;quot;);\n}\n/// 调用未实现对象方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    NSString *selName = NSStringFromSelector(sel);\n    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {\n        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n/// 调用未实现类方法\n+ (BOOL)resolveClassMethod:(SEL)sel {\n    NSString *selName = NSStringFromSelector(sel);\n    if ([selName isEqualToString:@&amp;quot;methodNull&amp;quot;]) {\n        //v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\n        class_addMethod(self.class, sel, (IMP)functionForMethod, &amp;quot;v@:&amp;quot;);\n        return YES;\n    }\n    return [super resolveClassMethod:sel];\n}\n\n/// 2 级处理\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    NSString *selName = NSStringFromSelector(aSelector);\n    if ([selName isEqualToString:@&amp;quot;people2log&amp;quot;]) {\n        return self.xw_people;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n- (XWPeople *)xw_people {\n    if(!_xw_people){\n        _xw_people = [[XWPeople alloc] init];\n    }\n    return _xw_people;\n}\n\n/// 3 级处理\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];\n    if (!signature) {\n        if ([XWPeople instancesRespondToSelector:aSelector]) {\n            signature = [XWPeople instanceMethodSignatureForSelector:aSelector];\n        }\n    }\n    return signature;\n}\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    if ([XWPeople instancesRespondToSelector:anInvocation.selector]) {\n        [anInvocation invokeWithTarget:self.xw_people];\n    }\n}\n\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。&lt;/p&gt;\n&lt;p&gt;从某种意义上来讲，forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。&lt;/p&gt;\n&lt;h5 id=\&#34;4-消息转发与多重继承\&#34;&gt;4、消息转发与多重继承&lt;/h5&gt;\n&lt;p&gt;回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。&lt;/p&gt;\n&lt;p&gt;不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如respondsToSelector:和isKindOfClass:只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (BOOL)respondsToSelector:(SEL)aSelector   {\n       if ( [super respondsToSelector:aSelector] )         \n       \t\treturn YES;     \n       else {          \n       \t\t/* Here, test whether the aSelector message can     *            \n      \t\t * be forwarded to another object and whether that  *            \n      \t\t* object can respond to it. Return YES if it can.  */      \n       }\n      return NO;  \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;46-method-swizzling\&#34;&gt;4.6 Method Swizzling&lt;/h3&gt;\n&lt;h4 id=\&#34;461-概述\&#34;&gt;4.6.1 概述&lt;/h4&gt;\n&lt;p&gt;Objective-C 中的 Method Swizzling 是一项异常强大的技术，它可以允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。&lt;/p&gt;\n&lt;h4 id=\&#34;462-原理\&#34;&gt;4.6.2 原理&lt;/h4&gt;\n&lt;p&gt;Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。所以下面两个方法在 runtime 看来就是同一个方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (void)viewWillAppear:(BOOL)animated;\n- (void)viewWillAppear:(NSString *)string;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;而下面两个方法却是可以共存的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (void)viewWillAppear:(BOOL)animated;\n+ (void)viewWillAppear:(BOOL)animated;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为实例方法和类方法是分别保存在类对象和元类对象中的。&lt;/p&gt;\n&lt;p&gt;原则上，方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的&lt;/p&gt;\n&lt;p&gt;原有方法和实现的对应关系如下图：&lt;br&gt;\n&lt;img src=\&#34;https://github.com/qxuewei/XWResources/blob/master/images/Swizzling_1.png?raw=true\&#34; alt=\&#34;原有方法和实现的对应关系\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;通过runtime可实现：&lt;br&gt;\n&lt;img src=\&#34;https://github.com/qxuewei/XWResources/blob/master/images/Swizzling_2.png?raw=true\&#34; alt=\&#34;runtime 调整的对应关系\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;在OC语言的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的SEL，这个SEL对应着一个IMP(一个IMP可以对应多个SEL)，通过这个IMP找到对应的方法调用。&lt;/p&gt;\n&lt;p&gt;在每个类中都有一个Dispatch Table，这个Dispatch Table本质是将类中的SEL和IMP(可以理解为函数指针)进行对应。而我们的Method Swizzling就是对这个table进行了操作，让SEL对应另一个IMP。&lt;/p&gt;\n&lt;h4 id=\&#34;463-使用注意\&#34;&gt;4.6.3 使用注意&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;Swizzling应该总在+load中执行：Objective-C在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载&lt;/li&gt;\n&lt;li&gt;Swizzling应该总是在dispatch_once中执行：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。&lt;/li&gt;\n&lt;li&gt;Selector，Method和Implementation：这几个之间关系可以这样理解，一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个Method，其中key是一个特定的名称，及SEL，与其对应的实现是IMP即指向底层C函数的指针。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;464-应用实例\&#34;&gt;4.6.4 应用实例&lt;/h4&gt;\n&lt;h5 id=\&#34;1-替换方法实现\&#34;&gt;1. 替换方法实现&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;//  ViewController+Method.m\n//  RuntimeDemo\n//\n//  Created by 邱学伟 on 2018/5/4.\n//  Copyright © 2018年 邱学伟. All rights reserved.\n//\n\n#import &amp;quot;ViewController+Method.h&amp;quot;\n#import &amp;lt;objc/runtime.h&amp;gt;\n\n@implementation ViewController (Method)\n+ (void)load {\n    [super load];\n    [self exchangeMethod];\n}\n\n/// runtime 交换方法\n+ (void)exchangeMethod {\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;amp;onceToken, ^{\n        Class class = [self class];\n        \n        SEL originSel = @selector(viewWillAppear:);\n        SEL swizzledSel = @selector(xw_viewWillAppear:);\n        \n        Method originMethod = class_getInstanceMethod(class, originSel);\n        Method swizzledMethod = class_getInstanceMethod(class, swizzledSel);\n        \n        //先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况\n        BOOL isAddMethod = class_addMethod(class, originSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));\n        if (isAddMethod) {\n            class_replaceMethod(class, swizzledSel, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));\n        }else{\n            method_exchangeImplementations(originMethod, swizzledMethod);\n        }\n    });\n}\n- (void)xw_viewWillAppear:(BOOL)animation {\n    [self xw_viewWillAppear:animation];\n    NSLog(@&amp;quot;xw_viewWillAppear - %@&amp;quot;,self);\n}\n@end\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;2-method-swizzling类簇\&#34;&gt;2、Method Swizzling类簇&lt;/h5&gt;\n&lt;p&gt;在我们项目开发过程中，经常因为NSArray数组越界或者NSDictionary的key或者value值为nil等问题导致的崩溃，我们可以尝试使用前面知识对NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等类进行Method Swizzling，但是结果发现Method Swizzling根本就不起作用，到底为什么呢？&lt;/p&gt;\n&lt;p&gt;这是因为Method Swizzling对NSArray这些的类簇是不起作用的。因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用NSArray的objectAtIndex:方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。&lt;/p&gt;\n&lt;p&gt;所以也就是我们对NSArray类进行操作其实只是对父类进行了操作，在NSArray内部会创建其他子类来执行操作，真正执行操作的并不是NSArray自身，所以我们应该对其“真身”进行操作。&lt;/p&gt;\n&lt;p&gt;下面我们实现了防止NSArray因为调用objectAtIndex:方法，取下标时数组越界导致的崩溃：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;#import &amp;quot;NSArray+ MyArray.h&amp;quot;\n#import &amp;quot;objc/runtime.h&amp;quot;\n@implementation NSArray MyArray)\n+ (void)load {\n    Method fromMethod = class_getInstanceMethod(objc_getClass(&amp;quot;__NSArrayI&amp;quot;), @selector(objectAtIndex:));\n    Method toMethod = class_getInstanceMethod(objc_getClass(&amp;quot;__NSArrayI&amp;quot;), @selector(my_objectAtIndex:));\n    method_exchangeImplementations(fromMethod, toMethod);\n}\n\n- (id)my_objectAtIndex:(NSUInteger)index {\n    if (self.count-1 &amp;lt; index) {\n        // 这里做一下异常处理，不然都不知道出错了。\n        @try {\n            return [self my_objectAtIndex:index];\n        }\n        @catch (NSException *exception) {\n            // 在崩溃后会打印崩溃信息，方便我们调试。\n            NSLog(@&amp;quot;---------- %s Crash Because Method %s  ----------\\n&amp;quot;, class_getName(self.class), __func__);\n            NSLog(@&amp;quot;%@&amp;quot;, [exception callStackSymbols]);\n            return nil;\n    }\n        @finally {}\n    } else {\n        return [self my_objectAtIndex:index];\n    }\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;常见类簇真身：&lt;br&gt;\n&lt;img src=\&#34;https://github.com/qxuewei/XWResources/blob/master/images/runtime_%E7%B1%BB%E7%B0%87%E7%9C%9F%E8%BA%AB.png?raw=true\&#34; alt=\&#34;类簇\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;5-protocol-和-category\&#34;&gt;5. Protocol 和 Category&lt;/h2&gt;\n&lt;h3 id=\&#34;51-category\&#34;&gt;5.1 Category&lt;/h3&gt;\n&lt;p&gt;指向分类的结构体的指针&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;typedef struct objc_category *Category;\n\nstruct objc_category {\n     char *category_name OBJC2_UNAVAILABLE; // 分类名\n     char *class_name OBJC2_UNAVAILABLE; // 分类所属的类名\n     struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表\n     struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表，Meta Class方法列表的子集\n     struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;示例代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;//\n//  main.m\n//  RuntimeDemo\n//\n//  Created by 邱学伟 on 2018/4/27.\n//  Copyright © 2018年 邱学伟. All rights reserved.\n//\n\n#import &amp;lt;UIKit/UIKit.h&amp;gt;\n#import &amp;quot;AppDelegate.h&amp;quot;\n\n@interface NSObject (Fuck)\n+ (void)foo;\n@end\n\n@implementation NSObject (Fuck)\n- (void)foo {\n    NSLog(@&amp;quot;我是Foo %@&amp;quot;,[self class]);\n}\n@end\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        \n        [NSObject foo];\n        [[NSObject new] foo];\n        \n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;2018-05-04 16:23:26.643100+0800 RuntimeDemo[48558:2377362] 我是Foo NSObject\n2018-05-04 16:23:26.644354+0800 RuntimeDemo[48558:2377362] 我是Foo NSObject\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;objc runtime加载后NSObject的Sark Category被加载，头文件+(void)foo没有IMP，只会出现一个warning。被加到Class的Method list里的方法只有-(void)foo，Meta Class的方法列表里没有。&lt;/p&gt;\n&lt;p&gt;执行[NSObject foo]时，会在Meta Class的Method list里找，找不着就继续往super class里找，NSObject Meta Clas的super class是NSObject本身，这时在NSObject的Method list里就有foo这个方法了，能够正常输出。&lt;/p&gt;\n&lt;p&gt;执行[[NSObject new] foo]就简单的多了，[NSObject new]生成一个实例，实例的Method list是有foo方法的，于是正常输出。&lt;/p&gt;\n&lt;p&gt;如果换做其他类就会报错了&lt;/p&gt;\n&lt;h3 id=\&#34;52-protocol\&#34;&gt;5.2 Protocol&lt;/h3&gt;\n&lt;p&gt;Protocol其实就是一个对象结构体&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;typedef struct objc_object Protocol;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;操作函数:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 返回指定的协议\nProtocol * objc_getProtocol ( const char *name );\n// 获取运行时所知道的所有协议的数组\nProtocol ** objc_copyProtocolList ( unsigned int *outCount );\n// 创建新的协议实例\nProtocol * objc_allocateProtocol ( const char *name );\n// 在运行时中注册新创建的协议\nvoid objc_registerProtocol ( Protocol *proto ); //创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。\n// 为协议添加方法\nvoid protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );\n// 添加一个已注册的协议到协议中\nvoid protocol_addProtocol ( Protocol *proto, Protocol *addition );\n// 为协议添加属性\nvoid protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );\n// 返回协议名\nconst char * protocol_getName ( Protocol *p );\n// 测试两个协议是否相等\nBOOL protocol_isEqual ( Protocol *proto, Protocol *other );\n// 获取协议中指定条件的方法的方法描述数组\nstruct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );\n// 获取协议中指定方法的方法描述\nstruct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );\n// 获取协议中的属性列表\nobjc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );\n// 获取协议的指定属性\nobjc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );\n// 获取协议采用的协议\nProtocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );\n// 查看协议是否采用了另一个协议\nBOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;6-补充\&#34;&gt;6. 补充&lt;/h2&gt;\n&lt;h3 id=\&#34;61-super\&#34;&gt;6.1 Super&lt;/h3&gt;\n&lt;p&gt;在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到super，如下所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;@interface MyViewController: UIViewController\n@end\n@implementation MyViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // do something\n    ...\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;struct objc_super { id receiver; Class superClass; };\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个结构体有两个成员：&lt;/p&gt;\n&lt;p&gt;（1）receiver：即消息的实际接收者&lt;/p&gt;\n&lt;p&gt;（2）superClass：指针当前类的父类&lt;/p&gt;\n&lt;p&gt;当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是MyViewController对象，与self相同；superClass指向MyViewController的父类UIViewController。&lt;/p&gt;\n&lt;p&gt;接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc-&amp;gt;receiver去调用这个selector，而此时的操作就是如下方式了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;objc_msgSend(objc_super-&amp;gt;receiver, @selector(viewDidLoad))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于objc_super-&amp;gt;receiver就是self本身，所以该方法实际与下面这个调用是相同的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;objc_msgSend(self, @selector(viewDidLoad))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;+ (void)load {\n    [super load];\n    NSLog(@&amp;quot;self class: %@&amp;quot;, self.class);\n    NSLog(@&amp;quot;super class: %@&amp;quot;, super.class);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;2018-05-04 15:19:45.264902+0800 RuntimeDemo[47032:2208798] self class: ViewController\n2018-05-04 15:19:45.265792+0800 RuntimeDemo[47032:2208798] super class: ViewController\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;62-库相关操作\&#34;&gt;6.2 库相关操作&lt;/h3&gt;\n&lt;p&gt;库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 获取所有加载的Objective-C框架和动态库的名称\nconst char ** objc_copyImageNames ( unsigned int *outCount );\n\n// 获取指定类所在动态库\nconst char * class_getImageName ( Class cls );\n\n// 获取指定库或框架中所有类的类名\nconst char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。如下代码所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (void)testImage {\n    NSLog(@&amp;quot;获取指定类所在动态库&amp;quot;);\n    NSLog(@&amp;quot;UIView&#39;s Framework: %s&amp;quot;, class_getImageName(NSClassFromString(@&amp;quot;UIView&amp;quot;)));\n    NSLog(@&amp;quot;获取指定库或框架中所有类的类名&amp;quot;);\n    unsigned int outCount;\n    const char ** classes = objc_copyClassNamesForImage(class_getImageName(NSClassFromString(@&amp;quot;UIView&amp;quot;)), &amp;amp;outCount);\n    for (int i = 0; i &amp;lt; outCount; i++) {\n        NSLog(@&amp;quot;class name: %s&amp;quot;, classes[i]);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;2018-05-04 15:30:51.342342+0800 RuntimeDemo[47333:2253385] 获取指定类所在动态库\n2018-05-04 15:30:51.342499+0800 RuntimeDemo[47333:2253385] UIView&#39;s Framework: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/UIKit.framework/UIKit\n2018-05-04 15:30:51.342620+0800 RuntimeDemo[47333:2253385] 获取指定库或框架中所有类的类名\n2018-05-04 15:30:51.343164+0800 RuntimeDemo[47333:2253385] class name: UIGestureKeyboardIntroduction\n2018-05-04 15:30:51.343269+0800 RuntimeDemo[47333:2253385] class name: _UIPreviewPresentationPlatterView\n2018-05-04 15:30:51.343364+0800 RuntimeDemo[47333:2253385] class name: UIKeyboardUISettings\n2018-05-04 15:30:51.343456+0800 RuntimeDemo[47333:2253385] class name: _UIFocusScrollManager\n2018-05-04 15:30:51.343550+0800 RuntimeDemo[47333:2253385] class name: _UIPickerViewTopFrame\n2018-05-04 15:30:51.343655+0800 RuntimeDemo[47333:2253385] class name: _UIOnePartImageView\n2018-05-04 15:30:51.343749+0800 RuntimeDemo[47333:2253385] class name: _UIPickerViewSelectionBar\n。。。。。。。。。。。。。。。。。。。。。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;63-块操作\&#34;&gt;6.3 块操作&lt;/h3&gt;\n&lt;p&gt;我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 创建一个指针函数的指针，该函数调用时会调用特定的block\nIMP imp_implementationWithBlock ( id block );\n\n// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block\nid imp_getBlock ( IMP anImp );\n\n// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝\nBOOL imp_removeBlock ( IMP anImp );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。如下代码所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;- (void)testBlock {\n    IMP imp = imp_implementationWithBlock(^(id obj, NSString *str) {\n        NSLog(@&amp;quot;testBlock - %@&amp;quot;,str);\n    });\n    class_addMethod(self.class, @selector(testBlock:), imp, &amp;quot;v@:@&amp;quot;);\n    [self performSelector:@selector(testBlock:) withObject:@&amp;quot;邱学伟!&amp;quot;];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;2018-05-04 15:41:47.221228+0800 RuntimeDemo[47587:2282146] testBlock - 邱学伟!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;64-弱引用操作\&#34;&gt;6.4 弱引用操作&lt;/h3&gt;\n&lt;p&gt;操作函数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objective-c\&#34;&gt;// 加载弱引用指针引用的对象并返回\nid objc_loadWeak ( id *location );\n\n// 存储__weak变量的新值\nid objc_storeWeak ( id *location, id obj );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。&lt;/p&gt;\n&lt;p&gt;objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ios-runtime-xiang-jie&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;ios-runtime-详解\&#34;&gt;iOS - Runtime 详解&lt;/h1&gt;\n&lt;h2 id=\&#34;0-概述\&#34;&gt;0. 概述&lt;/h2&gt;\n&lt;p&gt;Objective-C Runtime 使得C具有了面向对象的能力，在程序运行时创建，检查，修改类，对象和它们的方法。Runtime 是 C和汇编写的，这里&lt;a href=\&#34;http://www.opensource.apple.com/source/objc4/\&#34;&gt;http://www.opensource.apple.com/source/objc4/&lt;/a&gt;可以下载Apple维护的开源代码，GUN也有一个开源的Runtime版本，它们都努力保持一致。&lt;a href=\&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048\&#34;&gt;Apple官方的runtime编程指南&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;对于 C 语言，函数的调用会在编译期就已经决定好，在编译完成后直接顺序执行。但是 OC 是一门动态语言，函数调用变成了消息发送，在编译期不能知道调用哪个函数，Runtime 就是去解决如何在运行时期找到调用方法的问题。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;iOS - Runtime 详解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;iOS 基础&#34;,&#34;slug&#34;:&#34;PmC0N8rc0&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/PmC0N8rc0/&#34;}],&#34;date&#34;:&#34;2020-06-12 16:02:19&#34;,&#34;dateFormat&#34;:&#34;2020-06-12&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2020.06.12.15919490869236.lev-photion-C_7NlFnTVXY-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/ios-runtime-xiang-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;50 min read&#34;,&#34;time&#34;:2971000,&#34;words&#34;:11481,&#34;minutes&#34;:50},&#34;description&#34;:&#34;iOS - Runtime 详解\n0. 概述\nObjective-C Runtime 使得C具有了面向对象的能力，在程序运行时创建，检查，修改类，对象和它们的方法。Runtime 是 C和汇编写的，这里http://www.opensour...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#ios-runtime-%E8%AF%A6%E8%A7%A3\&#34;&gt;iOS - Runtime 详解&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#0-%E6%A6%82%E8%BF%B0\&#34;&gt;0. 概述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-runtime-%E5%87%BD%E6%95%B0\&#34;&gt;1、Runtime 函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-class-%E5%92%8C-nsobject-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\&#34;&gt;2. Class 和 NSObject 基础数据结构&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#21-class\&#34;&gt;2.1 Class&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#22-objc_object\&#34;&gt;2.2 objc_object&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#23-cache_t\&#34;&gt;2.3 cache_t&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#24-meta-class\&#34;&gt;2.4 Meta Class&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3runtime-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\&#34;&gt;3.Runtime 类与对象操作函数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#31%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\&#34;&gt;3.1类相关操作函数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#name\&#34;&gt;name&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#super_class-%E5%92%8C-meta_class\&#34;&gt;super_class 和 meta_class&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#instance_size\&#34;&gt;instance_size&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#32-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8Fivars%E5%8F%8A%E5%B1%9E%E6%80%A7\&#34;&gt;3.2 成员变量（ivars）及属性&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#321-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\&#34;&gt;3.2.1 成员变量操作函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#322-%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\&#34;&gt;3.2.2 属性操作函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#323-%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\&#34;&gt;3.2.3 协议相关函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#324-%E7%89%88%E6%9C%AC%E5%8F%B7\&#34;&gt;3.2.4 版本号&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#33-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\&#34;&gt;3.3 动态创建类和对象&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#331-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB\&#34;&gt;3.3.1. 动态创建类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#332-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\&#34;&gt;3.3.2. 动态创建对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#333-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\&#34;&gt;3.3.3. 其他类和对象相关的操作函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#334-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B\&#34;&gt;3.3.4. 应用实例&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-json-%E8%BD%AC-model\&#34;&gt;1. Json 转 Model&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%BF%AB%E9%80%9F%E5%BD%92%E8%A7%A3%E6%A1%A3\&#34;&gt;2. 快速归解档&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1\&#34;&gt;3. 关联对象&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B6%88%E6%81%AF\&#34;&gt;4. 方法与消息&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#41-sel\&#34;&gt;4.1 SEL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#42-imp\&#34;&gt;4.2 IMP&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#43-method\&#34;&gt;4.3 Method&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#44-objc_method_description\&#34;&gt;4.4 objc_method_description&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#45-method-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\&#34;&gt;4.5 Method 相关操作函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#46-%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9%E5%99%A8\&#34;&gt;4.6 方法选择器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#47-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B\&#34;&gt;4.7 方法调用流程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81\&#34;&gt;1. 消息发送&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0\&#34;&gt;2. 隐藏参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%9C%B0%E5%9D%80\&#34;&gt;3. 获取方法地址&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91\&#34;&gt;4. 消息转发&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90\&#34;&gt;1.  动态方法解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%A4%87%E7%94%A8%E6%8E%A5%E5%8F%97%E8%80%85\&#34;&gt;2.  备用接受者&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%AE%8C%E6%95%B4%E8%BD%AC%E5%8F%91\&#34;&gt;3.  完整转发&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E4%B8%8E%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\&#34;&gt;4、消息转发与多重继承&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#46-method-swizzling\&#34;&gt;4.6 Method Swizzling&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#461-%E6%A6%82%E8%BF%B0\&#34;&gt;4.6.1 概述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#462-%E5%8E%9F%E7%90%86\&#34;&gt;4.6.2 原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#463-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F\&#34;&gt;4.6.3 使用注意&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#464-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B\&#34;&gt;4.6.4 应用实例&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0\&#34;&gt;1. 替换方法实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-method-swizzling%E7%B1%BB%E7%B0%87\&#34;&gt;2、Method Swizzling类簇&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-protocol-%E5%92%8C-category\&#34;&gt;5. Protocol 和 Category&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#51-category\&#34;&gt;5.1 Category&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#52-protocol\&#34;&gt;5.2 Protocol&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E8%A1%A5%E5%85%85\&#34;&gt;6. 补充&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#61-super\&#34;&gt;6.1 Super&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#62-%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C\&#34;&gt;6.2 库相关操作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#63-%E5%9D%97%E6%93%8D%E4%BD%9C\&#34;&gt;6.3 块操作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#64-%E5%BC%B1%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C\&#34;&gt;6.4 弱引用操作&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;多线程同时访问同一块资源会造成资源抢夺，容易引发数据错乱和数据安全问题，此时我们需要保证资源同时只有一个线程访问，加锁就是为了解决这个问题。&lt;/p&gt;\n&lt;p&gt;常用的加锁方式：（性能由差到好）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;OSSpinLock&lt;/code&gt; 自旋锁，存在优先级反转问题，破坏了 spinLock，后来Apple推出 &lt;code&gt;os_unfair_lock_t&lt;/code&gt; 解决优先级翻转问题&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt; 信号量&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;pthread_mutex&lt;/code&gt; 互斥锁 （C语言）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSLock&lt;/code&gt; 对象锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSCondition&lt;/code&gt; 条件锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt; 递归锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 条件锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;@synchronized&lt;/code&gt; 性能最差&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;各种锁的性能比较&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.06.11.15918541083583.15910531507405.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;自旋锁\&#34;&gt;自旋锁&lt;/h2&gt;\n&lt;h3 id=\&#34;osspinlock-os_unfair_lock\&#34;&gt;&#39;OSSpinLock&#39;、&#39;os_unfair_lock&#39;&lt;/h3&gt;\n&lt;p&gt;&#39;OSSpinLock&#39; 是一种自旋锁，和互斥锁类似，都是为了保证线程安全的锁。对于互斥锁，当一个线程获得这个锁以后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放；自旋锁，当一个线程获得锁之后，其他线程将会一直循环查看该锁是否被释放，此锁适用于锁的持有者保存时间较短的情况。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;spinLock = OS_SPINLOCK_INIT;\nOSSpinLockLock(&amp;amp;spinLock);\nsleep(4);\nOSSpinLockUnlock(&amp;amp;spinLock);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&#39;OSSpinLock&#39; 不再安全了？ 因为存在优先级翻转的问题。&lt;br&gt;\n在新版本iOS系统中，系统维护了5个不同的线程优先级(Qos): background, utility, default, user-initiated, user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比他更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级翻转的问题，从而破坏 spin lock.&lt;/p&gt;\n&lt;p&gt;实例：如果一个低优先级的线程获得锁并访问共享资源，此时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙时状态从而占用大量CPU，此时低优先级线程无法与高优先级线程抢夺CPU时间，从而导致任务迟迟无法完成，无法释放lock。&lt;/p&gt;\n&lt;p&gt;为解决此问题，在iOS10，给出了新API：&lt;code&gt;os_unfair_lock&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;os_unfair_lock_t unfairLock = &amp;amp;(OS_UNFAIR_LOCK_INIT);\nos_unfair_lock_lock(unfairLock);\nsleep(4);\nos_unfair_lock_unlock(unfairLock);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;信号量\&#34;&gt;信号量&lt;/h2&gt;\n&lt;h3 id=\&#34;dispatch_semaphore\&#34;&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt;&lt;/h3&gt;\n&lt;p&gt;信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt; 可以通过控制并发数实现锁机制。通过控制信号量的值为 0 或 1 来实现锁。&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt; 会使信号量-1，&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt; 会使信号量+1，信号量为0时线程等待，为1时方可继续执行。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;#import &amp;quot;Dispatch_Semaphore.h&amp;quot;\n@interface Dispatch_Semaphore ()\n{\n    dispatch_semaphore_t _semaphore;\n}\n@property (nonatomic, strong) NSMutableArray *array;\n@property (assign) NSUInteger index;\n@end\n@implementation Dispatch_Semaphore\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        /// 通道默认为1, 首次执行\n        _semaphore = dispatch_semaphore_create(1);\n    }\n    return self;\n}\n- (void)run {\n    for (NSUInteger i = 0; i &amp;lt; self.array.count; i++) {\n        if (i % 2 == 0) {\n            dispatch_async(dispatch_get_global_queue(0, 0), ^{\n                [self log];\n            });\n        } else {\n            dispatch_async(dispatch_get_global_queue(0, 0), ^{\n                [self log];\n            });\n        }\n    }\n}\n- (void)log {\n    /// 通道 -1 阻塞其他线程进入\n    dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);\n    NSLog(@&amp;quot;%@&amp;quot;,self.array[self.index++]);\n    /// 通道+1 其他线程可进入\n    dispatch_semaphore_signal(_semaphore);\n}\n- (NSMutableArray *)array {\n    if(!_array){\n        NSMutableArray *arrayM = [NSMutableArray array];\n        for (NSUInteger i = 0; i &amp;lt; 1000; i++) {\n            [arrayM addObject:@(i)];\n        }\n        _array = arrayM;\n    }\n    return _array;\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;互斥锁\&#34;&gt;互斥锁&lt;/h2&gt;\n&lt;h3 id=\&#34;pthread_mutex\&#34;&gt;&lt;code&gt;pthread_mutex&lt;/code&gt;&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;#import &amp;quot;Phread_mutex.h&amp;quot;\n#import &amp;lt;pthread.h&amp;gt;\n@interface Phread_mutex ()\n{\n    pthread_mutex_t _mutex_t;\n}\n@property (nonatomic, strong) NSMutableArray *array;\n@property (assign) NSUInteger index;\n@end\n\n@implementation Phread_mutex\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        /// 锁初始化\n        pthread_mutex_t mutex_t = PTHREAD_MUTEX_INITIALIZER;\n        _mutex_t = mutex_t;\n    }\n    return self;\n}\n- (void)run {\n    for (NSUInteger i = 0; i &amp;lt; self.array.count; i++) {\n        if (i % 2 == 0) {\n            dispatch_async(dispatch_get_global_queue(0, 0), ^{\n                [self log];\n            });\n        } else {\n            dispatch_async(dispatch_get_global_queue(0, 0), ^{\n                [self log];\n            });\n        }\n    }\n}\n- (void)log {\n    // 加互斥锁\n    pthread_mutex_lock(&amp;amp;(_mutex_t));\n    NSLog(@&amp;quot;%@&amp;quot;,self.array[self.index++]);\n    // 解互斥锁\n    pthread_mutex_unlock(&amp;amp;(_mutex_t));\n}\n- (NSMutableArray *)array {\n    if(!_array){\n        NSMutableArray *arrayM = [NSMutableArray array];\n        for (NSUInteger i = 0; i &amp;lt; 1000; i++) {\n            [arrayM addObject:@(i)];\n        }\n        _array = arrayM;\n    }\n    return _array;\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;nslock\&#34;&gt;&lt;code&gt;NSLock&lt;/code&gt;&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;NSLock&lt;/code&gt; 和 &lt;code&gt;NSRecursiveLock&lt;/code&gt;, &lt;code&gt;NSConditionLock&lt;/code&gt; 都是对 &lt;code&gt;pthread_mutex&lt;/code&gt; 的封装。&lt;/p&gt;\n&lt;p&gt;NSLock 遵循 NSLocking 协议. lock 加锁，unlock 解锁，tryLock 尝试加锁，如果失败的话返回 NO，lockBeforeDate: 是在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;NSLocking&lt;/code&gt; 协议&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;@protocol NSLocking\n\n- (void)lock;\n- (void)unlock;\n\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;- (void)log {\n    // 加互斥锁\n    [self.lock lock];\n    NSLog(@&amp;quot;%@&amp;quot;,self.array[self.index++]);\n    // 解互斥锁\n    [self.lock unlock];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;条件锁\&#34;&gt;条件锁&lt;/h2&gt;\n&lt;h3 id=\&#34;nsconditionlock\&#34;&gt;&lt;code&gt;NSConditionLock&lt;/code&gt;&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 同样遵循了&lt;code&gt;NSLocking&lt;/code&gt; 协议，除此之外，还可以设置自定义条件来获得锁和释放锁.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;#import &amp;quot;NSConditionLockDemo.h&amp;quot;\n@interface NSConditionLockDemo ()\n@property (nonatomic, strong) NSMutableArray *images;\n@property (assign) NSUInteger index;\n@property (nonatomic, strong) NSConditionLock *conditionLock;\n@end\n@implementation NSConditionLockDemo\nstatic const NSInteger lockTag = 10086;\nstatic const NSInteger imageCount = 100;\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        self.conditionLock = [[NSConditionLock alloc] init];\n    }\n    return self;\n}\n- (void)run {\n    for (NSUInteger i = 0; i &amp;lt; imageCount; i++) {\n        dispatch_async(dispatch_get_global_queue(0, 0), ^{\n            [self downloadImages];\n        });\n    }\n    [self showImages];\n}\n/// 异步下载 imageCount 张图片\n- (void)downloadImages {\n    sleep(arc4random_uniform(5));\n    [self.conditionLock lock];\n    [self.images addObject:@(arc4random_uniform(100))];\n    [self.conditionLock unlock];\n    if (self.images.count == imageCount) {\n        [self.conditionLock unlockWithCondition:lockTag];\n    }\n}\n/// 展示下载好的 imageCount 张图片\n- (void)showImages {\n    [self.conditionLock lockWhenCondition:lockTag];\n    [self.images enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        NSLog(@&amp;quot;show: %@&amp;quot;,obj);\n    }];\n    [self.conditionLock unlockWithCondition:lockTag];\n}\n- (NSMutableArray *)images {\n    if(!_images){\n        _images = [NSMutableArray array];\n    }\n    return _images;\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;递归锁\&#34;&gt;递归锁&lt;/h2&gt;\n&lt;h3 id=\&#34;nsrecursivelock\&#34;&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;@interface NSRecursiveLockDemo ()\n@property (nonatomic, strong) NSRecursiveLock *recursiveLock;\n@end\n\n@implementation NSRecursiveLockDemo\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        self.recursiveLock = [[NSRecursiveLock alloc] init];\n    }\n    return self;\n}\n- (void)run {\n    NSInteger n = 3;\n    NSLog(@&amp;quot;%ld! = %ld&amp;quot;,(long)n, (long)[self sum:3]);\n}\n- (NSInteger)sum:(NSUInteger)n {\n    [self.recursiveLock lock];\n    NSInteger result = 0;\n    if (n &amp;lt;= 1) {\n        result = n;\n    } else {\n        result = [self sum:n - 1] * n;\n    }\n    [self.recursiveLock unlock];\n    return result;\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果将 &lt;code&gt;NSRecursiveLock&lt;/code&gt; 换成 &lt;code&gt;NSLock&lt;/code&gt; 就会造成死锁。&lt;/p&gt;\n&lt;h3 id=\&#34;synchronized\&#34;&gt;&lt;code&gt;@synchronized&lt;/code&gt;&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-objc\&#34;&gt;- (void)lock1 {\n    @synchronized (self) {\n        // 加锁操作\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;性能最差&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ios-xi-tong-zhong-de-suo&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;多线程同时访问同一块资源会造成资源抢夺，容易引发数据错乱和数据安全问题，此时我们需要保证资源同时只有一个线程访问，加锁就是为了解决这个问题。&lt;/p&gt;\n&lt;p&gt;常用的加锁方式：（性能由差到好）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;OSSpinLock&lt;/code&gt; 自旋锁，存在优先级反转问题，破坏了 spinLock，后来Apple推出 &lt;code&gt;os_unfair_lock_t&lt;/code&gt; 解决优先级翻转问题&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt; 信号量&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;pthread_mutex&lt;/code&gt; 互斥锁 （C语言）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSLock&lt;/code&gt; 对象锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSCondition&lt;/code&gt; 条件锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt; 递归锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 条件锁&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;@synchronized&lt;/code&gt; 性能最差&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;iOS - 系统中的锁&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;iOS 基础&#34;,&#34;slug&#34;:&#34;PmC0N8rc0&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/PmC0N8rc0/&#34;}],&#34;date&#34;:&#34;2020-06-11 13:40:14&#34;,&#34;dateFormat&#34;:&#34;2020-06-11&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2019.12.31.15777952677146.joakim-honkasalo-tvVcBCFVHY8-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/ios-xi-tong-zhong-de-suo/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:362000,&#34;words&#34;:1351,&#34;minutes&#34;:7},&#34;description&#34;:&#34;多线程同时访问同一块资源会造成资源抢夺，容易引发数据错乱和数据安全问题，此时我们需要保证资源同时只有一个线程访问，加锁就是为了解决这个问题。\n常用的加锁方式：（性能由差到好）\n\nOSSpinLock 自旋锁，存在优先级反转问题，破坏了 sp...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E6%97%8B%E9%94%81\&#34;&gt;自旋锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#osspinlock-os_unfair_lock\&#34;&gt;&#39;OSSpinLock&#39;、&#39;os_unfair_lock&#39;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%A1%E5%8F%B7%E9%87%8F\&#34;&gt;信号量&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#dispatch_semaphore\&#34;&gt;&lt;code&gt;dispatch_semaphore&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%92%E6%96%A5%E9%94%81\&#34;&gt;互斥锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#pthread_mutex\&#34;&gt;&lt;code&gt;pthread_mutex&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nslock\&#34;&gt;&lt;code&gt;NSLock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%A1%E4%BB%B6%E9%94%81\&#34;&gt;条件锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#nsconditionlock\&#34;&gt;&lt;code&gt;NSConditionLock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%92%E5%BD%92%E9%94%81\&#34;&gt;递归锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#nsrecursivelock\&#34;&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#synchronized\&#34;&gt;&lt;code&gt;@synchronized&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;java-基础语法二\&#34;&gt;Java - 基础语法二&lt;/h1&gt;\n&lt;h2 id=\&#34;1-常用-api\&#34;&gt;① 常用 API&lt;/h2&gt;\n&lt;h3 id=\&#34;object-类\&#34;&gt;Object 类&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。&lt;/p&gt;\n&lt;p&gt;常用 API：&lt;br&gt;\n&lt;code&gt;public String toString()&lt;/code&gt;: 返回该对象的字符串表示&lt;br&gt;\n&lt;code&gt;public boolean equals(Object obj)&lt;/code&gt; : 与其他对象比较是否与当前对象“相等”&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;objects-类\&#34;&gt;Objects 类&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; 类的 &lt;code&gt;equals&lt;/code&gt; 方法容易抛出空指针异常，在 &lt;code&gt;Objects&lt;/code&gt; 类中提供了 &lt;code&gt;equals&lt;/code&gt; 方法优化这个问题。&lt;br&gt;\n&lt;code&gt;public static boolean equals(Object a, Object b)&lt;/code&gt;:判断两个对象是否相等。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public static boolean equals(Object a, Object b) {  \n    return (a == b) || (a != null &amp;amp;&amp;amp; a.equals(b));  \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;date-类\&#34;&gt;Date 类&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public Date()&lt;/code&gt;：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public Date(long date)&lt;/code&gt;：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public long getTime()&lt;/code&gt; 把日期对象转换成对应的时间毫秒值。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;dateformat-类\&#34;&gt;DateFormat 类&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;java.text.DateFormat&lt;/code&gt; 是日期/时间格式化子类的抽象类，通过这个类完成日期和文本之间的转换。&lt;/p&gt;\n&lt;h4 id=\&#34;格式规则\&#34;&gt;格式规则&lt;/h4&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;标识字母（区分大小写）&lt;/th&gt;\n&lt;th&gt;含义&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;y&lt;/td&gt;\n&lt;td&gt;年&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;M&lt;/td&gt;\n&lt;td&gt;月&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;d&lt;/td&gt;\n&lt;td&gt;日&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;H&lt;/td&gt;\n&lt;td&gt;时&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;m&lt;/td&gt;\n&lt;td&gt;分&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;s&lt;/td&gt;\n&lt;td&gt;秒&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;Demo:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;   /*从出生到现在经历多少天*/\n    private static void daysFormBirthday() throws ParseException {\n        System.out.println(&amp;quot;输入生日：（格式 yyyy-MM-dd）&amp;quot;);\n        Scanner scanner = new Scanner(System.in);\n        String birthday = scanner.next();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&amp;quot;yyyy-MM-dd&amp;quot;);\n        Date birthdayDate = simpleDateFormat.parse(birthday);\n\n        long birthdayDateTime = birthdayDate.getTime();\n        long nowTime = new Date().getTime();\n        long interval = nowTime - birthdayDateTime;\n        long days = interval / 1000 / 60 / 60 / 24;\n        System.out.println(&amp;quot;从出生到现在已过&amp;quot; + days + &amp;quot;天！&amp;quot;);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;calendar-类\&#34;&gt;Calendar 类&lt;/h3&gt;\n&lt;p&gt;日历类。&lt;br&gt;\nCalendar类中提供很多成员常量，代表给定的日历字段：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;字段值&lt;/th&gt;\n&lt;th&gt;含义&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;YEAR&lt;/td&gt;\n&lt;td&gt;年&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;MONTH&lt;/td&gt;\n&lt;td&gt;月（从0开始，可以+1使用）&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;DAY_OF_MONTH&lt;/td&gt;\n&lt;td&gt;月中的天（几号）&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;HOUR&lt;/td&gt;\n&lt;td&gt;时（12小时制）&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;HOUR_OF_DAY&lt;/td&gt;\n&lt;td&gt;时（24小时制）&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;MINUTE&lt;/td&gt;\n&lt;td&gt;分&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;SECOND&lt;/td&gt;\n&lt;td&gt;秒&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;DAY_OF_WEEK&lt;/td&gt;\n&lt;td&gt;周中的天（周几，周日为1，可以-1使用）&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h3 id=\&#34;system-类\&#34;&gt;System 类&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public static long currentTimeMillis()&lt;/code&gt;：返回以毫秒为单位的当前时间。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)&lt;/code&gt;：将数组中指定的数据拷贝到另一个数组中。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;参数序号&lt;/th&gt;\n&lt;th&gt;参数名称&lt;/th&gt;\n&lt;th&gt;参数类型&lt;/th&gt;\n&lt;th&gt;参数含义&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;src&lt;/td&gt;\n&lt;td&gt;Object&lt;/td&gt;\n&lt;td&gt;源数组&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2&lt;/td&gt;\n&lt;td&gt;srcPos&lt;/td&gt;\n&lt;td&gt;int&lt;/td&gt;\n&lt;td&gt;源数组索引起始位置&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;3&lt;/td&gt;\n&lt;td&gt;dest&lt;/td&gt;\n&lt;td&gt;Object&lt;/td&gt;\n&lt;td&gt;目标数组&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;4&lt;/td&gt;\n&lt;td&gt;destPos&lt;/td&gt;\n&lt;td&gt;int&lt;/td&gt;\n&lt;td&gt;目标数组索引起始位置&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;5&lt;/td&gt;\n&lt;td&gt;length&lt;/td&gt;\n&lt;td&gt;int&lt;/td&gt;\n&lt;td&gt;复制元素个数&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h2 id=\&#34;2-collection-集合\&#34;&gt;② Collection 集合&lt;/h2&gt;\n&lt;p&gt;数组的长度是固定的，集合的长度是可变的&lt;br&gt;\n数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致，在开发中一般当对象多的时候，使用集合存储。&lt;/p&gt;\n&lt;h3 id=\&#34;collection-常用功能\&#34;&gt;Collection 常用功能&lt;/h3&gt;\n&lt;p&gt;Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public boolean add(E e)&lt;/code&gt;：  把给定的对象添加到当前集合中 。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public void clear()&lt;/code&gt; :清空集合中所有的元素。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public boolean remove(E e)&lt;/code&gt;: 把给定的对象在当前集合中删除。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public boolean contains(E e)&lt;/code&gt;: 判断当前集合中是否包含给定的对象。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public boolean isEmpty()&lt;/code&gt;: 判断当前集合是否为空。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public int size()&lt;/code&gt;: 返回集合中元素的个数。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public Object[] toArray()&lt;/code&gt;: 把集合中的元素，存储到数组中。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;迭代器-iterator\&#34;&gt;迭代器 （Iterator）&lt;/h3&gt;\n&lt;p&gt;Iterator接口的常用方法如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public E next()&lt;/code&gt;:返回迭代的下一个元素。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public boolean hasNext()&lt;/code&gt;:如果仍有元素可以迭代，则返回 true。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;泛型\&#34;&gt;泛型&lt;/h3&gt;\n&lt;p&gt;当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&amp;lt;?&amp;gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。&lt;/p&gt;\n&lt;p&gt;受限泛型&lt;br&gt;\n&lt;strong&gt;泛型的上限&lt;/strong&gt;：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;格式&lt;/strong&gt;： &lt;code&gt;类型名称 &amp;lt;? extends 类 &amp;gt; 对象名称&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;： &lt;code&gt;只能接收该类型及其子类&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;泛型的下限&lt;/strong&gt;：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;格式&lt;/strong&gt;： &lt;code&gt;类型名称 &amp;lt;? super 类 &amp;gt; 对象名称&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;： &lt;code&gt;只能接收该类型及其父类型&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;list\&#34;&gt;List&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;java.util.ArrayList&lt;/code&gt; 集合数据存储的结构是数组结构，元素增删满，查找快。日常开发常用的功能是查询数据和遍历数据，所以&lt;code&gt;ArrayList&lt;/code&gt;是最常用的集合。&lt;br&gt;\n&lt;code&gt;java.until.LinkedList&lt;/code&gt;集合数据存储的结构是链表结构，方便元素添加和删除的集合，但是查询慢。&lt;/p&gt;\n&lt;h3 id=\&#34;set\&#34;&gt;Set&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;java.until.Set&lt;/code&gt; 接口和 &lt;code&gt;java.util.List&lt;/code&gt; 接口一样，同样继承于 &lt;code&gt;Collection&lt;/code&gt; 接口，它与 &lt;code&gt;Collection&lt;/code&gt; 接口中的方法基本一致。&lt;code&gt;Set&lt;/code&gt;接口中的元素无序，并且都会以某种规则保证存入的元素不会出现重复。&lt;br&gt;\n&lt;code&gt;HashSet&lt;/code&gt; 能保证存储的元素唯一，但是无序。想要即唯一，又有顺序就需要用 &lt;code&gt;java.util.LinkedHashSet&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;collections\&#34;&gt;Collections&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;java.utils.Collections&lt;/code&gt;是集合工具类，用来对集合进行操作。部分方法:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; boolean addAll(Collection&amp;lt;T&amp;gt; c, T... elements)  &lt;/code&gt;:往集合中添加一些元素。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public static void shuffle(List&amp;lt;?&amp;gt; list) 打乱顺序&lt;/code&gt;:打乱集合顺序。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list)&lt;/code&gt;:将集合中元素按照默认规则排序。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list，Comparator&amp;lt;? super T&amp;gt; )&lt;/code&gt;:将集合中元素按照指定规则排序。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;Comparator&lt;/code&gt; 接口代表一个比较器，其中：&lt;br&gt;\n&lt;code&gt;public int compare(String o1, String o2);&lt;/code&gt; 比较其两个参数的顺序。&lt;br&gt;\n若按照升序排序，则 o1 &amp;lt; o2 (负数)&lt;br&gt;\n若按照降序排序，则 o1 &amp;gt; o1 (正数)&lt;/p&gt;\n&lt;p&gt;Demo：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;private static void sortDemo() {\n    ArrayList&amp;lt;Student&amp;gt; arrayList = new ArrayList&amp;lt;Student&amp;gt;();\n    arrayList.add(new Student(&amp;quot;邱学伟&amp;quot;,18));\n    arrayList.add(new Student(&amp;quot;梁朝伟&amp;quot;,30));\n    arrayList.add(new Student(&amp;quot;周星驰&amp;quot;,24));\n    arrayList.add(new Student(&amp;quot;刘德华&amp;quot;,28));\n    arrayList.add(new Student(&amp;quot;a&amp;quot;,22));\n    arrayList.add(new Student(&amp;quot;b&amp;quot;,22));\n    // 按类内定义排序\n//        Collections.sort(arrayList); \n\n    // 年龄降序\n//        arrayList.sort(new Comparator&amp;lt;Student&amp;gt;() {\n//            @Override\n//            public int compare(Student o1, Student o2) {\n//                return o2.getAge() - o1.getAge();//年龄降序\n//            }\n//        });\n\n    // 年龄升序，相同年龄 按首字母\n    arrayList.sort(new Comparator&amp;lt;Student&amp;gt;() {\n        @Override\n        public int compare(Student o1, Student o2) {\n            int result = o1.getAge() - o2.getAge();\n            if (result == 0) {\n                result = o1.getName().charAt(0) - o2.getName().charAt(0);\n            }\n            return result;\n        }\n    });\n\n    for (Student student : arrayList) {\n        System.out.println(student);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;map\&#34;&gt;Map&lt;/h3&gt;\n&lt;p&gt;Map 中的集合，元素是成对存在的，每个元素由键和值两部分组成，通过键可以找到所对应的值；&lt;br&gt;\nCollection 中的集合称为单列集合，Map 中的集合称为双列集合；&lt;br&gt;\nMap 中的集合不能包含重复的键，值可以重复。每个键对应一个值。&lt;br&gt;\nMap接口中定义了很多方法，常用的如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public V put(K key, V value)&lt;/code&gt;:  把指定的键与指定的值添加到Map集合中。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public V remove(Object key)&lt;/code&gt;: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public V get(Object key)&lt;/code&gt; 根据指定的键，在Map集合中获取对应的值。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;boolean containsKey(Object key)  &lt;/code&gt; 判断集合中是否包含指定的键。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public Set&amp;lt;K&amp;gt; keySet()&lt;/code&gt;: 获取Map集合中所有的键，存储到Set集合中。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()&lt;/code&gt;: 获取到Map集合中所有的键值对对象的集合(Set集合)。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;entry-键值对对象\&#34;&gt;Entry 键值对对象&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;Entry&lt;/code&gt; 将键值对的对应关系封装成了对象，即键值对对象，这样我们在遍历 Map 集合时，就可以从每一个键值对（&lt;code&gt;Entry&lt;/code&gt;）对象中获取对应的键与其对应的值。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public K getKey()&lt;/code&gt;：获取Entry对象中的键。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;public V getValue()&lt;/code&gt;：获取Entry对象中的值。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在Map集合中也提供了获取所有Entry对象的方法：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;public Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()&lt;/code&gt;: 获取到Map集合中所有的键值对对象的集合(Set集合)。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;当给 HashMap 中存放自定义对象时，如果自定义对象作为 Key 存在，这时要保证对象的唯一，则必须重写对象的 &lt;code&gt;hashCode&lt;/code&gt; 和 &lt;code&gt;equals&lt;/code&gt; 方法。&lt;br&gt;\n如果要保证 map 中存在的 key 和取出的顺序一致，可以使用 &lt;code&gt;java.util.LinkedHashMap&lt;/code&gt;集合存放。&lt;/p&gt;\n&lt;h2 id=\&#34;3-线程\&#34;&gt;③ 线程&lt;/h2&gt;\n&lt;p&gt;并发：指两个或多个事件在同一时间段内发生。&lt;br&gt;\n并行：指两个或多个事件在同一时刻发生（同时发生）。&lt;/p&gt;\n&lt;p&gt;进程：一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。&lt;br&gt;\n线程：线程是进程中的一个执行单元，负责当前进程中的程序的执行，一个进程中至少有一个线程。一个进程是可以有多个线程的，这个应用程序也可称之为多线程程序。&lt;/p&gt;\n&lt;p&gt;简而言之：一个程序运行后至少有一个进程，一个进程可以包含多个线程。&lt;/p&gt;\n&lt;p&gt;线程的调度方式：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。&lt;/li&gt;\n&lt;li&gt;抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java 使用的是抢占式调度。\n&lt;ol&gt;\n&lt;li&gt;CPU 使用抢占式调度模式在多个线程间进行着高速的切换，对于 CPU 的一个核而言，某个时刻，只能执行一个线程，而 CPU 在多个线程间切换速度相对我们感觉要快，看上去就像在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序的运行效率，让 CPU 的使用率更高。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;线程同步的三种方式\&#34;&gt;线程同步的三种方式&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;同步代码块&lt;/li&gt;\n&lt;li&gt;同步方法&lt;/li&gt;\n&lt;li&gt;锁机制&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;同步代码块：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;synchronized(同步锁) \n{\n    /// 需要同步执行的代码\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中同步锁：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;锁对象，可以是任意类型&lt;/li&gt;\n&lt;li&gt;多个线程对象，要使用同一把锁&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;线程之间的通信\&#34;&gt;线程之间的通信&lt;/h3&gt;\n&lt;p&gt;wait/notify 就是线程间的一种协作机制。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;调用wait和notify方法需要注意的细节&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。&lt;/li&gt;\n&lt;li&gt;wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。&lt;/li&gt;\n&lt;li&gt;wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;线程池\&#34;&gt;线程池&lt;/h3&gt;\n&lt;p&gt;一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源。&lt;/p&gt;\n&lt;h2 id=\&#34;4-lambda\&#34;&gt;④ Lambda&lt;/h2&gt;\n&lt;p&gt;面向对象的思想：&lt;br&gt;\n做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情；&lt;br&gt;\n函数式编程思想：&lt;br&gt;\n只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果不重视过程。&lt;/p&gt;\n&lt;h3 id=\&#34;lambda-的标准格式\&#34;&gt;Lambda 的标准格式：&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;一些参数&lt;/li&gt;\n&lt;li&gt;一个箭头&lt;/li&gt;\n&lt;li&gt;一段代码&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;(参数类型 参数名称) -&amp;gt; { 代码语句 }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。&lt;br&gt;\n-&amp;gt; 是新引入的语法，代表指向动作&lt;br&gt;\n大括号内的语法与传统方法体要求基本一致&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;// Lambda , 年龄升序，相同年龄，首字母降序\narrayList.sort((Student s1, Student s2)-&amp;gt;{\n    int result = s1.getAge() - s2.getAge();\n    if (result == 0) {\n        result = s2.getName().charAt(0) - s1.getName().charAt(0);\n    }\n    return result;\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;省略规则：&lt;br&gt;\n小括号内参数的类型可以省略；&lt;br&gt;\n如果小括号内有且仅有一个参数，则小括号可以省略&lt;br&gt;\n如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return 关键字及语句分号。&lt;/p&gt;\n&lt;p&gt;使用 Lambda 注意：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;使用 Lambda 必须有接口，且要求接口中有且仅有一个抽象方法&lt;/li&gt;\n&lt;li&gt;使用 Lambda 必须具有上下文推断。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Java 中的 Lambda 可以被当做是匿名内部类的替代品。&lt;br&gt;\n如果函数的参数是一个函数式接口类型，就可以使用 Lambda 表达式进行替代，使用 Lambda 表达式作为方法参数，其实就是使用函数式接口作为方法参数。&lt;br&gt;\n类似的，如果一个方法的返回值是一个函数式接口，那么也可以直接返回一个 Lambda 表达式。&lt;/p&gt;\n&lt;h3 id=\&#34;常用函数式接口\&#34;&gt;常用函数式接口&lt;/h3&gt;\n&lt;h4 id=\&#34;1-supplier-接口\&#34;&gt;1. Supplier 接口&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;java.util.function.Supplier&amp;lt;T&amp;gt;&lt;/code&gt; 接口仅包含一个无参方法 &lt;code&gt;T get()&lt;/code&gt;。用以获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的 Lambda 表达式需要“对外提供”一个符合泛型类型的对象数据。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private static void demo2() {\n    String s1 = &amp;quot;极客学伟&amp;quot;;\n    String s2 = &amp;quot;科技有限公司&amp;quot;;\n    String s3 = getString(()-&amp;gt; s1 + s2 );\n    System.out.print(s3);\n}\nprivate static String getString(Supplier&amp;lt;String&amp;gt; function) {\n    return function.get();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;2-consumer-接口\&#34;&gt;2. Consumer 接口&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;java.util.function.Consumer&amp;lt;T&amp;gt;&lt;/code&gt; 接口与 Supplier 相反，它不是产生一个数据，而是消费一个数据，其数据类型由泛型决定。&lt;/p&gt;\n&lt;h5 id=\&#34;抽象方法-accept\&#34;&gt;抽象方法 accept&lt;/h5&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private static void demo3() {\n    consumerString((num)-&amp;gt; System.out.println(&amp;quot;打印：&amp;quot; + num));\n}\nprivate static void consumerString(Consumer&amp;lt;Integer&amp;gt; function) {\n    function.accept(1024);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;默认方法-andthen\&#34;&gt;默认方法 andThen&lt;/h5&gt;\n&lt;p&gt;消费数据时，首先做一个操作，然后再做一个操作，实现组合。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private static void demo4() {\n    consumerAndThenString(s -&amp;gt; System.out.println(s.toLowerCase()) ,s -&amp;gt; System.out.println(s.toUpperCase()));\n}\nprivate static void consumerAndThenString(Consumer&amp;lt;String&amp;gt; f1, Consumer&amp;lt;String&amp;gt; f2) {\n    f1.andThen(f2).accept(&amp;quot;Hello World!&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;private static void demo5() {\n    ArrayList&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;Student&amp;gt;(Arrays.asList(new Student(&amp;quot;极客&amp;quot;,18) , new Student(&amp;quot;学伟&amp;quot;,28)));\n    userInfoLog(students,student -&amp;gt; System.out.print(&amp;quot;姓名：&amp;quot; + student.getName()) , student -&amp;gt; System.out.print(&amp;quot; 年龄：&amp;quot; + student.getAge() + &amp;quot;;\\n&amp;quot;));\n}\nprivate static void userInfoLog(ArrayList&amp;lt;Student&amp;gt; s, Consumer&amp;lt;Student&amp;gt; s1, Consumer&amp;lt;Student&amp;gt; s2) {\n    for (Student student : s) {\n        s1.andThen(s2).accept(student);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;3-predicate-接口\&#34;&gt;3. Predicate 接口&lt;/h4&gt;\n&lt;p&gt;对某种类型的数据进行判断，从而得到一个 boolean 值的结果，可以使用 &lt;code&gt;java.util.function.Predicate&amp;lt;T&amp;gt;&lt;/code&gt; 接口。&lt;/p&gt;\n&lt;h5 id=\&#34;抽象方法test\&#34;&gt;抽象方法：test&lt;/h5&gt;\n&lt;p&gt;用于条件判断的场景：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;private static void demo6() {\n    Student s = new Student(&amp;quot;极客学伟&amp;quot;,27);\n    adjustMethod(student -&amp;gt; student.getName().equals(&amp;quot;极客学伟&amp;quot;) , s);\n}\nprivate static void adjustMethod(Predicate&amp;lt;Student&amp;gt; predicate, Student s) {\n    boolean isMe = predicate.test(s);\n    System.out.println(&amp;quot;名字叫&amp;quot; + s.getName() + &amp;quot;的&amp;quot; + (isMe ? &amp;quot;很帅&amp;quot; : &amp;quot;一点点丑&amp;quot;));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h5 id=\&#34;默认方法and\&#34;&gt;默认方法：and&lt;/h5&gt;\n&lt;p&gt;逻辑判断中将两个 &lt;code&gt;Predicate&lt;/code&gt; 条件使用“与”逻辑连接起来实现 “并且”的效果&lt;/p&gt;\n&lt;h5 id=\&#34;默认方法or\&#34;&gt;默认方法：or&lt;/h5&gt;\n&lt;p&gt;逻辑判断中将两个 &lt;code&gt;Predicate&lt;/code&gt; 条件使用“或”逻辑连接起来实现 “或者”的效果&lt;/p&gt;\n&lt;h5 id=\&#34;默认方法negate\&#34;&gt;默认方法：negate&lt;/h5&gt;\n&lt;p&gt;逻辑判断中将两个 &lt;code&gt;Predicate&lt;/code&gt; 条件使用“非”逻辑连接起来实现 “取反”的效果&lt;/p&gt;\n&lt;p&gt;Demo：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;private static void demo7() {\n    String[] girls = {&amp;quot;邓紫棋，26&amp;quot;, &amp;quot;韩红，46&amp;quot;, &amp;quot;韩雪，36&amp;quot;, &amp;quot;杨紫，29&amp;quot;, &amp;quot;慧慧，28&amp;quot;, &amp;quot;古力娜扎，32&amp;quot;, &amp;quot;AngelaBaby，28&amp;quot;};\n    /// 筛选 二十来岁名字是两个字的女神\n    ArrayList&amp;lt;String&amp;gt; result = predicateDemo(girls, g -&amp;gt; Integer.parseInt(g.split(&amp;quot;，&amp;quot;)[1]) &amp;lt; 30, g -&amp;gt; g.split(&amp;quot;，&amp;quot;)[0].length() &amp;lt; 3);\n    result.forEach(System.out::println);\n}\n// 筛选满足两个条件的数组\nprivate static ArrayList&amp;lt;String&amp;gt; predicateDemo(String[] girls, Predicate&amp;lt;String&amp;gt; p1, Predicate&amp;lt;String&amp;gt; p2) {\n    ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(girls.length);\n    for (String girl : girls) {\n        if (p1.and(p2).test(girl)) {\n            list.add(girl);\n        }\n    }\n    return list;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;4-function-接口\&#34;&gt;4. Function 接口&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;java.util.function.Function&amp;lt;T,R&amp;gt;&lt;/code&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者成为前置条件，后者称为后置条件。&lt;/p&gt;\n&lt;h5 id=\&#34;抽象方法apply\&#34;&gt;抽象方法：apply&lt;/h5&gt;\n&lt;p&gt;&lt;code&gt;R apply(T t)&lt;/code&gt; 根据类型 T 的参数获取类型 R 的结果。&lt;/p&gt;\n&lt;h2 id=\&#34;5-stream\&#34;&gt;⑤ Stream&lt;/h2&gt;\n&lt;p&gt;Java 中的流思想类似于工厂车间的“生产流水线”。&lt;br&gt;\nStream（流）是一个来自数据源的元素队列&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;元素是特定类型的对象，形成一个队列。Java 中的 Stream 并不会存储元素，而是按需计算。&lt;/li&gt;\n&lt;li&gt;数据源 流的来源，可以是集合数组等。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;基础特性：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Pipelining：中间操作都会返回流对象本身，这样多个操作可以串联成一个管道，如同流式风格。&lt;/li&gt;\n&lt;li&gt;内部迭代：以前对集合遍历都是通过 &lt;code&gt;Iterator&lt;/code&gt; 或者增强 &lt;code&gt;for&lt;/code&gt; 的方式，显式的在集合外部进行迭代，这叫外部迭代。Stream 提供内部迭代的方式，流可以直接调用遍历方法。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;使用步骤：&lt;br&gt;\n获取一个数据源 -&amp;gt; 数据转换 -&amp;gt; 执行操作获取想要的结果。每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。&lt;/p&gt;\n&lt;p&gt;demo：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;\n/// 筛选 二十来岁名字是两个字的女神\nprivate static void streamDemo1() {\n    String[] girls = {&amp;quot;邓紫棋，26&amp;quot;, &amp;quot;韩红，46&amp;quot;, &amp;quot;韩雪，36&amp;quot;, &amp;quot;杨紫，29&amp;quot;, &amp;quot;慧慧，28&amp;quot;, &amp;quot;古力娜扎，32&amp;quot;, &amp;quot;AngelaBaby，28&amp;quot;};\n    Arrays.stream(girls).filter(s -&amp;gt; parseInt(s.split(&amp;quot;，&amp;quot;)[1]) &amp;lt; 30).filter(s -&amp;gt; s.split(&amp;quot;，&amp;quot;)[0].length() &amp;lt; 3).forEach(s -&amp;gt; System.out.println(s));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;获取-stream\&#34;&gt;获取 Stream&lt;/h3&gt;\n&lt;h4 id=\&#34;collection\&#34;&gt;Collection&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;java.util.Collection&lt;/code&gt; 接口中加入了 default 方法 &lt;code&gt;stream&lt;/code&gt; 用来获取流，所以其所有实现类均可直接获取流。&lt;/p&gt;\n&lt;h4 id=\&#34;map-2\&#34;&gt;Map&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;java.util.Map&lt;/code&gt; 接口不是 &lt;code&gt;Collection&lt;/code&gt; 的子接口，且其 K-V 数据结构不符合流元素的单一特征，所以获取对应的流需要 Key、Value 或 entry 等情况。&lt;/p&gt;\n&lt;h4 id=\&#34;数组\&#34;&gt;数组&lt;/h4&gt;\n&lt;p&gt;数组对象不可能添加默认方法，&lt;code&gt;Stream&lt;/code&gt; 接口中提供了静态方法 &lt;code&gt;of&lt;/code&gt;，用于生成数组的 &lt;code&gt;stream&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private static void arrayStreamDemo() {\n    String[] array = {&amp;quot;张三&amp;quot;, &amp;quot;李四&amp;quot;, &amp;quot;王五&amp;quot;, &amp;quot;赵六&amp;quot;};\n    Stream&amp;lt;String&amp;gt; arrayStream = Stream.of(array);\n    arrayStream.forEach(System.out::println);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;stream-常用方法\&#34;&gt;Stream 常用方法&lt;/h3&gt;\n&lt;h4 id=\&#34;逐一处理foreach\&#34;&gt;逐一处理：forEach&lt;/h4&gt;\n&lt;p&gt;接收一个 &lt;code&gt;Consumer&lt;/code&gt; 接口函数，会将每一个流元素交给该函数处理。&lt;/p&gt;\n&lt;h4 id=\&#34;过滤filter\&#34;&gt;过滤：filter&lt;/h4&gt;\n&lt;p&gt;将一个流转换成另一个子集流&lt;/p&gt;\n&lt;h4 id=\&#34;映射map\&#34;&gt;映射：map&lt;/h4&gt;\n&lt;p&gt;将流中的元素映射到另一个流中&lt;/p&gt;\n&lt;h4 id=\&#34;统计个数count\&#34;&gt;统计个数：count&lt;/h4&gt;\n&lt;p&gt;获取流中的元素个数&lt;/p&gt;\n&lt;h4 id=\&#34;提取前几个limit\&#34;&gt;提取前几个：limit&lt;/h4&gt;\n&lt;p&gt;对流进行截取，只取前 n 个&lt;/p&gt;\n&lt;h4 id=\&#34;跳过前几个skip\&#34;&gt;跳过前几个：skip&lt;/h4&gt;\n&lt;p&gt;跳过流中的前 n 个元素&lt;/p&gt;\n&lt;h4 id=\&#34;组合concat\&#34;&gt;组合：concat&lt;/h4&gt;\n&lt;p&gt;将两个流合并成为一个流&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java-ji-chu-yu-fa-er&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;java-基础语法二\&#34;&gt;Java - 基础语法二&lt;/h1&gt;\n&lt;h2 id=\&#34;1-常用-api\&#34;&gt;① 常用 API&lt;/h2&gt;\n&lt;h3 id=\&#34;object-类\&#34;&gt;Object 类&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。&lt;/p&gt;\n&lt;p&gt;常用 API：&lt;br&gt;\n&lt;code&gt;public String toString()&lt;/code&gt;: 返回该对象的字符串表示&lt;br&gt;\n&lt;code&gt;public boolean equals(Object obj)&lt;/code&gt; : 与其他对象比较是否与当前对象“相等”&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Java - 基础语法二&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;9H4f1SDbS&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/9H4f1SDbS/&#34;}],&#34;date&#34;:&#34;2020-03-31 21:58:49&#34;,&#34;dateFormat&#34;:&#34;2020-03-31&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2020.03.28.15854051821300.maximilian-weisbecker-1td5Iq5IvNc-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/java-ji-chu-yu-fa-er/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;20 min read&#34;,&#34;time&#34;:1141000,&#34;words&#34;:4721,&#34;minutes&#34;:20},&#34;description&#34;:&#34;Java - 基础语法二\n① 常用 API\nObject 类\njava.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。\n常用 API：\np...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C\&#34;&gt;Java - 基础语法二&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%B8%B8%E7%94%A8-api\&#34;&gt;① 常用 API&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#object-%E7%B1%BB\&#34;&gt;Object 类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#objects-%E7%B1%BB\&#34;&gt;Objects 类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#date-%E7%B1%BB\&#34;&gt;Date 类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dateformat-%E7%B1%BB\&#34;&gt;DateFormat 类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99\&#34;&gt;格式规则&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#calendar-%E7%B1%BB\&#34;&gt;Calendar 类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#system-%E7%B1%BB\&#34;&gt;System 类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-collection-%E9%9B%86%E5%90%88\&#34;&gt;② Collection 集合&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#collection-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD\&#34;&gt;Collection 常用功能&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator\&#34;&gt;迭代器 （Iterator）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%9B%E5%9E%8B\&#34;&gt;泛型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#list\&#34;&gt;List&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#set\&#34;&gt;Set&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#collections\&#34;&gt;Collections&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#map\&#34;&gt;Map&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#entry-%E9%94%AE%E5%80%BC%E5%AF%B9%E5%AF%B9%E8%B1%A1\&#34;&gt;Entry 键值对对象&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E7%BA%BF%E7%A8%8B\&#34;&gt;③ 线程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\&#34;&gt;线程同步的三种方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1\&#34;&gt;线程之间的通信&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0\&#34;&gt;线程池&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-lambda\&#34;&gt;④ Lambda&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#lambda-%E7%9A%84%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F\&#34;&gt;Lambda 的标准格式：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\&#34;&gt;常用函数式接口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-supplier-%E6%8E%A5%E5%8F%A3\&#34;&gt;1. Supplier 接口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-consumer-%E6%8E%A5%E5%8F%A3\&#34;&gt;2. Consumer 接口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-accept\&#34;&gt;抽象方法 accept&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95-andthen\&#34;&gt;默认方法 andThen&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-predicate-%E6%8E%A5%E5%8F%A3\&#34;&gt;3. Predicate 接口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95test\&#34;&gt;抽象方法：test&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95and\&#34;&gt;默认方法：and&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95or\&#34;&gt;默认方法：or&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95negate\&#34;&gt;默认方法：negate&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-function-%E6%8E%A5%E5%8F%A3\&#34;&gt;4. Function 接口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95apply\&#34;&gt;抽象方法：apply&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-stream\&#34;&gt;⑤ Stream&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96-stream\&#34;&gt;获取 Stream&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#collection\&#34;&gt;Collection&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#map-2\&#34;&gt;Map&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84\&#34;&gt;数组&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#stream-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\&#34;&gt;Stream 常用方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%90%E4%B8%80%E5%A4%84%E7%90%86foreach\&#34;&gt;逐一处理：forEach&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%87%E6%BB%A4filter\&#34;&gt;过滤：filter&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%98%A0%E5%B0%84map\&#34;&gt;映射：map&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%9F%E8%AE%A1%E4%B8%AA%E6%95%B0count\&#34;&gt;统计个数：count&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%90%E5%8F%96%E5%89%8D%E5%87%A0%E4%B8%AAlimit\&#34;&gt;提取前几个：limit&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%B3%E8%BF%87%E5%89%8D%E5%87%A0%E4%B8%AAskip\&#34;&gt;跳过前几个：skip&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%84%E5%90%88concat\&#34;&gt;组合：concat&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;java-基础语法一\&#34;&gt;Java - 基础语法一&lt;/h1&gt;\n&lt;h2 id=\&#34;1-基础语法\&#34;&gt;① 基础语法&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;JVM（Java Virtual Machine）: Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 程序，都运行在 JVM 之上。&lt;/li&gt;\n&lt;li&gt;JRE（Java Runtime Environment）：Java 程序的运行环境，包含 JVM 和运行时所需要的核心类库。&lt;/li&gt;\n&lt;li&gt;JDK（Java Development Environment）：Java 程序开发工具包，包含 JRE 和开发人员使用的工具。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.03.28.15854041867234.15827280446149.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;方法\&#34;&gt;方法&lt;/h3&gt;\n&lt;p&gt;格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;修饰符 返回值类型 方法名（参数列表）\n{\n    // 代码\n    return 结果;// 如果返回值类型不为 void\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;方法重载多个方法的名称一样但是参数列表不一样\&#34;&gt;方法重载：多个方法的名称一样，但是参数列表不一样&lt;/h3&gt;\n&lt;h4 id=\&#34;方法重载与以下因素有关\&#34;&gt;方法重载与以下因素有关：&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;参数个数不同&lt;/li&gt;\n&lt;li&gt;参数类型不同&lt;/li&gt;\n&lt;li&gt;参数的多类型顺序不同&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;方法重载与以下因素无关\&#34;&gt;方法重载与以下因素无关：&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;与参数的名称无关&lt;/li&gt;\n&lt;li&gt;与方法的返回值类型无关&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;数组一种容器可以同时存放多个数据源\&#34;&gt;数组：一种容器，可以同时存放多个数据源&lt;/h3&gt;\n&lt;h4 id=\&#34;数组特点\&#34;&gt;数组特点：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;数组是一种引用数据类型&lt;/li&gt;\n&lt;li&gt;数组当中的多个数据，类型必须统一&lt;/li&gt;\n&lt;li&gt;数组的长度在程序运行期间不可改变&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;动态初始化在创建数组的时候直接指定数组当中的数据元素个数\&#34;&gt;动态初始化：在创建数组的时候，直接指定数组当中的数据元素个数&lt;/h4&gt;\n&lt;p&gt;格式：&lt;code&gt;数据类型[] 数组名称 = new 数据类型[数组长度]&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;静态初始化在创建数组的时候不直接指定数据个数多少而是直接将具体的数据内容进行指定\&#34;&gt;静态初始化：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定&lt;/h4&gt;\n&lt;p&gt;标准格式：&lt;code&gt;数据类型[] 数组名称 = new 数据类型[] {元素 1、元素 2、...}&lt;/code&gt;&lt;br&gt;\n省略格式：&lt;code&gt;数据类型[] 数组名称 = {元素 1、元素 2、...}&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;注意事项\&#34;&gt;注意事项&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;静态初始化没有直接指定长度，但是仍然会自动推算得到长度 &lt;code&gt;int[] arrayA = {10, 20, 30};&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;静态初始化标准格式可以拆分成两个步骤  &lt;code&gt;int[] arrayB; arrayB = new int[5];&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;动态初始化也可以拆分成两个步骤 &lt;code&gt;int arrayC; arrayC = new int [] {1, 2, 3 };&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;静态初始化一旦使用省略格式，就不能拆分成为两个步骤了&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;java-的内存需要划分成为-5-个部分\&#34;&gt;Java 的内存需要划分成为 5 个部分：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;栈（Srack）：存放的都是方法中的局部变量，&lt;strong&gt;方法的运行一定在栈中&lt;/strong&gt;\n&lt;ol&gt;\n&lt;li&gt;局部变量：方法的参数，或者是方法{} 内部的变量。&lt;/li&gt;\n&lt;li&gt;作用域：一旦超出作用域，立刻从栈内存当中消失。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;堆（Heap）：凡是 new 出来的东西，都在堆当中&lt;/strong&gt;\n&lt;ol&gt;\n&lt;li&gt;堆内存里面的东西都有一个地址值：16 进制&lt;/li&gt;\n&lt;li&gt;堆内存里面的数据，都有默认值&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;方法区（Method Area）：存储 .class 相关信息，包含方法的信息。&lt;/li&gt;\n&lt;li&gt;本地方法栈（Native Method Stack）：与操作系统相关&lt;/li&gt;\n&lt;li&gt;寄存器（pc Register）：与 CPU 相关&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;2-面向对象\&#34;&gt;② 面向对象&lt;/h2&gt;\n&lt;h3 id=\&#34;局部变量和成员变量\&#34;&gt;局部变量和成员变量&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;定义的位置不同\n&lt;ul&gt;\n&lt;li&gt;局部变量：在方法内部&lt;/li&gt;\n&lt;li&gt;成员变量：在方法外部，直接写在类中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;作用范围不同\n&lt;ul&gt;\n&lt;li&gt;局部变量：只有在方法中才可以使用，出了方法就不能用&lt;/li&gt;\n&lt;li&gt;成员变量：整个类全都可以通用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;默认值不同\n&lt;ul&gt;\n&lt;li&gt;局部变量：没有默认值，如果想使用，必须手动进行赋值&lt;/li&gt;\n&lt;li&gt;成员变量：如果没有赋值，会有默认值，规则和数组一样&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;内存位置不一样\n&lt;ul&gt;\n&lt;li&gt;局部变量：位于栈内存&lt;/li&gt;\n&lt;li&gt;成员变量：位于堆内存&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;生命周期不一样\n&lt;ul&gt;\n&lt;li&gt;局部变量：随方法进栈而诞生，随着方法出栈而消失&lt;/li&gt;\n&lt;li&gt;成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;面向对象三大特性封装-继承-多态\&#34;&gt;面向对象三大特性：封装、继承、多态&lt;/h3&gt;\n&lt;p&gt;封装性在 Java 体现：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;方法就是封装&lt;/li&gt;\n&lt;li&gt;Private 关键字也是封装&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;对于基本数据类型当中的 boolean 值，Getter 方法一定要写成 isXxx 的形式，而 setXxx 规则不变&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;构造方法\&#34;&gt;构造方法&lt;/h3&gt;\n&lt;p&gt;构造方法是专门用来创建对象的方法，当我们通过关键字 new 来创建对象时，其实就是在调用构造方法&lt;/p&gt;\n&lt;h4 id=\&#34;格式\&#34;&gt;格式：&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;public 类名称(参数类型 参数名称) \n{\n    方法体\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;构造方法使用注意事项\&#34;&gt;构造方法使用注意事项：&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样&lt;/li&gt;\n&lt;li&gt;构造方法不要写返回值类型，连 Void 都不写&lt;/li&gt;\n&lt;li&gt;构造方法不能 return 一个具体返回值&lt;/li&gt;\n&lt;li&gt;如果没有编写任何构造方法，编译器会默认生成一个构造方法，无参数、无方法体&lt;/li&gt;\n&lt;li&gt;一旦编写了至少一个构造方法，编译器便不再自动生成&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;标准的类\&#34;&gt;标准的类&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;所有的成员变量都要用 private 关键字修饰&lt;/li&gt;\n&lt;li&gt;为每一个成员变量编写一对儿 Getter/Setter 方法&lt;/li&gt;\n&lt;li&gt;编写一个无参数的构造方法&lt;/li&gt;\n&lt;li&gt;编写一个全参数的构造方法&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;3-常用-api\&#34;&gt;③ 常用 API&lt;/h2&gt;\n&lt;h3 id=\&#34;random\&#34;&gt;Random&lt;/h3&gt;\n&lt;p&gt;用于生成随机数&lt;br&gt;\n&lt;code&gt;public int nextInt(int n)&lt;/code&gt; 返回一个 [0,n) 之间的随机数。&lt;/p&gt;\n&lt;h3 id=\&#34;arraylist\&#34;&gt;ArrayList&lt;/h3&gt;\n&lt;p&gt;数组的长度不可以发生变化，ArrayList 集合的长度是可以随意变化的。&lt;br&gt;\n如果希望向 ArrayList 当中存储基本类型数据，必须使用基本类型对应的“包装类”&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;基本类型&lt;/th&gt;\n&lt;th&gt;包装类（引用类型）&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;byte&lt;/td&gt;\n&lt;td&gt;Byte&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;short&lt;/td&gt;\n&lt;td&gt;Short&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;int&lt;/td&gt;\n&lt;td&gt;Integer&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;long&lt;/td&gt;\n&lt;td&gt;Long&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;float&lt;/td&gt;\n&lt;td&gt;Float&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;double&lt;/td&gt;\n&lt;td&gt;Double&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;char&lt;/td&gt;\n&lt;td&gt;Character&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;boolean&lt;/td&gt;\n&lt;td&gt;Boolean&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h3 id=\&#34;string\&#34;&gt;String&lt;/h3&gt;\n&lt;p&gt;程序中所有双引号字符串，都是 String 类的对象&lt;/p&gt;\n&lt;h4 id=\&#34;特点\&#34;&gt;特点&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;字符串的内容永不改变&lt;/li&gt;\n&lt;li&gt;正是因为字符串不可改变，所以字符串是可以共享使用的&lt;/li&gt;\n&lt;li&gt;字符串效果上相当于是 char[] 字符数组，底层原理是 byte[] 字节数组&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;字符串常量池，在堆中开辟的一块空间。 使用 &amp;quot;&amp;quot; 直接创建的字符串都存放在字符串常量池中。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;对于引用类型来说，“==” 进行的是地址值的比较，基本数据类型是对值的比较；&lt;/li&gt;\n&lt;li&gt;双引号直接创建的字符串在常量池中，new 的不在池中。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;如果需要对字符串的内容进行比较，可以使用如下方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public boolean equals(Object obj); // 严格区分大小写\npublic boolean equalsIgnoreCase(Object obj); // 忽略大小写\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;split&lt;/code&gt; 方法的参数其实是一个正则表达式，如果要按照英文 . 进行切分，必须写 &amp;quot;\\\\.&amp;quot; (两个反斜杠)&lt;/p&gt;\n&lt;h3 id=\&#34;static-关键字\&#34;&gt;Static 关键字&lt;/h3&gt;\n&lt;p&gt;用来修饰成员变量和成员方法，被修饰的成员属于类的，而不是单单是属于某个对象的。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;当 &lt;code&gt;static&lt;/code&gt; 修饰成员变量，该变量称为类变量，该类的每个对象都共享同一个类变量的值。&lt;br&gt;\n格式：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;static 数据类型 变量名;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;当 &lt;code&gt;static&lt;/code&gt; 修饰成员方法时，该方法称为类方法。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;静态代码块：定义在成员位置，使用 &lt;code&gt;static&lt;/code&gt; 修饰的代码块 {}&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;位置：类中方法之外&lt;/li&gt;\n&lt;li&gt;执行：随着类的加载而执行且只执行一次，优先于 main 方法和构造方法的执行。&lt;/li&gt;\n&lt;li&gt;作用：类类变量进行初始化赋值。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public class className \n{\n    static {\n        /// 执行语句    \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;arrays\&#34;&gt;Arrays&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;java.util.Arrays&lt;/code&gt; 是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组常见操作。&lt;br&gt;\n&lt;code&gt;toString(数组)&lt;/code&gt; 将参数数组变成字符串&lt;br&gt;\n&lt;code&gt;sort(数组)&lt;/code&gt; 按照默认升序对数组的元素进行排序：注意 如果数组内是自定义类型，那么这个自定义类需要有 &lt;code&gt;Comparable&lt;/code&gt; 或者 &lt;code&gt;Comparator&lt;/code&gt; 接口的支持。&lt;/p&gt;\n&lt;h3 id=\&#34;math\&#34;&gt;Math&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;abs(double num)&lt;/code&gt; 绝对值&lt;br&gt;\n&lt;code&gt;ceil(double num)&lt;/code&gt; 向上取整&lt;br&gt;\n&lt;code&gt;floor(double num)&lt;/code&gt; 向下取整&lt;br&gt;\n&lt;code&gt;round(double num)&lt;/code&gt; 四舍五入&lt;br&gt;\n&lt;code&gt;Math.PI&lt;/code&gt; 圆周率&lt;/p&gt;\n&lt;h2 id=\&#34;4-继承\&#34;&gt;④ 继承&lt;/h2&gt;\n&lt;h3 id=\&#34;继承\&#34;&gt;继承&lt;/h3&gt;\n&lt;p&gt;子类继承父类的属性和行为，使得子类对象具有父类相同的属性、相同的行为，子类可以直接访问父类中的非私有的属性和行为。&lt;br&gt;\n优点：&lt;br&gt;\n1、提高代码的复用性&lt;br&gt;\n2、类与类之间产生了关系，是多态的前提。&lt;/p&gt;\n&lt;p&gt;子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有变量时，需要使用 &lt;code&gt;super&lt;/code&gt; 关键字修饰父类成员变量。&lt;/p&gt;\n&lt;p&gt;如果子父类中出现了同名的成员方法，这是的访问是一种特殊情况-称之为&lt;strong&gt;方法重写&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Java 中指支持单继承，不支持多继承。&lt;/p&gt;\n&lt;h3 id=\&#34;抽象类\&#34;&gt;抽象类&lt;/h3&gt;\n&lt;p&gt;父类中的方法，被他的子类们重写，子类各自的实现都不尽相同，那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了，我们把没有方法主体的方法称为抽象方法。包含抽象方法的类就是抽象类。&lt;/p&gt;\n&lt;h3 id=\&#34;抽象方法\&#34;&gt;抽象方法&lt;/h3&gt;\n&lt;p&gt;抽象方法，方法前加 &lt;code&gt;abstract&lt;/code&gt; 关键字,去掉关键字，直接分号结束。&lt;br&gt;\n定义格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;修饰符 abstract 返回值类型 方法名(参数列表);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;抽象类-2\&#34;&gt;抽象类&lt;/h3&gt;\n&lt;p&gt;抽象类：抽象方法所在的类，必须是抽象类才行，在 class 之前写上 &lt;code&gt;abstract&lt;/code&gt; 即可。抽象类可以定义正常方法。&lt;br&gt;\n定义格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;abstract class 类名字\n{\n    ///xxx\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;抽象类不能实例化，必须用子类继承抽象父类，子类必须覆盖重写抽象类的所有抽象方法。&lt;/li&gt;\n&lt;li&gt;抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。&lt;/li&gt;\n&lt;li&gt;抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。&lt;/li&gt;\n&lt;li&gt;抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错，除非子类也是抽象类。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;5-接口\&#34;&gt;⑤ 接口&lt;/h2&gt;\n&lt;p&gt;接口是 Java 中的一种引用类型，是方法的集合，如果类的内部封装了成员变量，构造方法和成员方法，那么接口的内部主要就是封装了方法。接口不是类，是一种引用数据类型，其他的引用数据类型还包括：数组、类。&lt;br&gt;\n接口可包含五部分：常量、抽象方法、默认方法、静态方法、私有方法&lt;br&gt;\n定义格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public interface 接口名称\n{\n    // 抽象方法,继承类必须全部实现\n    // 默认方法,default 修饰符修饰，可以继承可以重写，必须通过实现类来调用\n    // 静态方法,只能通过接口名调用，不可通过实现类名或者实现类对象调用\n    // 私有方法,私有成员方法只有默认方法可以调用、私有静态方法只有默认方法和静态方法可以调用\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接口使用步骤：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;接口不能直接使用，必须有一个“实现类”来“实现”该接口；格式：&lt;code&gt;public class 实现类名称 implement 接口名称&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;接口的实现类必须覆盖重写接口中所有的抽象方法。&lt;/li&gt;\n&lt;li&gt;创建实现类的对象，进行使用&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;注意事项：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果实现类并没有覆盖重写接口的所有抽象方法，那么这个实现类自己就必须是抽象类。&lt;/li&gt;\n&lt;li&gt;接口没有静态代码块或者构造方法&lt;/li&gt;\n&lt;li&gt;一个类的直接父类是唯一的，但是一个类可以用时实现多个接口。格式：&lt;code&gt;public class 类名称 implements 接口 A, 接口 B {}&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;多个接口存在相同名称抽象方法，实现类只需覆盖重写一次即可。&lt;/li&gt;\n&lt;li&gt;如果实现类没有覆盖重写所有接口中定义的所有抽象方法，那么实现类就必须是一个抽象类。&lt;/li&gt;\n&lt;li&gt;如果多个接口中存在相同名称的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。&lt;/li&gt;\n&lt;li&gt;一个类如果直接父类中的方法和接口当中的默认方法产生了冲突，优先用父类中的方法。（Java 继承优先级高于接口）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;接口中的方法默认是抽象方法\&#34;&gt;接口中的方法默认是抽象方法&lt;/h3&gt;\n&lt;p&gt;格式： &lt;code&gt;public abstract 返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;br&gt;\n实现类必须覆盖重写接口所有抽象方法，除非实现类是抽象类。&lt;/p&gt;\n&lt;h3 id=\&#34;接口中的默认方法\&#34;&gt;接口中的默认方法&lt;/h3&gt;\n&lt;p&gt;接口中的默认方法可以解决接口升级的问题。&lt;br&gt;\n格式：&lt;code&gt;public default 返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;接口中静态方法\&#34;&gt;接口中静态方法&lt;/h3&gt;\n&lt;p&gt;不能用接口实现类的对象来调用接口中的静态方法，应该直接使用接口名称直接调用静态方法。&lt;br&gt;\n格式：&lt;code&gt;public static 返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;接口中的私有方法\&#34;&gt;接口中的私有方法&lt;/h3&gt;\n&lt;p&gt;抽取公共方法用来解决多个默认方法之间重复代码的问题，但这个共有方法不应该让实现类使用，应该是私有化的。&lt;br&gt;\n格式：&lt;code&gt;private default  返回值类型 方法名称(参数列表);&lt;/code&gt;、&lt;code&gt;private static  返回值类型 方法名称(参数列表);&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;接口中的成员变量-即-常量\&#34;&gt;接口中的“成员变量” 即 “常量”&lt;/h3&gt;\n&lt;p&gt;接口中可以定义“成员变量”，但必须使用 &lt;code&gt;public static final&lt;/code&gt; 三个关键字进行修饰（可省略）。从效果上看，这其实就是接口的“常量”。一旦使用 &lt;code&gt;final&lt;/code&gt; 关键字，说明不可变&lt;br&gt;\n格式：&lt;code&gt;public static final 数据类型 名称 = 数据值;&lt;/code&gt;&lt;br&gt;\n注意事项：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;接口中的常量，可以省略 &lt;code&gt;public static final&lt;/code&gt; 关键字。含义不变。&lt;/li&gt;\n&lt;li&gt;接口中的常量，必须进行赋值，不能不赋值。&lt;/li&gt;\n&lt;li&gt;建议常量名称大写。多个单词用 _ 分割。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;接口中的多继承\&#34;&gt;接口中的多继承&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;类与类之间是单继承的，直接父类只有一个&lt;/li&gt;\n&lt;li&gt;类与接口之间是多继承的，一个类可以实现多个接口&lt;/li&gt;\n&lt;li&gt;接口与接口之间是多继承的\n&lt;ul&gt;\n&lt;li&gt;多个父接口中的抽象方法可以重复&lt;/li&gt;\n&lt;li&gt;多个父接口中的默认方法如果重复，必须在子接口进行覆盖重写，并带 &lt;code&gt;default&lt;/code&gt; 关键字。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;接口其他特性\&#34;&gt;接口其他特性&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;接口中，无法定义成员变量，但可以定义常量，其值不可改变，默认使用 &lt;code&gt;public static final&lt;/code&gt; 修饰，可以省略、&lt;/li&gt;\n&lt;li&gt;接口中，没有构造方法，不能创建对象&lt;/li&gt;\n&lt;li&gt;接口中，没有静态代码块&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;6-多态\&#34;&gt;⑥ 多态&lt;/h2&gt;\n&lt;p&gt;对象具有多个形态&lt;br&gt;\n代码中体现多态性，父类引用指向子类对象。格式：&lt;code&gt;父类名称 对象名 = new 子类名称();&lt;/code&gt; 或 &lt;code&gt;接口名称 对象名 = new 实现类名称();&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;多态访问成员变量的两种方式：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。（成员变量无法进行覆盖重写）&lt;/li&gt;\n&lt;li&gt;间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;多态访问成员方法：&lt;br&gt;\n看 new 的是谁，就优先用谁，没有则向上找。&lt;/p&gt;\n&lt;p&gt;口诀：&lt;br&gt;\n多态访问成员变量：编译看左边，运行也看左边&lt;br&gt;\n多态访问成员方法：编译看左边，运行看右边。&lt;/p&gt;\n&lt;p&gt;多态的好处：无论右边 new 的是哪个子类对象，左边声明的类和调用的方法可以保持一致。&lt;/p&gt;\n&lt;h3 id=\&#34;对象的向上转型\&#34;&gt;对象的向上转型&lt;/h3&gt;\n&lt;p&gt;其实就是多态的写法：&lt;code&gt;父类名称 对象名 = new 子类名称();&lt;/code&gt;&lt;br&gt;\n含义：右侧创建一个子类对象，把它当做父类看待使用。&lt;br&gt;\n注意事项：向上转型一定是安全的。类似于基本数据类型的类型转换 （float -&amp;gt; double）&lt;br&gt;\n弊端：一旦向上转型为父类，那么就无法调用子类原本特有的内容。（解决方案-使用向下转型）&lt;/p&gt;\n&lt;h3 id=\&#34;对象的向下转型\&#34;&gt;对象的向下转型&lt;/h3&gt;\n&lt;p&gt;其实是一个还原的动作。格式：&lt;code&gt;子类名称 对象名 = (子类名称)父类对象;&lt;/code&gt;&lt;br&gt;\n含义：将父类对象，&lt;strong&gt;还原&lt;/strong&gt;为本来的子类对象&lt;br&gt;\n注意事项：&lt;br&gt;\n必须保证对象创建的时候就是向下转型的类型。&lt;/p&gt;\n&lt;h3 id=\&#34;instanceof-关键字\&#34;&gt;&lt;code&gt;instanceof&lt;/code&gt; 关键字&lt;/h3&gt;\n&lt;p&gt;返回一个 boolean 值，判断前面的对象能不能当做后面类型的实例。&lt;br&gt;\n格式：&lt;code&gt;对象名 instanceof 类名&lt;/code&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;7-其他\&#34;&gt;⑦ 其他&lt;/h2&gt;\n&lt;h3 id=\&#34;final-关键字\&#34;&gt;&lt;code&gt;final&lt;/code&gt; 关键字&lt;/h3&gt;\n&lt;p&gt;用于修饰&lt;strong&gt;不可改变&lt;/strong&gt;的内容&lt;/p&gt;\n&lt;h4 id=\&#34;final-用法\&#34;&gt;&lt;code&gt;final&lt;/code&gt; 用法&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;修饰类：不能有任何子类，而且一个类如果是 &lt;code&gt;final&lt;/code&gt; 的，那么其中所有的成员方法都无法对其进行覆盖重写&lt;/li&gt;\n&lt;li&gt;修饰方法：这个方法不能被覆盖重写，对于类和方法而言，&lt;code&gt;abstract&lt;/code&gt; 关键字和 &lt;code&gt;final&lt;/code&gt; 关键字不能同时使用，因为矛盾。&lt;/li&gt;\n&lt;li&gt;修饰局部变量：这个变量只能被赋值一次，不能再次被修改。“一次赋值，终生不变”。对于基本数据类型，不可变值得是变量中的数据不可变；对于引用类型，不可变指的是变量中的地址值不可变。&lt;/li&gt;\n&lt;li&gt;修饰成员变量：这个变量只能而且必须被赋值一次，不能再次被修改。而且不再有默认值。\n&lt;ol&gt;\n&lt;li&gt;由于成员变量具有默认值，所以用了 &lt;code&gt;final&lt;/code&gt; 之后必须手动赋值，不会再有默认值。&lt;/li&gt;\n&lt;li&gt;对于 &lt;code&gt;final&lt;/code&gt; 的成员变量，要么使用直接赋值，要么使用构造方法赋值，两者取其一。&lt;/li&gt;\n&lt;li&gt;如果使用构造方法对 &lt;code&gt;final&lt;/code&gt; 修饰的成员变量赋值，必须保证类中所有重载的构造方法，都最终会对 &lt;code&gt;final&lt;/code&gt; 的成员变量进行赋值。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;被 &lt;code&gt;final&lt;/code&gt; 修饰的常量名称，一般有书写规范，所有字母均大写。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;java-中的四种权限修饰符\&#34;&gt;Java 中的四种权限修饰符&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;public &amp;gt; protected (专门给不同包子类用的) &amp;gt; (default) &amp;gt; private&lt;/code&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;&lt;/th&gt;\n&lt;th&gt;public&lt;/th&gt;\n&lt;th&gt;protected&lt;/th&gt;\n&lt;th&gt;（default）&lt;/th&gt;\n&lt;th&gt;private&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;同一个类（我自己）&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;用一个包（我邻居）&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;NO&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;不同包子类（我儿子）&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;NO&lt;/td&gt;\n&lt;td&gt;NO&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;不同包非子类（陌生人）&lt;/td&gt;\n&lt;td&gt;YES&lt;/td&gt;\n&lt;td&gt;NO&lt;/td&gt;\n&lt;td&gt;NO&lt;/td&gt;\n&lt;td&gt;NO&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h3 id=\&#34;内部类\&#34;&gt;内部类&lt;/h3&gt;\n&lt;h4 id=\&#34;分类\&#34;&gt;分类：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;成员内部类&lt;/li&gt;\n&lt;li&gt;局部内部类（包含匿名内部类）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;成员内部类\&#34;&gt;成员内部类&lt;/h4&gt;\n&lt;p&gt;格式:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;修饰符 class 外部类名称 \n{\n    修饰符 class 内部类名称\n    {\n        xxx\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;内部类可以直接访问外部类的成员，包括私有成员。&lt;br&gt;\n外部类要访问内部类的成员，必须建立内部类的对象。&lt;br&gt;\n即 : 内用外，随意访问。外用内需要借助内部类对象。&lt;/p&gt;\n&lt;h4 id=\&#34;如何使用成员内部类\&#34;&gt;如何使用成员内部类&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;间接方式：在外部类的方法中，使用内部类；然后 main 只是调用外部类的方法。&lt;/li&gt;\n&lt;li&gt;直接方式：定义格式：&lt;code&gt;外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;内部类使用外部类的成员变量\&#34;&gt;内部类使用外部类的成员变量&lt;/h4&gt;\n&lt;p&gt;如果出现重名现象，使用格式：&lt;code&gt;外部类名称.this.外部类成员变量名&lt;/code&gt;&lt;br&gt;\n实例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Outer\n{\n    int num = 10;\n     public class Inner\n     {\n        int num = 20;\n        public void methodInner()\n        {\n           int num = 30;\n           System.out.println(num); // 局部变量，就近原则\n           System.out.println(this.num); // 内部类的成员变量\n           System.out.println(Outer.this.num); // 外部类的成员变量\n        }\n     }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;局部内部类\&#34;&gt;局部内部类&lt;/h4&gt;\n&lt;p&gt;如果一个类定义在一个方法内部，那么就是局部内部类。&lt;br&gt;\n“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。&lt;/p&gt;\n&lt;p&gt;局部内部类如果要访问所在方法的局部变量，那么这个局部变量必须是【有效 final 的】即 用 final 声明的变量或者事实上只赋值一次的变量。&lt;br&gt;\n原因：new 出来的对象在堆内存中，局部变量跟着方法走，在栈内存中。方法运行结束立刻出栈，局部变量立即消失。但是 new 出来的对象会在堆中持续存在，直到垃圾回收消失。&lt;/p&gt;\n&lt;h4 id=\&#34;定义类的权限修饰符\&#34;&gt;定义类的权限修饰符&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;外部类：&lt;code&gt;public 或 (default)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;成员内部类：都可以&lt;/li&gt;\n&lt;li&gt;局部内部类：什么都不能写&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;匿名内部类\&#34;&gt;匿名内部类&lt;/h4&gt;\n&lt;p&gt;如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用&lt;strong&gt;匿名内部类&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;定义格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;接口名称 对象名 = new 接口名称()\n{\n    /// 覆盖重写接口中所有的抽象方法。\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对格式 &amp;quot;new 接口名称(){...}&amp;quot; 进行解析：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;new 代表创建对象的动作&lt;/li&gt;\n&lt;li&gt;接口名称就是匿名内部类需要实现哪个接口&lt;/li&gt;\n&lt;li&gt;{...} 这才是匿名内部类的内容&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;注意事项：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;匿名内部类，在【创建对象】的时候只能使用唯一一次，如果希望多次创建对象，那么就必须使用单独定义的实现类。&lt;/li&gt;\n&lt;li&gt;匿名对象，在【调用方法】的时候只能调用唯一一次，如果希望同一个对象调用多次方法，那么必须给对象起个名字。&lt;/li&gt;\n&lt;li&gt;匿名内部类是省略了【实现类/子类名称】，但是匿名对象时省略了【对象名称】，匿名内部类和匿名对象不是一回事！！&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;interface-作为成员变量\&#34;&gt;&lt;code&gt;interface&lt;/code&gt; 作为成员变量&lt;/h3&gt;\n&lt;p&gt;使用接口作为成员变量以便随时更换实现方式，这种设计更为灵活，增强了程序的扩展性。&lt;br&gt;\n接口作为成员变量时，对他进行复制的操作，实际上是赋给他接口的一个子类实现对象。&lt;/p&gt;\n&lt;p&gt;接口作为参数数，传递它的子类对象；&lt;br&gt;\n接口作为返回值类型是，也是返回它的子类对象。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java-ji-chu-yu-fa-yi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;java-基础语法一\&#34;&gt;Java - 基础语法一&lt;/h1&gt;\n&lt;h2 id=\&#34;1-基础语法\&#34;&gt;① 基础语法&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;JVM（Java Virtual Machine）: Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 程序，都运行在 JVM 之上。&lt;/li&gt;\n&lt;li&gt;JRE（Java Runtime Environment）：Java 程序的运行环境，包含 JVM 和运行时所需要的核心类库。&lt;/li&gt;\n&lt;li&gt;JDK（Java Development Environment）：Java 程序开发工具包，包含 JRE 和开发人员使用的工具。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;Java - 基础语法一&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;9H4f1SDbS&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/9H4f1SDbS/&#34;}],&#34;date&#34;:&#34;2020-03-28 22:18:04&#34;,&#34;dateFormat&#34;:&#34;2020-03-28&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2020.03.28.15854051821300.maximilian-weisbecker-1td5Iq5IvNc-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/java-ji-chu-yu-fa-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;19 min read&#34;,&#34;time&#34;:1126000,&#34;words&#34;:5362,&#34;minutes&#34;:19},&#34;description&#34;:&#34;Java - 基础语法一\n① 基础语法\n\nJVM（Java Virtual Machine）: Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80\&#34;&gt;Java - 基础语法一&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\&#34;&gt;① 基础语法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95\&#34;&gt;方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%E4%B8%80%E6%A0%B7%E4%BD%86%E6%98%AF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%B8%8D%E4%B8%80%E6%A0%B7\&#34;&gt;方法重载：多个方法的名称一样，但是参数列表不一样&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BB%A5%E4%B8%8B%E5%9B%A0%E7%B4%A0%E6%9C%89%E5%85%B3\&#34;&gt;方法重载与以下因素有关：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BB%A5%E4%B8%8B%E5%9B%A0%E7%B4%A0%E6%97%A0%E5%85%B3\&#34;&gt;方法重载与以下因素无关：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E4%B8%80%E7%A7%8D%E5%AE%B9%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%AD%98%E6%94%BE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90\&#34;&gt;数组：一种容器，可以同时存放多个数据源&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E7%89%B9%E7%82%B9\&#34;&gt;数组特点：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84%E5%BD%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0\&#34;&gt;动态初始化：在创建数组的时候，直接指定数组当中的数据元素个数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%E5%A4%9A%E5%B0%91%E8%80%8C%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%B0%86%E5%85%B7%E4%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%8C%87%E5%AE%9A\&#34;&gt;静态初始化：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\&#34;&gt;注意事项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-%E7%9A%84%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%81%E5%88%92%E5%88%86%E6%88%90%E4%B8%BA-5-%E4%B8%AA%E9%83%A8%E5%88%86\&#34;&gt;Java 的内存需要划分成为 5 个部分：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\&#34;&gt;② 面向对象&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\&#34;&gt;局部变量和成员变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81\&#34;&gt;面向对象三大特性：封装、继承、多态&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\&#34;&gt;构造方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%BC%E5%BC%8F\&#34;&gt;格式：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\&#34;&gt;构造方法使用注意事项：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB\&#34;&gt;标准的类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%B8%B8%E7%94%A8-api\&#34;&gt;③ 常用 API&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#random\&#34;&gt;Random&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arraylist\&#34;&gt;ArrayList&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#string\&#34;&gt;String&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%89%B9%E7%82%B9\&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#static-%E5%85%B3%E9%94%AE%E5%AD%97\&#34;&gt;Static 关键字&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arrays\&#34;&gt;Arrays&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#math\&#34;&gt;Math&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E7%BB%A7%E6%89%BF\&#34;&gt;④ 继承&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%A7%E6%89%BF\&#34;&gt;继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E8%B1%A1%E7%B1%BB\&#34;&gt;抽象类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\&#34;&gt;抽象方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E8%B1%A1%E7%B1%BB-2\&#34;&gt;抽象类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E6%8E%A5%E5%8F%A3\&#34;&gt;⑤ 接口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%BB%98%E8%AE%A4%E6%98%AF%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\&#34;&gt;接口中的方法默认是抽象方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95\&#34;&gt;接口中的默认方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\&#34;&gt;接口中静态方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95\&#34;&gt;接口中的私有方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%8D%B3-%E5%B8%B8%E9%87%8F\&#34;&gt;接口中的“成员变量” 即 “常量”&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF\&#34;&gt;接口中的多继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7\&#34;&gt;接口其他特性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E5%A4%9A%E6%80%81\&#34;&gt;⑥ 多态&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B\&#34;&gt;对象的向上转型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B\&#34;&gt;对象的向下转型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#instanceof-%E5%85%B3%E9%94%AE%E5%AD%97\&#34;&gt;&lt;code&gt;instanceof&lt;/code&gt; 关键字&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E5%85%B6%E4%BB%96\&#34;&gt;⑦ 其他&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#final-%E5%85%B3%E9%94%AE%E5%AD%97\&#34;&gt;&lt;code&gt;final&lt;/code&gt; 关键字&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#final-%E7%94%A8%E6%B3%95\&#34;&gt;&lt;code&gt;final&lt;/code&gt; 用法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\&#34;&gt;Java 中的四种权限修饰符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E9%83%A8%E7%B1%BB\&#34;&gt;内部类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E7%B1%BB\&#34;&gt;分类：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB\&#34;&gt;成员内部类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB\&#34;&gt;如何使用成员内部类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\&#34;&gt;内部类使用外部类的成员变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB\&#34;&gt;局部内部类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\&#34;&gt;定义类的权限修饰符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\&#34;&gt;匿名内部类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#interface-%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\&#34;&gt;&lt;code&gt;interface&lt;/code&gt; 作为成员变量&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;ios-类与对象\&#34;&gt;iOS - 类与对象&lt;/h1&gt;\n&lt;h3 id=\&#34;类方法\&#34;&gt;类方法&lt;/h3&gt;\n&lt;p&gt;OC 中类的方法只有实例方法和静态方法两种：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;@interface Controller: NSObject\n/// 静态方法\n+ (void)thisIsAStaticMethod;\n\n/// 实例方法\n- (void)thisIsAnInstanceMethod;\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;OC 中的方法只要声明在 @interface 里，就可以认为是公有的。实际上，OC 没有像 Java，C++ 中的那种绝对的 私有及保护 的成员方法，仅仅可以对调用者隐藏某些方法。&lt;/p&gt;\n&lt;p&gt;声明和实现都写在 @implementation 里的方法，类的外部是看不到的。&lt;/p&gt;\n&lt;p&gt;可以使用 分类（Category） 和 类扩展（Extension）来实现私有方法。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;// AClass.h\n@interface AClass: NSObject\n- (void)sayHello;\n@end\n\n// AClass.m\n@interface AClass (private)\n- (void)privateSayHello1;\n@end\n\n@interface AClass ()\n- (void)privateSayHello2;\n@end\n\n@implementation AClass\n- (void)sayHello \n{\n    [self privateSayHello];\n}\n\n- (void)privateSayHello1\n{\n    NSLog(@&amp;quot;privateSayHello1&amp;quot;);\n}\n\n- (void)privateSayHello2\n{\n    NSLog(@&amp;quot;privateSayHello2&amp;quot;);\n}\n\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用这种方法外部就不能直接调用到 &lt;code&gt;privateSayHello1&lt;/code&gt; 和 &lt;code&gt;privateSayHello2&lt;/code&gt; 方法。&lt;/p&gt;\n&lt;h3 id=\&#34;类变量\&#34;&gt;类变量&lt;/h3&gt;\n&lt;p&gt;Apple 推荐现代的 Objective-C 中使用 &lt;code&gt;@property&lt;/code&gt; 来实现成员变量，使用 &lt;code&gt;@property&lt;/code&gt; 声明的变量可以使用 &lt;code&gt;实例名.变量名&lt;/code&gt; 来获取和修改。&lt;br&gt;\n&lt;code&gt;@property&lt;/code&gt; 可以看做一种语法糖，使用 &lt;code&gt;@property&lt;/code&gt; 此声明&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;@interface AClass: NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可等价于&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;@interface AClass: NSObject\n{\n    NSString *_name;\n}\n- (NSString *)name;\n- (void)setName:(NSString *)name;\n@end\n\n@implementation AClass\n- (NSString *)name\n{\n    return _name;\n}\n- (void)setName:(NSString *)name\n{\n    _name = name;\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;@property&lt;/code&gt; 会自动生成 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法，同时进行自动内存管理&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;@property&lt;/code&gt; 可声明的属性修饰符有如下几种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;readwrite&lt;/code&gt; 可读写，需要生成 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;readonly&lt;/code&gt; 只读，只会生成 &lt;code&gt;getter&lt;/code&gt; 方法，不会生成 &lt;code&gt;setter&lt;/code&gt; 方法，不希望属性在类外改变时使用。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;assign&lt;/code&gt; 赋值属性，&lt;code&gt;setter&lt;/code&gt; 方法将传入的参数赋值给实例变量。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;strong&lt;/code&gt; 持有特性，&lt;code&gt;setter&lt;/code&gt; 方法将传入的参数先保留，再赋值，传入参数的引用计数会 +1。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;copy&lt;/code&gt; 拷贝特性，&lt;code&gt;setter&lt;/code&gt; 方法将传入对象复制一份；需要完全一份新的变量时使用。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;nonatomic&lt;/code&gt; 和 &lt;code&gt;atomic&lt;/code&gt; ，决定编译器生成的 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法是否是原子操作。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;默认的 &lt;code&gt;@property&lt;/code&gt; 是&lt;br&gt;\n基本数据类型： &lt;code&gt;readwrite&lt;/code&gt;、&lt;code&gt;assign&lt;/code&gt;、&lt;code&gt;atomic&lt;/code&gt;；&lt;br&gt;\n对象： &lt;code&gt;readwrite&lt;/code&gt;、&lt;code&gt;strong&lt;/code&gt;、&lt;code&gt;atomic&lt;/code&gt;；&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;protocol\&#34;&gt;Protocol&lt;/h3&gt;\n&lt;p&gt;OC 是单继承的，OC 中的类可以实现多个 &lt;code&gt;protocol&lt;/code&gt; 来实现类似 C++ 中多重继承的效果。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;protocol&lt;/code&gt; 类似 JAVA 中的 &lt;code&gt;interface&lt;/code&gt;，定义了一个方法列表，这个方法列表中的方法可以使用 &lt;code&gt;@required&lt;/code&gt; &lt;code&gt;@optional&lt;/code&gt; 标注，以表示该方法是否客户类必须要实现的方法。&lt;/p&gt;\n&lt;p&gt;当 &lt;code&gt;protocol&lt;/code&gt; 中含有 &lt;code&gt;property&lt;/code&gt; 时，编译器不会进行自动 &lt;code&gt;synthesize&lt;/code&gt; 的，需要手动处理：在实现这个 &lt;code&gt;protocol&lt;/code&gt; 的时候要么再次声明 &lt;code&gt;property&lt;/code&gt; 要么手动 &lt;code&gt;synthesize&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;category\&#34;&gt;Category&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;Category&lt;/code&gt; 是一种很灵活的扩展原有类的机制，使用 &lt;code&gt;Category&lt;/code&gt; 不需要访问原有类的代码，也无需集成，&lt;code&gt;Category&lt;/code&gt; 提供了一种简单的方式，来实现类的相关方法的模块化，把不同的方法分配到不同的类文件中。&lt;/p&gt;\n&lt;p&gt;在使用 &lt;code&gt;Category&lt;/code&gt; 时需要注意的是，如果有多个 &lt;code&gt;Category&lt;/code&gt; 均实现了同一个方法，那么这些方法在运行时只有一个会被调用，具体哪个会被调用是不确定的，因此建议在使用 &lt;code&gt;Category&lt;/code&gt; 时在函数命名方法加上前缀。&lt;/p&gt;\n&lt;h3 id=\&#34;extension\&#34;&gt;Extension&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;Extension&lt;/code&gt; 可以认为是一种匿名的 &lt;code&gt;Category&lt;/code&gt; ，&lt;code&gt;Extension&lt;/code&gt; 与 &lt;code&gt;Category&lt;/code&gt; 有如下区别：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;使用 &lt;code&gt;Extension&lt;/code&gt; 必须有原有类的源码&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Extension&lt;/code&gt; 声明的方法必须在类的主 &lt;code&gt;@implementation&lt;/code&gt; 区间内实现，可以避免使用有名 &lt;code&gt;Category&lt;/code&gt; 带来的多个不必要的&lt;code&gt;@implementation&lt;/code&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Extension&lt;/code&gt; 可以在类中添加新的属性和实例变量，&lt;code&gt;Category&lt;/code&gt; 不可以。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Extension&lt;/code&gt; 和 &lt;code&gt;Category&lt;/code&gt; 里添加的方法必须要有实现。（没有实现编译器会给出警告）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Category&lt;/code&gt; 一般用来给类添加私有的变量和方法，在类的内部使用。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;如果在类中添加全局变量\&#34;&gt;如果在类中添加全局变量&lt;/h3&gt;\n&lt;p&gt;一个简单直接的做法是在 .m 文件中使用 &lt;code&gt;static&lt;/code&gt; 变量。由于 &lt;code&gt;static&lt;/code&gt; 变量在编译器就是确定的，因此对于 &lt;code&gt;NSObject&lt;/code&gt; 对象来说，初始化的值只能是 nil, 如何进行类似 init 的初始化呢? 可以通过重载 &lt;code&gt;initialize&lt;/code&gt; 方法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;static NSOperationQueue *_queue = nil;\n@implementation XWPerson\n- (void)initialize\n{\n    if (!_queue) {\n        _queue = [[NSOperationQueue alloc] init];\n    }\n}\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;为什么这里要判断是否为 &lt;code&gt;nil&lt;/code&gt; 呢？因为 &lt;code&gt;initialize&lt;/code&gt; 方法可能会调用多次。&lt;/p&gt;\n&lt;p&gt;有一种方法是声明 &lt;code&gt;static&lt;/code&gt; 函数，下面代码来自 &lt;a href=\&#34;https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m\&#34;&gt;AFNetworking&lt;/a&gt;，声明了一个当前文件范围可用的队列：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;static dispatch_queue_t url_session_manager_creation_queue() {\n    static dispatch_queue_t af_url_session_manager_creation_queue;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;amp;onceToken, ^{\n        af_url_session_manager_creation_queue = dispatch_queue_create(&amp;quot;com.alamofire.networking.session.manager.creation&amp;quot;, DISPATCH_QUEUE_SERIAL);\n    });\n\n    return af_url_session_manager_creation_queue;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;除此以外，还可以通过编译器的 &lt;code&gt;__attribute_&lt;/code&gt; 特性来实现初始化：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;__attribute__((constructor))\nstatic void initialize_Queue() {\n    _personOperationQueue = [[NSOperationQueue alloc] init];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;类的初始化\&#34;&gt;类的初始化&lt;/h3&gt;\n&lt;p&gt;Objective-C 是建立在 Runtime 基础上的语言，类也不例外。OC 中类的初始化也是动态的，在 OC 中绝大部分类都继承自 &lt;code&gt;NSObject&lt;/code&gt; ，它有两个非常特殊的类方法 &lt;code&gt;+load&lt;/code&gt; 和 &lt;code&gt;+initialize&lt;/code&gt;，用于类的初始化。&lt;/p&gt;\n&lt;h4 id=\&#34;load\&#34;&gt;&lt;code&gt;+load&lt;/code&gt;&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;+load&lt;/code&gt; 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 &lt;code&gt;+load&lt;/code&gt; 方法会在它所有的父类的 &lt;code&gt;+load&lt;/code&gt; 方法之后执行，而分类的 &lt;code&gt;+load&lt;/code&gt; 方法会在它的主类 &lt;code&gt;+load&lt;/code&gt; 方法之后执行。&lt;/p&gt;\n&lt;h4 id=\&#34;initialize\&#34;&gt;&lt;code&gt;+initialize&lt;/code&gt;&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;+initialize&lt;/code&gt; 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 &lt;code&gt;+initialize&lt;/code&gt; 方法是以懒加载的方式被调用的。如果程序一直没有给某各类或它的子类发送消息，那么这个类的 &lt;code&gt;+initialize&lt;/code&gt; 方法是永远不会被调用的。&lt;/p&gt;\n&lt;p&gt;如果一个分类实现了 &lt;code&gt;+initialize&lt;/code&gt; 方法，那么就会对这个类中的实现造成覆盖。&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;更多干货文章\&#34;&gt;更多干货文章&lt;/h3&gt;\n&lt;h5 id=\&#34;博客wwwqiuxueweicom\&#34;&gt;博客：&lt;a href=\&#34;http://www.qiuxuewei.com\&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;微信公众号开发者成长之路\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;\&#34;&gt;&lt;img src=\&#34;http://blog.image.jkxuewei.com/sou_wechat.png\&#34; alt=\&#34;公众号二维码\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;\n&lt;hr&gt;\n&#34;,&#34;fileName&#34;:&#34;ios-lei-yu-dui-xiang&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;ios-类与对象\&#34;&gt;iOS - 类与对象&lt;/h1&gt;\n&lt;h3 id=\&#34;类方法\&#34;&gt;类方法&lt;/h3&gt;\n&lt;p&gt;OC 中类的方法只有实例方法和静态方法两种：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-ObjectiveC\&#34;&gt;@interface Controller: NSObject\n/// 静态方法\n+ (void)thisIsAStaticMethod;\n\n/// 实例方法\n- (void)thisIsAnInstanceMethod;\n@end\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;OC 中的方法只要声明在 @interface 里，就可以认为是公有的。实际上，OC 没有像 Java，C++ 中的那种绝对的 私有及保护 的成员方法，仅仅可以对调用者隐藏某些方法。&lt;/p&gt;\n&lt;p&gt;声明和实现都写在 @implementation 里的方法，类的外部是看不到的。&lt;/p&gt;\n&lt;p&gt;可以使用 分类（Category） 和 类扩展（Extension）来实现私有方法。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;iOS - 类与对象&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;iOS 基础&#34;,&#34;slug&#34;:&#34;PmC0N8rc0&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/PmC0N8rc0/&#34;}],&#34;date&#34;:&#34;2020-01-02 20:57:00&#34;,&#34;dateFormat&#34;:&#34;2020-01-02&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2020.01.02.15779697951077.baim-hanif-pYWuOMhtc6k-unsplash-1.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/ios-lei-yu-dui-xiang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:339000,&#34;words&#34;:1478,&#34;minutes&#34;:6},&#34;description&#34;:&#34;iOS - 类与对象\n类方法\nOC 中类的方法只有实例方法和静态方法两种：\n@interface Controller: NSObject\n/// 静态方法\n+ (void)thisIsAStaticMethod;\n\n/// 实例方法\n- ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#ios-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1\&#34;&gt;iOS - 类与对象&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E6%96%B9%E6%B3%95\&#34;&gt;类方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E5%8F%98%E9%87%8F\&#34;&gt;类变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#protocol\&#34;&gt;Protocol&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#category\&#34;&gt;Category&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#extension\&#34;&gt;Extension&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\&#34;&gt;如果在类中添加全局变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\&#34;&gt;类的初始化&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#load\&#34;&gt;&lt;code&gt;+load&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#initialize\&#34;&gt;&lt;code&gt;+initialize&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E5%A4%9A%E5%B9%B2%E8%B4%A7%E6%96%87%E7%AB%A0\&#34;&gt;更多干货文章&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E5%AE%A2wwwqiuxueweicom\&#34;&gt;博客：www.qiuxuewei.com&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%80%85%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!公众号二维码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;内存管理-磁盘和文件拾遗\&#34;&gt;内存管理、磁盘和文件拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-内存管理\&#34;&gt;Part1. 内存管理&lt;/h2&gt;\n&lt;p&gt;一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。&lt;br&gt;\n可读写部分（变量）大致可分为下面几个部分：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：初始化了的全局变量和静态变量&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：即 &lt;code&gt;Block Started by Symbol&lt;/code&gt;，未初始化的全局变量和静态变量&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;heap&lt;/code&gt;：堆，使用 &lt;code&gt;malloc&lt;/code&gt;、&lt;code&gt;realloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;stack&lt;/code&gt;：栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;1-data-和-bss-区\&#34;&gt;1. &lt;code&gt;.data&lt;/code&gt; 和 &lt;code&gt;.bss&lt;/code&gt; 区&lt;/h3&gt;\n&lt;p&gt;这两个经常放在一起说，因为他们都是用来存储全局变量和静态变量的，区别在于 &lt;code&gt;.data&lt;/code&gt; 区存放的初始化过的，&lt;code&gt;.bss&lt;/code&gt;区存放的是没有初始化过的。例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int val = 3;\nchar string[] = &#39;Hello World&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这两个变量的值会在一开始被存储在 &lt;code&gt;.text&lt;/code&gt; 中，因为值是写在代码里面的，在程序启动时会拷贝到 &lt;code&gt;.data&lt;/code&gt; 区中。&lt;br&gt;\n若不初始化，类似:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;static int i;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个变量就会被放在 &lt;code&gt;.bss&lt;/code&gt; 区中。&lt;/p&gt;\n&lt;h4 id=\&#34;静态变量和全局变量\&#34;&gt;静态变量和全局变量&lt;/h4&gt;\n&lt;h5 id=\&#34;全局变量\&#34;&gt;全局变量&lt;/h5&gt;\n&lt;p&gt;在一个代码文件中，一个变量要么定义在函数中，要么定义在函数外。当定义在函数外时，这个变量就有了全局作用域，成为了全局变量。&lt;br&gt;\n全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫 &lt;code&gt;external linkage&lt;/code&gt;）。&lt;br&gt;\n当有如下两个文件时：&lt;br&gt;\nA.c&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;#include &amp;lt;stdio.h&amp;gt;\nint a;\nint compute(void);\nint main()\n{\n    a = 1;\n    printf(&amp;quot;%d %d&amp;quot;, a, compute());\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;B.c&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int a;\nint compute(void)\n{\n    a = 0;\n    return a;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在编译过程中会产生重复定义的错误！因为有两个全局的 a 变量，编译器不知道应该使用哪一个，为了避免这种问题，就需要引入 &lt;code&gt;static&lt;/code&gt;。&lt;/p&gt;\n&lt;h5 id=\&#34;静态变量\&#34;&gt;静态变量&lt;/h5&gt;\n&lt;p&gt;使用 &lt;code&gt;static&lt;/code&gt; 关键字修饰的变量，&lt;code&gt;static&lt;/code&gt; 关键字对变量的作用域进行了限制，具体的限制如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）。&lt;/li&gt;\n&lt;li&gt;在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;C++&lt;/code&gt; 在类中定义：全局变量，但是只在此类中可见&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用 &lt;code&gt;static&lt;/code&gt;，另一个不使用，这样使用 &lt;code&gt;static&lt;/code&gt; 的就会使用自己的 a 变量，而没有用 &lt;code&gt;static&lt;/code&gt; 的会使用全局的 a 变量。&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;注意：&lt;code&gt;静态&lt;/code&gt;这个中文翻译有点莫名其妙，给人的感觉像是不可改变的，实际上&lt;code&gt;static&lt;/code&gt; 跟不可改变没有关系，不可改变的变量使用 &lt;code&gt;const&lt;/code&gt; 关键字修饰！！！&lt;/em&gt;&lt;/p&gt;\n&lt;h5 id=\&#34;extern\&#34;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/h5&gt;\n&lt;p&gt;&lt;code&gt;extern&lt;/code&gt; 是 C 语言的另一个关键字，用来指示变量或函数的定义在别的文件中，使用 &lt;code&gt;extern&lt;/code&gt; 可以在多个源文件中共享某个变量。&lt;/p&gt;\n&lt;h4 id=\&#34;程序在内存和硬盘上不同的存在形式\&#34;&gt;程序在内存和硬盘上不同的存在形式&lt;/h4&gt;\n&lt;p&gt;这里提到的四个区，是指程序在&lt;strong&gt;内存&lt;/strong&gt;中存在的形式，和程序在&lt;strong&gt;硬盘&lt;/strong&gt;上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考：&lt;a href=\&#34;https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats\&#34;&gt;wikipedia&lt;/a&gt;。&lt;br&gt;\n一个明显的例子区分这个差别：&lt;br&gt;\n之前提到的未定义的全局变量存储在 &lt;code&gt;.bss&lt;/code&gt; 区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储他们的值，在程序启动过程中，他们的值会被初始化成 0，存储在内存中。&lt;/p&gt;\n&lt;h3 id=\&#34;2-栈\&#34;&gt;2. 栈&lt;/h3&gt;\n&lt;p&gt;栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。&lt;br&gt;\n栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示：&lt;code&gt;stackoverflow&lt;/code&gt;。&lt;br&gt;\n栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈、出栈都有专门的指令执行，这就决定了栈的效率比较高。&lt;/p&gt;\n&lt;h3 id=\&#34;3-堆\&#34;&gt;3. 堆&lt;/h3&gt;\n&lt;p&gt;堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;free&lt;/code&gt; 时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生 &lt;code&gt;memory leak&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;堆是向高地址扩展的数据结构，是不连续的内存区域。这里由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。&lt;/p&gt;\n&lt;p&gt;对于堆而言，频繁的 &lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt; 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈而言，则不会出现这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。&lt;/p&gt;\n&lt;p&gt;堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 &lt;code&gt;alloca&lt;/code&gt; 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。&lt;/p&gt;\n&lt;p&gt;计算机底层并没有对堆的支持，堆则是 C/C++ 函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。&lt;/p&gt;\n&lt;h2 id=\&#34;part2-内存分配\&#34;&gt;Part.2 内存分配&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;虚拟地址：用户编译时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址。&lt;/li&gt;\n&lt;li&gt;逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址。&lt;/li&gt;\n&lt;li&gt;物理地址：实际物理内存中所看到的存储地址称为物理地址。&lt;/li&gt;\n&lt;li&gt;逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加以区分，通称为逻辑地址，逻辑地址的几个称为逻辑地址空间。&lt;/li&gt;\n&lt;li&gt;线性地址空间：CPU 地址总线可以访问的所有地址合称为线性地址空间。&lt;/li&gt;\n&lt;li&gt;物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间。&lt;/li&gt;\n&lt;li&gt;MMU（Memery Management Unit）内存管理单元：实现将用户程序的虚拟地址（逻辑地址）-&amp;gt; 物理地址映射的 CPU 中的硬件电路。&lt;/li&gt;\n&lt;li&gt;基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算。&lt;/li&gt;\n&lt;li&gt;偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。&lt;/p&gt;\n&lt;h2 id=\&#34;part3-虚拟内存\&#34;&gt;Part.3 虚拟内存&lt;/h2&gt;\n&lt;h3 id=\&#34;请求调页\&#34;&gt;请求调页&lt;/h3&gt;\n&lt;p&gt;也成为按需调页，即对不在内存中的“页”，当进程执行时才调入，否则有可能到程序结束时也不会调入。&lt;/p&gt;\n&lt;h3 id=\&#34;页面置换算法\&#34;&gt;页面置换算法&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;FIFO 算法&lt;br&gt;\n先入先出，即淘汰最早调入的页面。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;OPT（MIN） 算法&lt;br&gt;\n选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。&lt;br&gt;\n可惜，MIN 需要知道将来发生的事，只能在理论中存在，实际不可应用。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;LRU（Least-Recently-Used） 算法&lt;br&gt;\n用过去的历史预测将来，选最近最长时间没有使用的页淘汰（也称最近最少使用）。LRU 准确实现：计数器法，页码栈法。由于代价较高，通常不使用准确实现，而是采用近似实现，例如 &lt;code&gt;Clock&lt;/code&gt; 算法。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;内存抖动\&#34;&gt;内存抖动&lt;/h3&gt;\n&lt;p&gt;页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。&lt;br&gt;\n抖动一般是内存分配算法不好，内存太小引起或者程序的算法不佳引起的。&lt;/p&gt;\n&lt;h3 id=\&#34;belady-现象\&#34;&gt;&lt;code&gt;Belady&lt;/code&gt; 现象&lt;/h3&gt;\n&lt;p&gt;对有的页面置换算法，页错误率可能会随着分配帧数的增加而增加。&lt;br&gt;\nFIFO 会产生 &lt;code&gt;Belady&lt;/code&gt; 异常。&lt;br&gt;\n栈式算法无 &lt;code&gt;Belady&lt;/code&gt; 异常，LRU、LFU（最不经常使用）、OPT 都属于栈式算法。&lt;/p&gt;\n&lt;h2 id=\&#34;part4-磁盘调度\&#34;&gt;Part.4 磁盘调度&lt;/h2&gt;\n&lt;p&gt;磁盘访问延迟 = 队列时间 + 控制器时间 + 寻道时间 + 旋转时间 + 传输时间。&lt;br&gt;\n磁盘调度的目的是减小延迟，其中前两项可以忽略，寻道时间是主要矛盾。&lt;/p&gt;\n&lt;h3 id=\&#34;磁盘调度算法\&#34;&gt;磁盘调度算法&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;FCFS&lt;br&gt;\n先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;SSTF（Shortest-seek-time 最短寻道时间优先）&lt;br&gt;\n选择使磁头从当前位置开始移动最少的磁盘 I/O 请求，所以 SSTF 总是选择导致最小寻道时间的请求。&lt;br&gt;\n总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS 算法更好的性能，会存在饥饿现象。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;SCAN&lt;br&gt;\nSSTF + 中途不回折，每个请求都有处理机会。&lt;br&gt;\nSCAN 要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止。&lt;br&gt;\n由于磁头移动规律与电梯运行相似，SCAN 也被称为电梯算法。&lt;br&gt;\nSCAN 算法对最近扫描过的区域不公平，因此，它的访问局部性方面不如 FCFS 算法和 SSTF 算法好。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;C-SCAN&lt;br&gt;\nSCAN + 直接移到另一端，两端请求都能很快处理。&lt;br&gt;\n把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描。&lt;br&gt;\n其中 “C” 是 &lt;code&gt;Circular(环)&lt;/code&gt;的意思。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;LOOK 和 C-LOOK&lt;br&gt;\n采用 SCAN 算法和 C-SCAN 算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的 SCAN 算法和 C-SCAN 算法称为 LOOK 和 C-LOOK 调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;part5-文件系统\&#34;&gt;Part5. 文件系统&lt;/h2&gt;\n&lt;h3 id=\&#34;分区表\&#34;&gt;分区表&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;MBR：支持最大卷为 2TB（Terabytes），并且每个磁盘最多有 4 个主分区（或 3 个主分区、1 个扩展分区和无限制的逻辑驱动器）&lt;/li&gt;\n&lt;li&gt;GPT：支持最大卷为 18EB（Exabytes），并且每磁盘的分区数没有上限，只受到操作系统限制，由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64版 Windows 限制最多有 128 个分区，这也是 EFI 标准规定的分区表的最小尺寸。另外 GPT 分区磁盘有备份分区表来提高分区数据结构的完整性。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;raid-技术\&#34;&gt;RAID 技术&lt;/h3&gt;\n&lt;p&gt;独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks），旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升。&lt;/p&gt;\n&lt;p&gt;在运作中，取决于 RAID 层级不同，数据会以多种模式分散于各个硬盘，RAID 层级的命名会以 RAID 开头并带数字，例如：RAID 0、RAID 1、RAID 5、RAID 6、RAID 7、RAID 01、RAID 10、RAID 50、RAID 60。每种等级都有其理论上的优缺点，不同的等级在两个目标间获取平衡，分别是增加数据可靠性以及增加存储器（群）读写性能。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 0&lt;br&gt;\nRAID 0 是最早出现的 RAID 模式，需要两块以上的硬盘，可以提高整个磁盘的性能和吞吐量。&lt;br&gt;\nRAID 0 没有提供冗余或错误修复能力，其中一块硬盘损坏，所有的数据将遗失。&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221775.15778853893740.jpg\&#34; alt=\&#34;-w183\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 1&lt;br&gt;\nRAID 1 就是镜像，其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据，当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以 RAID 1 的数据安全性在所有 RAID 级别上来说是最好的。&lt;br&gt;\n但无论用多少磁盘做 RAID 1，仅算一个磁盘的容量，是所有 RAID 中磁盘利用率最低的。&lt;br&gt;\n实际容量：&lt;code&gt;Size = min(S1, S2, S3 ... Sn)&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221788.15778854865641.jpg\&#34; alt=\&#34;-w175\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 2&lt;br&gt;\n这是 RAID 0 的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分区为独立的比特，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些，RAID 2 至少需要三台磁盘驱动器方能运作。&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221801.15778855454481.jpg\&#34; alt=\&#34;-w348\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 3&lt;br&gt;\n采用 Bit-interleaving（数据交错存储）技术，它需要通过编码再将数据比特分割后分别存在磁盘中，而将同比特检查后单独存在一个硬盘中，但由于数据内的比特分散在不同的硬盘上，因此就算要读取一小段数据资料都可能需要所有的硬盘进行工作，所以这种规格比较适用于读取大量数据时使用。&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221815.15778855779280.jpg\&#34; alt=\&#34;-w258\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 4&lt;br&gt;\n它与 RAID 3 不同的是它在分区时是以区块为单位分别存在硬盘中，但每次的数据访问都必须从同比特检查的那个硬盘中取出对应的同比特数据进行核对，由于过于频繁的使用，所以对硬盘的损耗可能会提高。（快交织技术，Block interleaving）。&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221828.15778855992090.jpg\&#34; alt=\&#34;-w256\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RAID 2、3、4 在实际应用中很少使用&lt;/strong&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 5&lt;br&gt;\nRAID Level 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案，他使用的是 Disk Striping（硬盘分区）技术。&lt;br&gt;\nRAID 5 至少需要三块硬盘，RAID 5 不是对存储的数据进行备份，而是把数据和相对应的数据分别存储于不同的磁盘上。&lt;br&gt;\nRAID 5 允许一块硬盘损坏。&lt;br&gt;\n实际容量：&lt;code&gt;Size = (N - 1) * min(S1, S2, S3... SN)&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221842.15778856469979.jpg\&#34; alt=\&#34;-w263\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 6&lt;br&gt;\n与 RAID 5 相比，RAID 6 增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。&lt;br&gt;\nRAID 6 至少需要 4 块硬盘。&lt;br&gt;\n实际容量：&lt;code&gt;Size = (N - 2) * min(S1, S2, S3 ... SN)&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221858.15778857093463.jpg\&#34; alt=\&#34;-w304\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;RAID 10/01 (RAID 1 + 0, RAID 0 + 1)&lt;br&gt;\nRAID 10 是先镜射再分区数据，再将所有硬盘分为两组，视为是 RAID 0 的最低组合，然后将这两组各自视为 RAID 1 运作。&lt;br&gt;\nRAID 01 则是跟 RAID 10 的程序相反，是先分区再将数据镜射到两组硬盘。它将所有的硬盘分为两组，变成 RAID 1 的最低组合，而将两组硬盘各自视为 RAID 0 运作。&lt;br&gt;\n当 RAID 10 有一个硬盘受损，其余硬盘会继续运作，RAID 01 只要有一个硬盘受损，同组 RAID 0 的所有硬盘都会停止运作，只剩下其他组的硬盘运作，可靠性较低。&lt;br&gt;\n如果以 6 个硬盘建 RAID 01，镜射再用三个建 RAID 0，那么坏一个硬盘便会有三个硬盘脱机，因此，RAID 10 远比 RAID 01 常用，零售主板绝大多数支持 RAID 0/1/5/10, 但不支持 RAID 01.&lt;br&gt;\nRAID 10 至少需要 4 块硬盘，且硬盘数量必须为偶数。&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221874.15778861611396.jpg\&#34; alt=\&#34;-w271\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;常见的文件系统\&#34;&gt;常见的文件系统&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Windows：FAT，FAT16，FAT32，NTFS&lt;/li&gt;\n&lt;li&gt;Linux：ext2/3/4，btrfs，ZFS&lt;/li&gt;\n&lt;li&gt;Mac OS X：HFS+&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;更多干货文章\&#34;&gt;更多干货文章&lt;/h3&gt;\n&lt;h5 id=\&#34;博客wwwqiuxueweicom\&#34;&gt;博客：&lt;a href=\&#34;http://www.qiuxuewei.com\&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;微信公众号开发者成长之路\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;\&#34;&gt;&lt;img src=\&#34;http://blog.image.jkxuewei.com/sou_wechat.png\&#34; alt=\&#34;公众号二维码\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;\n&lt;hr&gt;\n&#34;,&#34;fileName&#34;:&#34;nei-cun-guan-li-ci-pan-he-wen-jian-shi-yi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;内存管理-磁盘和文件拾遗\&#34;&gt;内存管理、磁盘和文件拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-内存管理\&#34;&gt;Part1. 内存管理&lt;/h2&gt;\n&lt;p&gt;一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。&lt;br&gt;\n可读写部分（变量）大致可分为下面几个部分：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：初始化了的全局变量和静态变量&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：即 &lt;code&gt;Block Started by Symbol&lt;/code&gt;，未初始化的全局变量和静态变量&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;heap&lt;/code&gt;：堆，使用 &lt;code&gt;malloc&lt;/code&gt;、&lt;code&gt;realloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;stack&lt;/code&gt;：栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;内存管理、磁盘和文件拾遗&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;计算机&#34;,&#34;slug&#34;:&#34;od9BBCWB7&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/od9BBCWB7/&#34;}],&#34;date&#34;:&#34;2020-01-01 23:28:42&#34;,&#34;dateFormat&#34;:&#34;2020-01-01&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2020.01.01.15778871221740.mr-cup-fabien-barral-o6GEPQXnqMY-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/nei-cun-guan-li-ci-pan-he-wen-jian-shi-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;16 min read&#34;,&#34;time&#34;:940000,&#34;words&#34;:4381,&#34;minutes&#34;:16},&#34;description&#34;:&#34;内存管理、磁盘和文件拾遗\nPart1. 内存管理\n一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。\n可读写部分（变量）大致可分为下面几...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E6%8B%BE%E9%81%97\&#34;&gt;内存管理、磁盘和文件拾遗&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#part1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\&#34;&gt;Part1. 内存管理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-data-%E5%92%8C-bss-%E5%8C%BA\&#34;&gt;1. &lt;code&gt;.data&lt;/code&gt; 和 &lt;code&gt;.bss&lt;/code&gt; 区&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\&#34;&gt;静态变量和全局变量&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\&#34;&gt;全局变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F\&#34;&gt;静态变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#extern\&#34;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E5%92%8C%E7%A1%AC%E7%9B%98%E4%B8%8A%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F\&#34;&gt;程序在内存和硬盘上不同的存在形式&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E6%A0%88\&#34;&gt;2. 栈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%A0%86\&#34;&gt;3. 堆&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\&#34;&gt;Part.2 内存分配&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\&#34;&gt;Part.3 虚拟内存&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5\&#34;&gt;请求调页&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\&#34;&gt;页面置换算法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8\&#34;&gt;内存抖动&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#belady-%E7%8E%B0%E8%B1%A1\&#34;&gt;&lt;code&gt;Belady&lt;/code&gt; 现象&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part4-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6\&#34;&gt;Part.4 磁盘调度&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\&#34;&gt;磁盘调度算法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\&#34;&gt;Part5. 文件系统&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%8C%BA%E8%A1%A8\&#34;&gt;分区表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#raid-%E6%8A%80%E6%9C%AF\&#34;&gt;RAID 技术&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\&#34;&gt;常见的文件系统&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E5%A4%9A%E5%B9%B2%E8%B4%A7%E6%96%87%E7%AB%A0\&#34;&gt;更多干货文章&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E5%AE%A2wwwqiuxueweicom\&#34;&gt;博客：www.qiuxuewei.com&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%80%85%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!公众号二维码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;并发技术-进程-线程和锁拾遗\&#34;&gt;并发技术、进程、线程和锁拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-多任务\&#34;&gt;Part1. 多任务&lt;/h2&gt;\n&lt;p&gt;计算机发展起初，CPU 资源十分昂贵，如果让 CPU 只能运行一个程序那么当 CPU 空闲下来（例如等待 I/O 时），CPU 资源就会被浪费，为了使 CPU 资源得到更好的利用，先驱编写了一个监控程序，如果发现某个程序暂时无需使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动起来，以充分利用 CPU资源。这种方法称为 - &lt;strong&gt;多道程序（Multiprogramming）&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;对于多道程序，最大的弊端是各程序之间不区分轻重缓急，对于用户交互式的程序来说，对 CPU 计算时间的需求并不多，但是对于响应速度却有比较高的要求。而对于计算类程序来说则相反，对响应速度要求低，但需要长时间的 CPU 计算。想象一个场景：我在同时在浏览网页和听音乐，我们希望浏览器能够快速响应，同时也希望音乐不停，这时候&lt;strong&gt;多道程序&lt;/strong&gt;就没法达到我们的要求了。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;于是人们改进了&lt;strong&gt;多道程序&lt;/strong&gt;，使得每个程序运行一段时间之后，都主动让出 CPU 资源，这样每个程序在一段时间内都有机会运行一小段时间。这样像浏览器这样的交互式程序就能够快速地被处理，同时计算类程序也不会受到很大影响。这种程序协作方式被称为 &lt;strong&gt;分时系统（Time-Sharing System）&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;在分时系统的帮助下，我们可以边用浏览器边听歌了。&lt;strong&gt;但是&lt;/strong&gt;如果某个程序出现了错误，导致了死循环，不仅仅是这个程序会出错，整个系统都会死机，为了避免这种情况，一个更为先进的操作系统模式被发明处理，也就是我们现在熟悉的&lt;strong&gt;多任务系统（Multi-tasking System）&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;操作系统从最底层接管了所有硬件资源。所有的应用程序在操作系统上以 &lt;strong&gt;进程（Process）&lt;/strong&gt; 的方式运行，每个进程都有自己独立的地址空间，相互隔离。CPU 由操作系统统一统一进行分配。每个进程都有机会得到 CPU，同时在操作系统控制下，如果一个进程运行超过了一定时间，就会被暂停掉，失去 CPU 资源。这样就避免了一个程序的错误导致整个系统死机。如果操作系统分配给各个进程的运行时间都很短，CPU 可以在多个进程间快速切断，就像很多进程都同时在运行的样子。几乎所有现代操作系统都是采用这样的方式支持多任务。&lt;/p&gt;\n&lt;h2 id=\&#34;part2-进程\&#34;&gt;Part2. 进程&lt;/h2&gt;\n&lt;p&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。它可以申请和拥有系统资源，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理递存器的内容来表示。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;进程是一个实体，每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。&lt;/li&gt;\n&lt;li&gt;进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;1-进程的基本状态\&#34;&gt;1. 进程的基本状态&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;等待态：等待某个事件的完成；&lt;/li&gt;\n&lt;li&gt;就绪态：等待系统分配处理器以便运行；&lt;/li&gt;\n&lt;li&gt;运行态：占有处理器正在运行；&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;几种状态的切换：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;运行态 -&amp;gt; 等待态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。&lt;/li&gt;\n&lt;li&gt;等待态 -&amp;gt; 就绪态：则是等待的条件已满足，只需分配到处理器后就能运行。&lt;/li&gt;\n&lt;li&gt;运行态 -&amp;gt; 就绪态：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时就变成就绪态。例如：时间片用完，或有更高优先级的进程来抢占处理器等&lt;/li&gt;\n&lt;li&gt;就绪态 -&amp;gt; 运行态：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;2-进程调度\&#34;&gt;2. 进程调度&lt;/h3&gt;\n&lt;h4 id=\&#34;调度种类\&#34;&gt;调度种类&lt;/h4&gt;\n&lt;p&gt;高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;高级调度（High-Level Scheduling）:又称为作业调度，它决定把后备作业调入内存运行；&lt;/li&gt;\n&lt;li&gt;中级调度（Intermediate-Level Scheduling）:又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。&lt;/li&gt;\n&lt;li&gt;低级调度（Low-Level Scheduling）:又称为进程调度，它决定把就绪队列的某进程获得 CPU。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;非抢占式调度与抢占式调度\&#34;&gt;非抢占式调度与抢占式调度&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;非抢占式&lt;br&gt;\n分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或者发生进程调度某事件而阻塞时，才把处理机分配给另一个进程。&lt;/li&gt;\n&lt;li&gt;抢占式&lt;br&gt;\n操作系统将正在运行的进程强行暂停，由调度程序将 CPU 分配给其他就绪进程的调度方式。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;调度策略的设计\&#34;&gt;调度策略的设计&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;响应时间：从用户输入到产生反应的时间&lt;/li&gt;\n&lt;li&gt;周转时间：从任务开始到任务结束的时间&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;CPU 任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用 CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。&lt;/p&gt;\n&lt;h4 id=\&#34;调度算法\&#34;&gt;调度算法&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;FIFO 或 First Come，First Served（FCFS）&lt;br&gt;\n调度的顺序就是任务到达就绪队列的顺序。&lt;br&gt;\n公平、简单（FIFO 队列）、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Shortest Job First（SJF）&lt;br&gt;\n最短的作业（CPU 区间长度最小）优先调度&lt;br&gt;\n可以证明，SJF 可以保证最小的平均等待时间&lt;br&gt;\nShortest Job First （SRJF）： SJF 的可抢占版本，比 SJF 更有优势&lt;br&gt;\nSJF、SRJF 如何知道下一 CPU 区间大小？根据历史进行预测：指数平均法。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;优先权调度&lt;br&gt;\n每个任务关联一个优先权、调度优先权最高的任务。&lt;br&gt;\n注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。&lt;br&gt;\nFCFS 是 RR 的特例，SJF 是优先权调度的特例，这些调度算法都不适合于交互式系统。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Round-Robin（RR）&lt;br&gt;\n设置一个时间片，按时间片来轮转调度（“轮叫”算法）&lt;br&gt;\n优点：定时有响应，等待时间较短；缺点：上下文切换次数较多；&lt;br&gt;\n如何确定时间片？时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为 FCFS。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;多级队列调度&lt;br&gt;\n按照一定的规则建立多个进程队列&lt;br&gt;\n不同的队列有固定的优先级（高优先级有抢占权）&lt;br&gt;\n不同的队列可以给不同的时间片和采用不同的调度方法&lt;br&gt;\n存在问题 1：没法区分 I/O bound 和 CPU bound；&lt;br&gt;\n存在问题 2：也存在一定程度的“饥饿”现象&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;多级反馈队列&lt;br&gt;\n在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。&lt;br&gt;\n可以根据“享用”CPU 时间多少来移动队列，阻止“饥饿”。&lt;br&gt;\n最通用的调度算法，多数 OS 都使用该方法或其变形，如 UNIX、Windows 等。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;3-进程同步\&#34;&gt;3. 进程同步&lt;/h3&gt;\n&lt;h4 id=\&#34;临界资源与临界区\&#34;&gt;临界资源与临界区&lt;/h4&gt;\n&lt;p&gt;在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。&lt;br&gt;\n典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等（如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题）。&lt;br&gt;\n对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被称为临界区。&lt;/p&gt;\n&lt;p&gt;解决临界区问题可能的方法：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;一般软件方法&lt;/li&gt;\n&lt;li&gt;关中断方法&lt;/li&gt;\n&lt;li&gt;硬件原子指令方法&lt;/li&gt;\n&lt;li&gt;信号量方法&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;信号量\&#34;&gt;信号量&lt;/h4&gt;\n&lt;p&gt;信号量是一个确定的二元组（s，q），其中 s 是一个具有非负初值的整型变量，q 是一个初始状态为空的队列，整型变量 s 表示系统中某类资源的数目：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;当 s ≥ 0 时，表示系统中当前可用资源的数目&lt;/li&gt;\n&lt;li&gt;当 s &amp;lt; 0 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;除信号量的初值外，信号量的值仅能由 P 操作和 V 操作更改，操作系统利用它的状态对进程和资源进行管理。&lt;/p&gt;\n&lt;p&gt;P 操作：P 操作记为 P(s)，其中 s 为一信号量，它执行时主要完成以下动作：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 可理解为占用一个资源，若原来就没有则记账“欠”1 个\ns.value = s.value - 1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;若 &lt;code&gt;s.value ≥ 0&lt;/code&gt;，则进程继续执行，否则（即&lt;code&gt;s.value &amp;lt; 0&lt;/code&gt;），则进程被阻塞，并将该进程插入到信号量 s 的等待队列 s.queue 中。&lt;br&gt;\n&lt;em&gt;实际上，P 操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;V 操作：V 操作记为 V(s)，其中 s 为一信号量，它执行时，主要完成以下动作：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 可理解为归还一个资源，若原来就没有则意义是用此资源还 1 个欠账\ns.value = s.value + 1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;若 &lt;code&gt;s.value &amp;gt; 0&lt;/code&gt;，则进程继续执行，否则（即 &lt;code&gt;s.value ≤ 0&lt;/code&gt;），则从信号量 s 的等待队列 s.queue 中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行。&lt;br&gt;\n&lt;em&gt;实际上，V 操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;信号量方法实现：生产者 - 消费者互斥与同步控制&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;semaphore fullBuffers = 0;//仓库中已填满的货架个数\nsemaphore emptyBuffers = BUFFER_SIZE;//仓库货架空闲个数\nsemaphore mutex = 1;//生产 - 消费互斥信号\n\nProducer() \n{ \n    while(True)\n    {  \n       /*生产产品item*/\n       emptyBuffers.P(); \n       mutex.P(); \n       /*item存入仓库buffer*/\n       mutex.V();\n       fullBuffers.V();\n    }\n}\n \nConsumer() \n{\n    while(True)\n    {\n        fullBuffers.P(); \n        mutex.P();\t\n        /*从仓库buffer中取产品item*/\n        mutex.V();\n        emptyBuffers.V();\n        /*消费产品item*/\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;死锁\&#34;&gt;死锁&lt;/h4&gt;\n&lt;p&gt;死锁：多个进程因循环等待而造成的无法执行的现象&lt;br&gt;\n死锁会造成进程无法执行，同时会造成系统资源的极大浪费（资源无法释放）。&lt;br&gt;\n死锁产生的 4 个必要条件：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;互斥使用（Mutual exclusion）\n&lt;ul&gt;\n&lt;li&gt;指进程对所有分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;不可抢占（No preemption）\n&lt;ul&gt;\n&lt;li&gt;指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;请求和保持（Hold and wait）\n&lt;ul&gt;\n&lt;li&gt;指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得其他资源保持不放。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;循环等待（Circular wait）\n&lt;ul&gt;\n&lt;li&gt;指在发生死锁时，必然存在一个进程-资源的环形链，即进程集合{P0, P1, P2, P3, P4, ..., Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，...，Pn 正在等待已被 P0 占用的资源。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;死锁的避免：银行家算法&lt;br&gt;\n思想：判断此次请求是否造成死锁，若会造成死锁，则拒绝该请求。&lt;/p&gt;\n&lt;h3 id=\&#34;4-进程间通信\&#34;&gt;4. 进程间通信&lt;/h3&gt;\n&lt;p&gt;本地进程间通信的方式有很多，可以总结为下面四类：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;消息传递（管道、FIFO、消息队列）&lt;/li&gt;\n&lt;li&gt;同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）&lt;/li&gt;\n&lt;li&gt;共享内存（匿名的和具名的）&lt;/li&gt;\n&lt;li&gt;远程过程调用（Solaris门 和 Sun RPC）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;part3-线程\&#34;&gt;Part3. 线程&lt;/h2&gt;\n&lt;p&gt;多线程解决了前面提到的多任务问题。然而很多时候不同的程序需要共享同样的资源（文件，信号量等），如果全都使用进程的话会导致切换的成本很高，造成 CPU 资源的浪费。于是出现了线程的概念。&lt;br&gt;\n线程，有时被称为轻量级进程（Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程 ID，当前指令指针（PC），寄存器集合和堆栈组成。&lt;br&gt;\n线程具有以下属性：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;轻型实体&lt;br&gt;\n线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括：程序、数据和 TCB（Thread Control Block）。线程是动态概念，它的动态特性由线程控制块 TCB 描述。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;独立调度和分派的基本单位&lt;br&gt;\n在多线程 OS 中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本的单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可并发执行&lt;br&gt;\n在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;共享进程资源&lt;br&gt;\n在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问改地址空间的每一个虚拟地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。&lt;br&gt;\n线程共享的环境包括：进程代码段、进程的公有数据（利用这些共享的数据，线程很容易的实现相互之前的通讯）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户 ID 与进程组 ID。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;part4-锁\&#34;&gt;Part4. 锁&lt;/h2&gt;\n&lt;p&gt;锁要解决的是线程之间争夺资源的问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;资源是否是独占（独占锁 - 共享锁）&lt;/li&gt;\n&lt;li&gt;抢占不到资源怎么办（互斥锁 - 自旋锁）&lt;/li&gt;\n&lt;li&gt;自己能不能重复抢（重入锁 - 不可重入锁）&lt;/li&gt;\n&lt;li&gt;竞争读的情况比较多，读可不可以不加锁（读写锁）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;上面几个角度并非相互独立，在实际场景中需要将他们集合起来才能构造出一个合适的锁。&lt;/p&gt;\n&lt;h3 id=\&#34;独占锁-共享锁\&#34;&gt;独占锁 - 共享锁&lt;/h3&gt;\n&lt;p&gt;当一个共享资源只有一份的时候，通常我们使用独占锁，常见的即各个语言中的 &lt;code&gt;Mutex&lt;/code&gt;。当共享资源有多份时，可以使用信号量（Semaphere）。&lt;/p&gt;\n&lt;h3 id=\&#34;互斥锁-自旋锁\&#34;&gt;互斥锁 - 自旋锁&lt;/h3&gt;\n&lt;p&gt;对于互斥锁来说，如果一个线程已经锁定了一个互斥锁，第二个线程又试图去获取这个互斥锁，则第二个线程将会被挂起（即休眠、不占用 CPU 资源）。&lt;/p&gt;\n&lt;p&gt;在计算机系统中，频繁的挂起和切换线程，也是有成本的。自旋锁就是解决这个问题的。&lt;/p&gt;\n&lt;p&gt;自旋锁：指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。&lt;/p&gt;\n&lt;p&gt;容易看出，当资源等待的时间较长，用互斥锁让线程休眠，会消耗更少的资源，当资源等待的时间较短时，使用自旋锁将减少线程的切换，获得更高的性能。&lt;/p&gt;\n&lt;p&gt;Java 中的 &lt;code&gt;synchornized&lt;/code&gt; 和 .NET 中的 &lt;code&gt;lock&lt;/code&gt;（&lt;code&gt;Monitor&lt;/code&gt;）的实现，是结合了两种锁的特点。简单说，它们在发现资源被抢占之后，会先试着自旋等待一段时间，如果等待时间太长，则会进入挂起状态。通过这样的实现，可以较大程度上挖掘出锁的性能。&lt;/p&gt;\n&lt;h3 id=\&#34;重入锁-不可重入锁\&#34;&gt;重入锁 - 不可重入锁&lt;/h3&gt;\n&lt;p&gt;可重入锁（ReetrantLock），也叫作递归锁，指的是同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。&lt;br&gt;\n换而言之：同一线程再次进入同步代码时，可以使用自己已获取到的锁。&lt;/p&gt;\n&lt;p&gt;使用可重入锁时，在同一线程中多次获取锁，不会导致死锁。使用不可重入锁，则会导致死锁发生。&lt;/p&gt;\n&lt;p&gt;Java 中的 &lt;code&gt;synchornized&lt;/code&gt; 和 .NET 中的 &lt;code&gt;lock&lt;/code&gt;（&lt;code&gt;Monitor&lt;/code&gt;） 都是可重入的。&lt;/p&gt;\n&lt;h3 id=\&#34;读写锁\&#34;&gt;读写锁&lt;/h3&gt;\n&lt;p&gt;有些情况下，对于共享资源读竞争的情况远远多于写竞争，这种情况下，对读操作每次都进行加锁，是得不偿失的。读写锁就是为了解决这个问题。&lt;/p&gt;\n&lt;p&gt;读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有读线程和其他的写线程都会被阻塞。简单可以总结为，读读不互斥，读写互斥，谢谢互斥。&lt;/p&gt;\n&lt;p&gt;对读写锁来说，有一个升级和降级的概念，即当前获得了读锁，想把当前的锁变成写锁，成为升级，反之称为降级。锁的升降级本身也是为了提升性能，通过改变当前锁的性质，避免重复获取锁。&lt;/p&gt;\n&lt;h2 id=\&#34;part5-协程\&#34;&gt;Part.5 协程&lt;/h2&gt;\n&lt;p&gt;协程，又称为微线程，纤程。英文名： Coroutine&lt;br&gt;\n协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多 CPU 的能力。&lt;/p&gt;\n&lt;h2 id=\&#34;part6-io多路复用\&#34;&gt;Part.6 IO多路复用&lt;/h2&gt;\n&lt;h3 id=\&#34;基本概念\&#34;&gt;基本概念&lt;/h3&gt;\n&lt;p&gt;IO 多路复用是指内核一旦发现进程指定的一个或者多个 IO 条件准备读取，他就通知该进程。IO 多路复用适用于如下场景：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用 I/O 复用。&lt;/li&gt;\n&lt;li&gt;当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。&lt;/li&gt;\n&lt;li&gt;如果一个 TCP 服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到 I/O 复用。&lt;/li&gt;\n&lt;li&gt;如果一个度武器既要处理 TCP，又要处理 UDP，一般要使用 I/O 复用。&lt;/li&gt;\n&lt;li&gt;如果一个服务器要处理多个服务或多个协议，一般要使用 I/O 复用。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建 进程/线程，也不必维护这些 进程/线程，从而大大减小了系统的开销。&lt;/p&gt;\n&lt;h3 id=\&#34;常见的-io-复用实现\&#34;&gt;常见的 IO 复用实现&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;select （Linux/Windows/BSD）&lt;/li&gt;\n&lt;li&gt;epoll （Linux）&lt;/li&gt;\n&lt;li&gt;kqueue （BSD/Mac OS）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;更多干货文章\&#34;&gt;更多干货文章&lt;/h3&gt;\n&lt;h5 id=\&#34;博客wwwqiuxueweicom\&#34;&gt;博客：&lt;a href=\&#34;http://www.qiuxuewei.com\&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;微信公众号开发者成长之路\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;\&#34;&gt;&lt;img src=\&#34;http://blog.image.jkxuewei.com/sou_wechat.png\&#34; alt=\&#34;公众号二维码\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;\n&lt;hr&gt;\n&#34;,&#34;fileName&#34;:&#34;bing-fa-ji-zhu-jin-cheng-xian-cheng-he-suo-shi-yi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;并发技术-进程-线程和锁拾遗\&#34;&gt;并发技术、进程、线程和锁拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-多任务\&#34;&gt;Part1. 多任务&lt;/h2&gt;\n&lt;p&gt;计算机发展起初，CPU 资源十分昂贵，如果让 CPU 只能运行一个程序那么当 CPU 空闲下来（例如等待 I/O 时），CPU 资源就会被浪费，为了使 CPU 资源得到更好的利用，先驱编写了一个监控程序，如果发现某个程序暂时无需使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动起来，以充分利用 CPU资源。这种方法称为 - &lt;strong&gt;多道程序（Multiprogramming）&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;对于多道程序，最大的弊端是各程序之间不区分轻重缓急，对于用户交互式的程序来说，对 CPU 计算时间的需求并不多，但是对于响应速度却有比较高的要求。而对于计算类程序来说则相反，对响应速度要求低，但需要长时间的 CPU 计算。想象一个场景：我在同时在浏览网页和听音乐，我们希望浏览器能够快速响应，同时也希望音乐不停，这时候&lt;strong&gt;多道程序&lt;/strong&gt;就没法达到我们的要求了。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;并发技术、进程、线程和锁拾遗&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;计算机&#34;,&#34;slug&#34;:&#34;od9BBCWB7&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/od9BBCWB7/&#34;}],&#34;date&#34;:&#34;2019-12-31 22:21:29&#34;,&#34;dateFormat&#34;:&#34;2019-12-31&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2019.12.31.15777952677146.joakim-honkasalo-tvVcBCFVHY8-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/bing-fa-ji-zhu-jin-cheng-xian-cheng-he-suo-shi-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;19 min read&#34;,&#34;time&#34;:1096000,&#34;words&#34;:5239,&#34;minutes&#34;:19},&#34;description&#34;:&#34;并发技术、进程、线程和锁拾遗\nPart1. 多任务\n计算机发展起初，CPU 资源十分昂贵，如果让 CPU 只能运行一个程序那么当 CPU 空闲下来（例如等待 I/O 时），CPU 资源就会被浪费，为了使 CPU 资源得到更好的利用，先驱编写...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E6%8B%BE%E9%81%97\&#34;&gt;并发技术、进程、线程和锁拾遗&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#part1-%E5%A4%9A%E4%BB%BB%E5%8A%A1\&#34;&gt;Part1. 多任务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part2-%E8%BF%9B%E7%A8%8B\&#34;&gt;Part2. 进程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81\&#34;&gt;1. 进程的基本状态&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\&#34;&gt;2. 进程调度&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E5%BA%A6%E7%A7%8D%E7%B1%BB\&#34;&gt;调度种类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6\&#34;&gt;非抢占式调度与抢占式调度&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E8%AE%A1\&#34;&gt;调度策略的设计&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\&#34;&gt;调度算法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5\&#34;&gt;3. 进程同步&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA\&#34;&gt;临界资源与临界区&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%A1%E5%8F%B7%E9%87%8F\&#34;&gt;信号量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%BB%E9%94%81\&#34;&gt;死锁&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\&#34;&gt;4. 进程间通信&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part3-%E7%BA%BF%E7%A8%8B\&#34;&gt;Part3. 线程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part4-%E9%94%81\&#34;&gt;Part4. 锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8B%AC%E5%8D%A0%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81\&#34;&gt;独占锁 - 共享锁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%92%E6%96%A5%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81\&#34;&gt;互斥锁 - 自旋锁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81\&#34;&gt;重入锁 - 不可重入锁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%BB%E5%86%99%E9%94%81\&#34;&gt;读写锁&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part5-%E5%8D%8F%E7%A8%8B\&#34;&gt;Part.5 协程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part6-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\&#34;&gt;Part.6 IO多路复用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\&#34;&gt;基本概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E8%A7%81%E7%9A%84-io-%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0\&#34;&gt;常见的 IO 复用实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E5%A4%9A%E5%B9%B2%E8%B4%A7%E6%96%87%E7%AB%A0\&#34;&gt;更多干货文章&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E5%AE%A2wwwqiuxueweicom\&#34;&gt;博客：www.qiuxuewei.com&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%80%85%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!公众号二维码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;如何成为有效学习的高手\&#34;&gt;《如何成为有效学习的高手》&lt;/h1&gt;\n&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;p&gt;高效学习的定义是找到适合自己的学习方法,在最短的时间里能够集中注意力,以解决生活或工作中的一个任务为目的着手学习. 需要勤加练习,必要的时候要向名师求助!&lt;/p&gt;\n&lt;p&gt;这其中有七个关键点:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;适合自己&lt;/li&gt;\n&lt;li&gt;学习方法&lt;/li&gt;\n&lt;li&gt;最短时间&lt;/li&gt;\n&lt;li&gt;注意力&lt;/li&gt;\n&lt;li&gt;解决任务&lt;/li&gt;\n&lt;li&gt;设定目标&lt;/li&gt;\n&lt;li&gt;名师&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;1找到适合自己的学习方法\&#34;&gt;1.找到适合自己的学习方法&lt;/h2&gt;\n&lt;h4 id=\&#34;自然主义和结构主义\&#34;&gt;自然主义和结构主义&lt;/h4&gt;\n&lt;p&gt;这是两种针对不同知识门类需采用的两种不同的学习方法. 学语言, 学乐器演奏. 如果你采用从最基础的语法,字母,音符开始学. 虽然能学成, 但是这不是最合适的学习方法. 咱所说的话从来没有从语法开始学起, 照样能说的好. 何况是世界上最难学习的语言之一的中文. 如果从基础开始学, 相对低效. 并且是用需要用自然主义的学习方法用了结构主义去学. 这样只会事倍功半.&lt;/p&gt;\n&lt;p&gt;自然主义的学习方法简单来说是模仿,结构主义为的是创新&lt;/p&gt;\n&lt;p&gt;像语言,乐器,书法这类知识适合用自然主义学习. 像医药,艺术,经济学,程序这类需要创新的要用结构主义去学.&lt;/p&gt;\n&lt;p&gt;选对学习方法能够做到有效的学习, 如何使其升级为高效这就需要一些学习方法. 最简单是把目标拆碎. 针对每一个细节反复练习, 不要一开始就顾全大局. 成年人很难把一大段时间空闲出来全神贯注专注一个技能的学习, 碎片化学习变得尤为重要. 在碎片化的时间里做到高效也有技巧, 就是带着问题和困惑去执行碎片化学习, 并且多使用搜索这个功能. 要注意的一点有一种假的碎片化学习叫做收藏, 这里看到一篇好文章想到的不是马上阅读而是收藏到收藏夹里! 等以后有时间再看, 这里要告诉你, 很难, 非常难! 即便你以后有时间了, 也不会来学这篇文章. 所以收藏夹我建议只有一天或者两天的有效期, 不要超过两天! 否则收藏夹没有存在的意义! 在地铁上看到一篇很棒的文章首选立即去读它,读完, 实在看不完可以收藏起来晚上回家继续看完. 需要敲代码的地方如果不方便马上敲出来可以晚上回去敲. 这样的话你偶遇的这篇文章会彻底成为你的知识积累, 而不是收藏夹里那些无用的东西.&lt;/p&gt;\n&lt;h2 id=\&#34;2不谈兴趣-用任务驱动学习\&#34;&gt;2.不谈兴趣, 用任务驱动学习&lt;/h2&gt;\n&lt;p&gt;都说兴趣是最好的老师, 但对于一个陌生的领域,何谈兴趣. 兴趣可以是最好的老师, 这是你了解他并发现他的美之后产生的兴趣.  成年人是不需要兴趣驱动学习的, 应该用任务来驱动. 工作中的职业强迫, 生活中的任务驱动, 以教为学 都是兴趣.&lt;/p&gt;\n&lt;p&gt;在学习, 工作中经常给自己布置任务, 每一个任务作为学习的一个小阶段, 任务驱动自己这样效率会大大提升. 除此之外还可以以教为学, 通过想把这个知识传授给别人为目标, 去掌握此项技能, 自己掌握了才能教育别人, 写博客就是以教为学的典型示例. 每一个人都能成为一个很好的老师!&lt;/p&gt;\n&lt;h2 id=\&#34;3拖延症的-确诊和治疗\&#34;&gt;3.拖延症的 &amp;quot;确诊和治疗&amp;quot;&lt;/h2&gt;\n&lt;p&gt;任何人都有拖延症, 只不过有选择性的拖延, 没人会在地震的时候拖延着逃生. 所以拖延是所制定的目标不够紧迫,不够重视. 所以把所定的目标足够重视, 在心底把他作为人生不可不做的一件事. 拖延自然会消失. 将任务 &amp;quot;严峻化&amp;quot; !&lt;br&gt;\n成年人在读书的时候也要讲究方法, 不能跟学生时代一样每本书都精读, 精读的意思就一字一句读到尾. 要学会速读, 拿起一本书先看目录, 如果对自己职业技能和道德品质没有多大作用果断扔掉.&lt;/p&gt;\n&lt;h2 id=\&#34;4在衣食住行上训练专注力\&#34;&gt;4.在衣食住行上训练专注力&lt;/h2&gt;\n&lt;p&gt;拖延症的本质是做事缺乏专注力.&lt;br&gt;\n一段时间内, 专注做一件事. 平常的生活并不能训练人的专注力, 但是在生活中营造仪式感, 就会提升注意力. 比如: 购买昂贵的学习工具. 如果你学习某一项技能时需要工具时, 购买最贵的. 这样好的开始会是成功的一半. 学习工具昂贵你自然不会耽搁, 试想练书法有人用旧报纸, 有人用20块钱一张的宣纸, 自然后者在每写一笔都会郑重其事, 技能自然能得到突飞猛进的提升. 再者是一个人好好吃饭, 吃饭的时候点点好的, 或是做点好的, 不要吃自助. 自助不会让你吃好, 只能让你吃撑! 使用射灯, 把灯光会聚集到一处, 其他的地方时黑的, 这很好的营造一种仪式感. 进入高质量的睡眠.&lt;/p&gt;\n&lt;h2 id=\&#34;5直奔大师-不必从基础开始\&#34;&gt;5.直奔大师, 不必从基础开始&lt;/h2&gt;\n&lt;p&gt;学英语很多人都想着是从基础学起, 比如从新概念四册厚厚的教材开始学起, 很多人在看到第一册就会坚持不下去, 甚至在第一册的前几章就坚持不下去, 这很正常,因为没有一个学习英语的明确的目标, 自然没有强大的动力. 有了明确的目标之后, 也不应该是从基础学起, 而是要直奔大师! 不必从基础开始.&lt;br&gt;\n要去哪里, 就从哪里开始. 比如学吉他, 如果从一个个音符学起相信很多人会觉得枯燥无味. 如果一开始学着弹一首自己喜欢的完整的吉他曲, 进而再对基础乐理知识查漏补缺, 这样学习效果会事半功倍! 怯场是最糟糕的自觉吗一个人单子变得比之前大一点, 能走的路可能就会长一点.&lt;/p&gt;\n&lt;h2 id=\&#34;6给自己制造反馈\&#34;&gt;6.给自己制造反馈&lt;/h2&gt;\n&lt;p&gt;学习要真正有效, 一定更要有反馈. 学完一项技能一定要输出, 比如掌握了一项编程知识, 要把它写成博客记录下来, 学唱了一首歌要把它录下来, 这样在输出的时候会发现掌握的情况, 也会对自己更自信, 看到一本书或是一篇文章之后, 一定要写个摘要或是笔记, 再或是发篇微博, 总之一定要有一个反馈,没人看不重要, 这是记录给自己看的! 写摘要不要脱稿写, 因为那是考研你的记忆力, 要照着文本用自己的语言进行总结输出, 另外两种反馈一是给自己录音, 给自己录像. 针对不一样的情景给自己制造不一样的反馈.&lt;/p&gt;\n&lt;h2 id=\&#34;7怎样突破学习瓶颈\&#34;&gt;7.怎样突破学习瓶颈&lt;/h2&gt;\n&lt;p&gt;首先要有一个认知, 瓶颈不是极限. 学习过程中遇到瓶颈需要调整的不是方法, 而是心态. 遇到瓶颈很可能是对自己不自信造成的. 所以解决心态问题. 把注意力放在每一件小事上, 而不要过多去想最后的结果. 这样会不知不觉的达到你想要的高度. 扩大涉猎范围, 想要突破它需要不断积累, 比如吉他弹奏遇到瓶颈之后多听一些顶级大师的吉他演奏, 会从中找到突破的. 更加专注,请教名师.&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;更多干货文章\&#34;&gt;更多干货文章&lt;/h3&gt;\n&lt;h5 id=\&#34;博客wwwqiuxueweicom\&#34;&gt;博客：&lt;a href=\&#34;http://www.qiuxuewei.com\&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;微信公众号开发者成长之路\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;\&#34;&gt;&lt;img src=\&#34;http://blog.image.jkxuewei.com/sou_wechat.png\&#34; alt=\&#34;公众号二维码\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;\n&lt;hr&gt;\n&#34;,&#34;fileName&#34;:&#34;ru-he-cheng-wei-you-xiao-xue-xi-de-gao-shou&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;如何成为有效学习的高手\&#34;&gt;《如何成为有效学习的高手》&lt;/h1&gt;\n&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;p&gt;高效学习的定义是找到适合自己的学习方法,在最短的时间里能够集中注意力,以解决生活或工作中的一个任务为目的着手学习. 需要勤加练习,必要的时候要向名师求助!&lt;/p&gt;\n&lt;p&gt;这其中有七个关键点:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;适合自己&lt;/li&gt;\n&lt;li&gt;学习方法&lt;/li&gt;\n&lt;li&gt;最短时间&lt;/li&gt;\n&lt;li&gt;注意力&lt;/li&gt;\n&lt;li&gt;解决任务&lt;/li&gt;\n&lt;li&gt;设定目标&lt;/li&gt;\n&lt;li&gt;名师&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;如何成为有效学习的高手&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;读书笔记&#34;,&#34;slug&#34;:&#34;ueK-dj8_Y&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/ueK-dj8_Y/&#34;},{&#34;name&#34;:&#34;心得&#34;,&#34;slug&#34;:&#34;r2Mb5sADpD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/r2Mb5sADpD/&#34;}],&#34;date&#34;:&#34;2019-12-30 00:05:21&#34;,&#34;dateFormat&#34;:&#34;2019-12-30&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2019.12.29.15776349584222.1532936218602482.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/ru-he-cheng-wei-you-xiao-xue-xi-de-gao-shou/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:421000,&#34;words&#34;:2096,&#34;minutes&#34;:8},&#34;description&#34;:&#34;《如何成为有效学习的高手》\n前言\n高效学习的定义是找到适合自己的学习方法,在最短的时间里能够集中注意力,以解决生活或工作中的一个任务为目的着手学习. 需要勤加练习,必要的时候要向名师求助!\n这其中有七个关键点:\n\n适合自己\n学习方法\n最短时...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B\&#34;&gt;《如何成为有效学习的高手》&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%89%BE%E5%88%B0%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95\&#34;&gt;1.找到适合自己的学习方法&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E7%84%B6%E4%B8%BB%E4%B9%89%E5%92%8C%E7%BB%93%E6%9E%84%E4%B8%BB%E4%B9%89\&#34;&gt;自然主义和结构主义&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E4%B8%8D%E8%B0%88%E5%85%B4%E8%B6%A3-%E7%94%A8%E4%BB%BB%E5%8A%A1%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0\&#34;&gt;2.不谈兴趣, 用任务驱动学习&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E6%8B%96%E5%BB%B6%E7%97%87%E7%9A%84-%E7%A1%AE%E8%AF%8A%E5%92%8C%E6%B2%BB%E7%96%97\&#34;&gt;3.拖延症的 &amp;quot;确诊和治疗&amp;quot;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E5%9C%A8%E8%A1%A3%E9%A3%9F%E4%BD%8F%E8%A1%8C%E4%B8%8A%E8%AE%AD%E7%BB%83%E4%B8%93%E6%B3%A8%E5%8A%9B\&#34;&gt;4.在衣食住行上训练专注力&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E7%9B%B4%E5%A5%94%E5%A4%A7%E5%B8%88-%E4%B8%8D%E5%BF%85%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8B\&#34;&gt;5.直奔大师, 不必从基础开始&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6%E7%BB%99%E8%87%AA%E5%B7%B1%E5%88%B6%E9%80%A0%E5%8F%8D%E9%A6%88\&#34;&gt;6.给自己制造反馈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7%E6%80%8E%E6%A0%B7%E7%AA%81%E7%A0%B4%E5%AD%A6%E4%B9%A0%E7%93%B6%E9%A2%88\&#34;&gt;7.怎样突破学习瓶颈&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E5%A4%9A%E5%B9%B2%E8%B4%A7%E6%96%87%E7%AB%A0\&#34;&gt;更多干货文章&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E5%AE%A2wwwqiuxueweicom\&#34;&gt;博客：www.qiuxuewei.com&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%80%85%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!公众号二维码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;体系结构与操作系统拾遗\&#34;&gt;体系结构与操作系统拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-体系结构基础\&#34;&gt;Part1. 体系结构基础&lt;/h2&gt;\n&lt;h3 id=\&#34;1-冯诺依曼体系结构\&#34;&gt;1. 冯·诺依曼体系结构&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;计算机处理的数据和指令一律用二进制数表示&lt;/li&gt;\n&lt;li&gt;顺序执行程序\n&lt;ol&gt;\n&lt;li&gt;计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序从主存储器中取出指令一条一条地执行，这一概念称作顺序执行程序。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;2-数据的机内表示\&#34;&gt;2. 数据的机内表示&lt;/h3&gt;\n&lt;h4 id=\&#34;二进制表示\&#34;&gt;二进制表示&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;机器数&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;由于计算机中符号和数字是一样的，都必须用二进制数串来表示，因此，正负号也必须用 0、1 来表示。&lt;/li&gt;\n&lt;li&gt;用最高位 0 表示正、1 表示负，这种正负号数字化的机内表示形式就称为 “机器数”，而相应的机器外部用正负号表示的数称为“真值”，将一个真值表示成二进制字串的机器数的过程就称为编码。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;原码&lt;br&gt;\n原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值，比如如果是 8 位二进制:&lt;br&gt;\n[+1]原 = 0000 0001&lt;br&gt;\n[-1]原 = 1000 0001&lt;br&gt;\n第一位是符号位，因为第一位是符号位，所以 8 位二进制的取值范围就是：&lt;br&gt;\n[1111 1111, 0111, 1111] 即 [-127, +127]&lt;br&gt;\n原码是人脑最容易理解和计算表达方式。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;反码&lt;br&gt;\n反码的表示方法是：正数的反码就是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。&lt;br&gt;\n[+1] = 原码:[0000 0001] = 反码:[0000 0001]&lt;br&gt;\n[-1] = 原码:[1000 0001] = 反码:[1111 1110]&lt;br&gt;\n可见如果一个反码表示负数，人脑无法直观的看出它的数值，通常要将其转换成原码再计算。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;补码&lt;br&gt;\n补码的表示方法是：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1。（即在反码的基础上 +1）&lt;br&gt;\n[+1] = 原码:[0000 0001] = 补码:[0000 0001]&lt;br&gt;\n[-1] = 原码:[1000 0001] = 补码:[1111 1111]&lt;br&gt;\n对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码再计算其数值。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;定点数与浮点数&lt;br&gt;\n定点数是小数点固定的数。在计算机中没有专门表示小数点的位，小数点的位置是约定默认的。一般固定在机器数的最低位之后，或是固定在符号位之后。前者称为定点纯整数，后者称为定点纯小数。&lt;br&gt;\n定点数表示法简单直观，但是数值表示的范围太小，运算时容易产生溢出。&lt;/p&gt;\n&lt;p&gt;浮点数是小数点的位置可以变动的数。为增大数值表示范围，防止溢出，采用浮点数表示法。浮点表示法类似于十进制中的科学计数法。&lt;/p&gt;\n&lt;p&gt;在计算机中，通常把浮点数分成阶码和尾数两部分来表示，其中阶码一般用补码定点整数表示，尾数一般用补码或原码定点小数表示。为保证不损失有效数字，对尾数进行格式化处理，也就是平时所说的科学计数法，即保证尾数的最高位为 1，实际数值通过阶码进行调整。&lt;br&gt;\n阶符表示指数的符号位、阶码表示幂次、数符表示尾数的符号位、尾数表示格式化后的小数值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;N = 尾数 x 基数阶码（指数）\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;位bit-字节byte-字word\&#34;&gt;位（Bit）、字节（Byte）、字（Word）&lt;/h4&gt;\n&lt;p&gt;位（Bit）：是电子计算机中最小的数据单位，每一位的状态只能是 0 或 1.&lt;/p&gt;\n&lt;p&gt;字节（Byte）：8 个二进制构成 1 个字节（Byte），它是存储空间的基本计量单位。1 个字节（Byte）可以存储一个英文字母或半个汉字，换而言之：1 个汉字占据 2 个字节（Byte）的存储空间。&lt;/p&gt;\n&lt;p&gt;字（Word）：由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。例如：一台 8 位机，它的 1 个字就等于 1 个字节。如果是一台 16 位机，那么它的 1 个字就由 2 个字节构成，字长为 16 位。字是计算机进行数据处理和运算的单位。&lt;/p&gt;\n&lt;h4 id=\&#34;字节序\&#34;&gt;字节序&lt;/h4&gt;\n&lt;p&gt;字节序（字节顺序）是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。&lt;/p&gt;\n&lt;p&gt;小端字节序（Little Endian）：指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；&lt;br&gt;\n大端字节序（Big Endian）：指高字节数据存放在低地址处，低字节数据存放在高地址处。&lt;/p&gt;\n&lt;p&gt;基于 X86 平台的 PC 机是小端字节序的，而有的嵌入式平台则是大端字节序的。所有网络协议也都是采用大端字节序的方式来传输数据的，所以有时我们也会把大端字节序称之为：网络字节序。&lt;/p&gt;\n&lt;p&gt;比如数字 0x12345678 在两种不同字节序 CPU 中的存储顺序如下所示：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;大端字节序（Big Endian）\n低地址                                            高地址\n----------------------------------------------------&amp;gt;\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     12     |      34    |     56      |     78    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n小端字节序（Little Endian）\n低地址                                            高地址\n----------------------------------------------------&amp;gt;\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     78     |      56    |     34      |     12    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;联合体 &lt;code&gt;union&lt;/code&gt; 的存放顺序是所有成员都从低地址开始存放，利用该特性，就能判断 CPU 对内存采用 Little-Endian 还是 Big-Endian 模式读写。&lt;br&gt;\n示例代码:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;union test {\n    short value;\n    char str[sizeof(short)];\n}example\n\nvoid main()\n{\n    example.value = 0x0102;\n    if (sizeof(short) == 2) {\n        if (example.str[0] == 1 &amp;amp;&amp;amp; example.str[1] == 2) {\n            printf(&amp;quot;大端字节序&amp;quot;);\n        } else if (example.str[0] == 2 &amp;amp;&amp;amp; example.str[1] == 1) {\n            printf(&amp;quot;小端字节序&amp;quot;);        \n        } else {\n            printf(&amp;quot;结果未知&amp;quot;);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;字节对齐\&#34;&gt;字节对齐&lt;/h4&gt;\n&lt;p&gt;现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。&lt;/p&gt;\n&lt;h5 id=\&#34;为什么要进行字节对齐\&#34;&gt;为什么要进行字节对齐？&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;最根本的原因是效率问题，字节对齐能提高存取数据的速度。&lt;/li&gt;\n&lt;li&gt;某些平台只能在特定的地址处访问特定类型的数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;比如有的平台每次都是从偶地址处读取数据，对于一个 int 型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量，但是若从奇地址单元处存放，则需要 2 个读取周期读取该变量。&lt;/p&gt;\n&lt;h5 id=\&#34;字节对齐的原则\&#34;&gt;字节对齐的原则&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;数据成员对齐规则：结构（struct）或联合（union）的数据成员，第一个数据成员放在 &lt;code&gt;offset&lt;/code&gt; 为 0 的地方，以后每个数据成员存储的起初位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组、结构体等）的整数倍开始，比如 int 在 32 位机为 4 字节，则要从 4 的整数倍地址开始存储。&lt;/li&gt;\n&lt;li&gt;结构体作为成员：如果一个结构体里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。（&lt;code&gt;struct a&lt;/code&gt; 里存有 &lt;code&gt;struct b&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt; 里有 &lt;code&gt;char&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt; 等元素，那么 &lt;code&gt;b&lt;/code&gt; 应该从 8 的整数倍开始存储。）&lt;/li&gt;\n&lt;li&gt;结构体的总大小，也就是 &lt;code&gt;sizeof&lt;/code&gt; 的结果，必须使其内部最大成员的整数倍，不足的要补齐。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;part2-操作系统基础\&#34;&gt;Part2. 操作系统基础&lt;/h2&gt;\n&lt;h3 id=\&#34;1-操作系统提供的服务\&#34;&gt;1. 操作系统提供的服务&lt;/h3&gt;\n&lt;p&gt;操作系统五大功能：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;作业管理&lt;/li&gt;\n&lt;li&gt;文件管理&lt;/li&gt;\n&lt;li&gt;存储管理&lt;/li&gt;\n&lt;li&gt;输入输出设备管理&lt;/li&gt;\n&lt;li&gt;进程及处理机管理&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;2-中断与系统调用\&#34;&gt;2. 中断与系统调用&lt;/h3&gt;\n&lt;h4 id=\&#34;中断\&#34;&gt;中断&lt;/h4&gt;\n&lt;p&gt;中断：计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序，等这些特殊事情处理完之后再回去执行之前的程序。&lt;br&gt;\n中断分三类：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;由计算机硬件异常或故障引起的中断，称为内部异常中断；&lt;/li&gt;\n&lt;li&gt;由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）&lt;/li&gt;\n&lt;li&gt;由外部设备请求引起的中断，称为外部中断。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;简单说，对中断的理解就是对一些特殊事情的处理。&lt;/p&gt;\n&lt;p&gt;与中断紧密相连的一个概念就是中断处理程序，当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序。&lt;/p&gt;\n&lt;p&gt;另一个与中断紧密相连的概念是中断的优先级，中断的优先级说明的是当一个中断正在被处理的时候，处理器能接收的中断的级别。中断的优先级表明了中断需要被处理的紧急程度，每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。&lt;br&gt;\n中断优先级：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;机器错误 &amp;gt; 时钟 &amp;gt; 磁盘 &amp;gt; 网络设备 &amp;gt; 终端 &amp;gt; 软件中断\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当发现软件中断时，其他所有的中断都可能发生并被处理；但当发生磁盘中断时，就只有时钟中断和机器错误中断能被处理了。&lt;/p&gt;\n&lt;h4 id=\&#34;系统调用\&#34;&gt;系统调用&lt;/h4&gt;\n&lt;p&gt;进程的执行在系统上的两个级别：用户级（用户态）和核心级（系统态）。&lt;/p&gt;\n&lt;p&gt;程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发生调用服务的请求，这就是系统调用。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口，当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。但这个时候，进程本身其实并没有做什么事情，这个时候是由内核在做相应的操作，去完成进程所提出的这些请求。&lt;/p&gt;\n&lt;p&gt;系统调用和中断的关系在于：当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。&lt;/p&gt;\n&lt;p&gt;用户态和核心态区别：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;用户态的进程能存取他们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据），然而，核心态下的进程能够存取内核和用户地址。&lt;/li&gt;\n&lt;li&gt;某些机器指令是特权指令，在用户态下执行特权指令会引起错误。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;在系统中内核并不是作为一个与用户进程平行的进程的集合，内核是为用户进程运行的。&lt;/strong&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;更多干货文章\&#34;&gt;更多干货文章&lt;/h3&gt;\n&lt;h5 id=\&#34;博客wwwqiuxueweicom\&#34;&gt;博客：&lt;a href=\&#34;http://www.qiuxuewei.com\&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;微信公众号开发者成长之路\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;\&#34;&gt;&lt;img src=\&#34;http://blog.image.jkxuewei.com/sou_wechat.png\&#34; alt=\&#34;公众号二维码\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;\n&lt;hr&gt;\n&#34;,&#34;fileName&#34;:&#34;ti-xi-jie-gou-yu-cao-zuo-xi-tong-shi-yi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;体系结构与操作系统拾遗\&#34;&gt;体系结构与操作系统拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-体系结构基础\&#34;&gt;Part1. 体系结构基础&lt;/h2&gt;\n&lt;h3 id=\&#34;1-冯诺依曼体系结构\&#34;&gt;1. 冯·诺依曼体系结构&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;计算机处理的数据和指令一律用二进制数表示&lt;/li&gt;\n&lt;li&gt;顺序执行程序\n&lt;ol&gt;\n&lt;li&gt;计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序从主存储器中取出指令一条一条地执行，这一概念称作顺序执行程序。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;体系结构与操作系统拾遗&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;计算机&#34;,&#34;slug&#34;:&#34;od9BBCWB7&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/od9BBCWB7/&#34;},{&#34;name&#34;:&#34;操作系统&#34;,&#34;slug&#34;:&#34;Re43WuPjwZ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/Re43WuPjwZ/&#34;}],&#34;date&#34;:&#34;2019-12-28 19:19:19&#34;,&#34;dateFormat&#34;:&#34;2019-12-28&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2019.12.28.15775292852857.victor-aznabaev-pjTU9Edzc1g-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/ti-xi-jie-gou-yu-cao-zuo-xi-tong-shi-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;11 min read&#34;,&#34;time&#34;:645000,&#34;words&#34;:3068,&#34;minutes&#34;:11},&#34;description&#34;:&#34;体系结构与操作系统拾遗\nPart1. 体系结构基础\n1. 冯·诺依曼体系结构\n\n计算机处理的数据和指令一律用二进制数表示\n顺序执行程序\n\n计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8B%BE%E9%81%97\&#34;&gt;体系结构与操作系统拾遗&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#part1-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80\&#34;&gt;Part1. 体系结构基础&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\&#34;&gt;1. 冯·诺依曼体系结构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%86%85%E8%A1%A8%E7%A4%BA\&#34;&gt;2. 数据的机内表示&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA\&#34;&gt;二进制表示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%8Dbit-%E5%AD%97%E8%8A%82byte-%E5%AD%97word\&#34;&gt;位（Bit）、字节（Byte）、字（Word）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E8%8A%82%E5%BA%8F\&#34;&gt;字节序&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90\&#34;&gt;字节对齐&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90\&#34;&gt;为什么要进行字节对齐？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E7%9A%84%E5%8E%9F%E5%88%99\&#34;&gt;字节对齐的原则&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80\&#34;&gt;Part2. 操作系统基础&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1\&#34;&gt;1. 操作系统提供的服务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%B8%AD%E6%96%AD%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\&#34;&gt;2. 中断与系统调用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%AD%E6%96%AD\&#34;&gt;中断&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\&#34;&gt;系统调用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E5%A4%9A%E5%B9%B2%E8%B4%A7%E6%96%87%E7%AB%A0\&#34;&gt;更多干货文章&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E5%AE%A2wwwqiuxueweicom\&#34;&gt;博客：www.qiuxuewei.com&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%80%85%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!公众号二维码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;网络拾遗\&#34;&gt;网络拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-http-协议\&#34;&gt;Part.1 - HTTP 协议&lt;/h2&gt;\n&lt;h3 id=\&#34;1-http-特性\&#34;&gt;1. HTTP 特性&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80。&lt;/li&gt;\n&lt;li&gt;HTTP 是无连接无状态的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;2-http-报文\&#34;&gt;2. HTTP 报文&lt;/h3&gt;\n&lt;p&gt;HTTP 协议是以 ASCII 码进行传输的，建立在 TCP/IP 协议上的应用层规范。规范把 HTTP 分为三个部分：状态行、请求头、请求主体。HTTP 定义了与服务器交互的不同方法，常用的有如下四种：&lt;code&gt;GET&lt;/code&gt; 、&lt;code&gt;POST&lt;/code&gt; 、&lt;code&gt;DELETE&lt;/code&gt; 、&lt;code&gt;PUT&lt;/code&gt;。&lt;br&gt;\nURL 全称是资源描述符，一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 &lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;、&lt;code&gt;GET&lt;/code&gt; 就对应着对这个资源的 增、删、改、查 四个操作。其他请求方式还有：&lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;OPTIONS&lt;/code&gt; 、 &lt;code&gt;TRACE&lt;/code&gt; 、 &lt;code&gt;PATCH&lt;/code&gt; 。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;GET&lt;/code&gt; 用于信息的获取。（安全和幂等）注：安全意味着该操作用于获取信息而非修改信息。幂等意味着对同一 URL 的多个请求应返回同样的结果。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; 表示可能修改服务器上的资源的请求。(非安全、非幂等)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt; 与 &lt;code&gt;GET&lt;/code&gt; 方法类似，但不返回 message body内容，仅仅是获得获取资源的部分信息（content-type、content-length）(安全和幂等)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt; 用于创建、更新资源。（非安全、幂等）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt; 删除资源。（非安全、幂等）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;OPTIONS&lt;/code&gt; 用于 URL 验证，验证接口服务是否正常。（安全、幂等）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;TEACE&lt;/code&gt; 回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现.（安全、幂等）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;PATCH&lt;/code&gt; 用于创建、更新资源，于PUT类似，区别在于PATCH代表部分更新；&lt;br&gt;\n后来提出的接口方法，使用时可能去要验证客户端和服务端是否支持；（非安全、幂等）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;GET 提交的数据量受 URL 长度的限制，HTTP 协议没有对 URL 长度进行限制，这个限制是浏览器和服务器对他的限制；理论上 POST 也是没有大小限制的，HTTP 协议也没有进行大小限制，出于安全考虑，服务器会做一定的限制。&lt;/p&gt;\n&lt;h3 id=\&#34;3-post-提交数据的方式\&#34;&gt;3. POST 提交数据的方式&lt;/h3&gt;\n&lt;p&gt;HTTP 协议中规定 POST 提交的数据必须在 Body 部分中，但协议并未规定数据需要采用何种数据格式或编码方式，服务端通常通过请求头中的 &lt;code&gt;Content-Type&lt;/code&gt; 字段来获知请求中的消息主体是以何种方式编码，再对主体进行解析。&lt;br&gt;\nPOST 提交数据的方案，包含：Content-Type 和消息主体编码方式两部分：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;：最常见的 POST 数据提交方式，浏览器的原生 &lt;form&gt; 表单，如果不设置 &lt;code&gt;enctype&lt;/code&gt; 属性，最终就会以&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 方式提交数据。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;multipart/form-data&lt;/code&gt; ：使用表单上传文件时，必须让表单的 &lt;code&gt;enctype&lt;/code&gt; 等于 &lt;code&gt;multipart/form-data&lt;/code&gt; 。这种方式一般用于上传文件。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;application/json&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;text/xml&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;application/x-protobuf&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;只要服务器可以根据 Content-Type 和 Content-Encoding 正确解析出请求即可。&lt;/p&gt;\n&lt;h3 id=\&#34;4-响应报文\&#34;&gt;4. 响应报文&lt;/h3&gt;\n&lt;p&gt;HTTP 响应跟 HTTP 请求类似，也是由三部分构成：状态行、响应头、响应正文。&lt;br&gt;\n状态行由协议版本、数字形式的状态代码、响应的状态描述构成，各元素以空格分割。常见的状态码：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;200 OK&lt;/code&gt; 客户端请求成功&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;301 Moved Permanently&lt;/code&gt; 请求永久重定向&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;302 Moved Temporarily&lt;/code&gt; 请求临时重定向&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;304 Not Modified&lt;/code&gt; 文件未修改，可以直接使用缓存文件&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;400 Bad Request&lt;/code&gt; 由于客户端请求有语法错误，无法被服务器所理解&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;401 Unauthorized&lt;/code&gt; 请求未经授权（状态代码必须和WWW-Authenticate报头域一起使用）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;403 Forbidden&lt;/code&gt; 服务器收到请求，但拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;404 Not Found&lt;/code&gt; 请求的资源不存在。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt; 服务器发生不可预知的错误，导致无法完成客户端的请求。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;503 Service Unavailable&lt;/code&gt; 服务器当前不可处理客户端的请求，在一段时间后服务器可能会恢复正常。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;5-条件-get\&#34;&gt;5. 条件 GET&lt;/h3&gt;\n&lt;p&gt;HTTP 条件 GET 是HTTP 协议为了减少不必要的宽带浪费，提出的一种方案。&lt;br&gt;\n使用时机：客户端之前已经访问过该网站，并想再次访问。&lt;br&gt;\n使用方法：客户端向服务端发送一个包询问是否在上次访问网站后的时间后更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只需要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。&lt;/p&gt;\n&lt;h3 id=\&#34;6-持久连接\&#34;&gt;6. 持久连接&lt;/h3&gt;\n&lt;p&gt;一般情况下，HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接。&lt;br&gt;\n在 HTTP 1.0 中： 如果客户端浏览器支持 Keep-Alive，那么就在 HTTP 请求头中添加一个字段 &lt;code&gt;Connection-Keep-Alive&lt;/code&gt;。&lt;br&gt;\n在 HTTP 1.1 中：默认所有连接都被保持。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;HTTP Keep-Alive 简单来说就是保持当前 TCP 连接，避免重新建立连接。&lt;/li&gt;\n&lt;li&gt;HTTP 长连接不可能一直保持，例如 &lt;code&gt;Keep-Alive: timeout=5, max=100&lt;/code&gt;，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开.&lt;/li&gt;\n&lt;li&gt;HTTP 是一个无状态协议，这意味着每个请求都是独立的，&lt;code&gt;Keep-Alive&lt;/code&gt; 没有改变这个结果，&lt;code&gt;Keep-Alive&lt;/code&gt; 无法保证客户端和服务端的连接一定是活跃的，唯一能保证的是当连接被断开时将会收到一个通知。&lt;/li&gt;\n&lt;li&gt;使用长连接之后，客户端、服务端怎么知道本次传输结束呢？1. 判断传输数据是否达到了 &lt;code&gt;Content-Length&lt;/code&gt; 指示的大小,2.动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;7-transform-encoding\&#34;&gt;7. Transform-Encoding&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;Transform-Encoding&lt;/code&gt; 是一个用来标明 HTTP 报文传输格式的头部值，当前的 HTTP 规范里只定义了一种传输格式 - &lt;code&gt;chunked&lt;/code&gt;.&lt;br&gt;\n如果一个 HTTP 消息请求或应答消息的 &lt;code&gt;Transform-Encoding&lt;/code&gt; 消息头的值是 chunked ，那么消息体由数量未定的块组成，并以最后一个大小为 0 的块为结束。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;chunked&lt;/code&gt; 和 &lt;code&gt;multipart&lt;/code&gt; 两个名词在意义上有类似的地方，不过在 HTTP 协议当中这两个概念则不是一个类别的。multipart 是一种 &lt;code&gt;Content-Type&lt;/code&gt;，标示 HTTP 报文内容的类型，而 &lt;code&gt;chunked&lt;/code&gt; 是一种传输格式，标示报头将以何种方式进行传输。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;chunked&lt;/code&gt; 传输不能事先知道传输内容的大小，只能靠最后的空 &lt;code&gt;chunked&lt;/code&gt; 块来判断结束，所以对于下载请求，是无法知道下载进度的。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;chunked&lt;/code&gt; 优势在于服务端可以边生成内容边发送，无需事先知道全部内容。HTTP/2 是不支持 &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; 的，因为 HTTP/2 有自己的 streaming 传输方式：&lt;code&gt;Source：MDN - Transfer-Encoding&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;8-http-pipelining-http-管线化\&#34;&gt;8. HTTP Pipelining (HTTP 管线化)&lt;/h3&gt;\n&lt;p&gt;默认情况下，HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于： &lt;code&gt;请求1 -&amp;gt; 响应1 -&amp;gt; 请求2 -&amp;gt; 响应2 -&amp;gt; 请求3 -&amp;gt; 响应3&lt;/code&gt;。&lt;br&gt;\n使用 HTTP Pipelining 是将多个 HTTP 请求打包传递的技术，在传送过程中无需等待服务端的回应，某个连接上消息的传递类似于：&lt;code&gt;请求1 -&amp;gt; 请求2 -&amp;gt; 请求3 -&amp;gt; 响应1 -&amp;gt; 响应2 -&amp;gt; 响应3&lt;/code&gt;。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0不支持）&lt;/li&gt;\n&lt;li&gt;只有 GET 和 HEAD 请求可以实现管线化，POST 则有所限制。&lt;/li&gt;\n&lt;li&gt;初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。&lt;/li&gt;\n&lt;li&gt;管线化不会影响响应到来的顺序。&lt;/li&gt;\n&lt;li&gt;HTTP 1.1 要求服务端实现管线化，不要求服务端也对响应进行管线化处理，只要求对管线化请求不失败即可。&lt;/li&gt;\n&lt;li&gt;由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;9-会话跟踪\&#34;&gt;9. 会话跟踪&lt;/h3&gt;\n&lt;h4 id=\&#34;会话\&#34;&gt;会话&lt;/h4&gt;\n&lt;p&gt;客户端打开与服务端的连接发送请求到服务端响应客户端请求的全过程称之为会话。&lt;/p&gt;\n&lt;h4 id=\&#34;会话跟踪\&#34;&gt;会话跟踪&lt;/h4&gt;\n&lt;p&gt;会话跟踪是对同一个用户对服务器的连续的请求和接收响应的监视。&lt;/p&gt;\n&lt;h4 id=\&#34;为何需要会话跟踪\&#34;&gt;为何需要会话跟踪&lt;/h4&gt;\n&lt;p&gt;客户端跟服务端的通信如果是采用 HTTP 协议通信，而 HTTP 协议是无状态的，它无法保存用户的状态（信息），即一次响应后就断开了，下次请求需要重新连接，此时需要判断是否为同一个用户，所以需要会话跟踪技术实现这种需求。&lt;/p&gt;\n&lt;h4 id=\&#34;会话跟踪常用技术\&#34;&gt;会话跟踪常用技术&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;URL 重写\n&lt;ul&gt;\n&lt;li&gt;URL（统一资源定位符）是Web 上特定界面的地址，URL 重写技术就是在 URL 结尾添加一个附加数据来标识该会话，把会话的 ID 通过 URL 传输给服务端，以便在服务端区分不同用户。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;隐藏表单域\n&lt;ul&gt;\n&lt;li&gt;将会话 ID 添加到HTTP表单元素中提交到服务器，此表单元素客户端不可见&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Cookie\n&lt;ul&gt;\n&lt;li&gt;Cookie 是服务端发送给客户端的一小段信息，客户端请求时可读取该信息发送到服务端，进而进行用户识别，对于客户端的每次请求，服务器会将Cookie 下发到客户端，在客户端可以进行保存以便下一次使用。&lt;/li&gt;\n&lt;li&gt;Cookie 可存放在客户端内存中，称为临时Cookie，客户端关闭即清除；另外可存放在磁盘中，成为永久 Cookie。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Session\n&lt;ul&gt;\n&lt;li&gt;每一个用户都有一个特定的 Session，各个用户之间不可共享，是每个用户独享的，在 Session 中可以存放信息。&lt;/li&gt;\n&lt;li&gt;在服务端会创建一个 Session 对象，产生一个 SessionID 来标示这个Session对象，然后将这个 SessionID 放入 Cookie 中发送给客户端，下一次访问时，SessionID 会再次发送给服务端，在服务端进行识别不同用户&lt;/li&gt;\n&lt;li&gt;Session 的实现依赖于 Cookie，若 Cookie 被禁用，那么 Session 也将失效。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;10跨站攻击\&#34;&gt;10.跨站攻击&lt;/h3&gt;\n&lt;h4 id=\&#34;csrf-cross-site-request-forgery-伪造请求冒充用户在站内的正常操作\&#34;&gt;CSRF （Cross-Site request forgery）- 伪造请求，冒充用户在站内的正常操作。&lt;/h4&gt;\n&lt;p&gt;如何防止 &lt;code&gt;CSRF&lt;/code&gt; 跨站攻击：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;关键操作只接受 POST 请求&lt;/li&gt;\n&lt;li&gt;验证码\n&lt;ul&gt;\n&lt;li&gt;使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;检测 &lt;code&gt;Referer&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 &lt;code&gt;Referer&lt;/code&gt; 中, 通过检查 &lt;code&gt;Referer&lt;/code&gt; 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 &lt;code&gt;Referer&lt;/code&gt; 的值，所以 &lt;code&gt;Referer Check&lt;/code&gt; 一般用于监控 &lt;code&gt;CSRF&lt;/code&gt; 攻击的发生，而不用来抵御攻击。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Token\n&lt;ul&gt;\n&lt;li&gt;对参数进行加密预防 &lt;code&gt;CSRF&lt;/code&gt; 攻击。&lt;/li&gt;\n&lt;li&gt;添加一个新参数 Token，不知道 Token 是无法构造出合法的请求进行攻击的。&lt;/li&gt;\n&lt;li&gt;Token 使用时机：\n&lt;ul&gt;\n&lt;li&gt;Token 要足够随机&lt;/li&gt;\n&lt;li&gt;Token 是一次性的，即每次请求成功后都要更新 Token&lt;/li&gt;\n&lt;li&gt;Token 要注意保密性&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;xss-cross-site-scripting跨站脚本攻击-是注入攻击的一种\&#34;&gt;XSS (Cross Site Scripting，跨站脚本攻击) - 是注入攻击的一种&lt;/h4&gt;\n&lt;p&gt;如果防御 XSS：&lt;br&gt;\n将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。&lt;/p&gt;\n&lt;h2 id=\&#34;part2-http-over-ssltls\&#34;&gt;Part.2 - HTTP over SSL/TLS&lt;/h2&gt;\n&lt;h3 id=\&#34;1-https-基本过程\&#34;&gt;1. HTTPS 基本过程&lt;/h3&gt;\n&lt;p&gt;HTTPS 即 HTTP over SSL/TLS ，是一种在加密通道进行 HTTP 内容传输的协议。&lt;/p&gt;\n&lt;h4 id=\&#34;tls-基本过程\&#34;&gt;TLS 基本过程：&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;客户端发送一个 &lt;code&gt;ClientHello&lt;/code&gt; 消息到服务端，消息中包含了它的 TLS （Transport Layer Security） 的版本、可用的加密算法和压缩算法。&lt;/li&gt;\n&lt;li&gt;服务端向客户端发送一个 &lt;code&gt;ServerHello&lt;/code&gt; 消息，消息中包含了服务端 TLS 的版本，服务端所选择的加密算法和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥来加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。&lt;/li&gt;\n&lt;li&gt;客户端根据自己信任的 CA 列表验证服务端的证书是否可信，如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密他，这串随机数会被用于生成新的对称密钥。&lt;/li&gt;\n&lt;li&gt;服务端使用自己的私钥解密上面的随机数，然后使用这串随机数生成自己的对称主密钥。&lt;/li&gt;\n&lt;li&gt;客户端发送一个 &lt;code&gt;finished&lt;/code&gt; 消息给服务端，使用对称密钥加密这次通信的一个散列值。&lt;/li&gt;\n&lt;li&gt;服务器生成自己的 Hash 值，然后解密客户端发来的信息，检查这两个值是否对应，如果对应就向客户端发送一个 &lt;code&gt;finished&lt;/code&gt; 消息，也使用协商好的对称密钥加密。&lt;/li&gt;\n&lt;li&gt;从现在开始，接下来整个 TLS 会话都使用对称密钥加密，传输应用层（HTTP）内容。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;TLS 的完整过程需要三个算法（协议），密钥交互算法、对称加密算法、消息认证算法&lt;/p&gt;\n&lt;h3 id=\&#34;2-tls-证书机制\&#34;&gt;2. TLS 证书机制&lt;/h3&gt;\n&lt;p&gt;HTTPS 过程中有一个很重要的步骤，就是服务器要有 CA 证书机构颁发的证书，客户端根据自己信任的 CA 列表验证服务器的身份。&lt;br&gt;\n现代浏览器中，证书的验证过程依赖于证书信任链：即一个证书需要依靠上一个证书来证明自己的可信的，最顶层的证书是根证书，拥有根证书的机构被称为 根 CA（一般操作系统自带）。&lt;/p&gt;\n&lt;h3 id=\&#34;3-中间人攻击\&#34;&gt;3. 中间人攻击&lt;/h3&gt;\n&lt;p&gt;所谓中间人攻击，指攻击者与通信的两端都建立独立的联系，并交换其所接受到的数据，使通信的双方都认为他们正在通过私密的连接直接与对方进行通话，事实上整个会话都会被攻击者完全控制。在中间人攻击中，攻击者可以拦截双方的通信并插入新的内容。&lt;/p&gt;\n&lt;h4 id=\&#34;ssl-剥离-问题\&#34;&gt;SSL 剥离 问题&lt;/h4&gt;\n&lt;p&gt;SSL 剥离即阻止用户使用 HTTPS 访问网站。由于并不是所有网站都只支持 HTTPS，大部分网站会同时支持 HTTP 和 HTTPS 两种协议。用户在访问网站时，也可能会在地址栏中输入 &lt;code&gt;http://&lt;/code&gt; 的地址，第一次的访问完全是明文的，这就给了攻击者可乘之机。通过攻击 DNS 响应，攻击者可以将自己变成中间人。&lt;/p&gt;\n&lt;h4 id=\&#34;hsts\&#34;&gt;HSTS&lt;/h4&gt;\n&lt;p&gt;用于强制浏览器使用 HTTPS 访问网站的一种机制。它的基本机制是在服务器返回的响应中，加上一个特殊的头部，指示浏览器对于此网站，强制使用 HTTPS 进行访问。&lt;br&gt;\nHSTS 有一个很明显的缺点，是需要等待第一个服务器的影响中的头部才能生效，但如果第一次访问该网站就被攻击呢？为了解决这个问题，浏览器中会带上一些网站的域名，被称为 HSTS preload list。对于在这个 list 的网站来说，直接强制使用 HTTPS。&lt;/p&gt;\n&lt;h4 id=\&#34;伪造证书攻击\&#34;&gt;伪造证书攻击&lt;/h4&gt;\n&lt;p&gt;HSTS 只解决了 SSL 剥离的问题，然而即使在全程使用 HTTPS 的情况下，我们仍然有可能被监听。&lt;br&gt;\n第一步是需要攻击 DNS 服务器。第二步是攻击者自己的证书需要被用户信任，这一步对于用户来说是很难控制的，需要证书颁发机构能够控制自己不滥发证书。&lt;/p&gt;\n&lt;h4 id=\&#34;hpkp\&#34;&gt;HPKP&lt;/h4&gt;\n&lt;p&gt;HPKP 技术是为了解决伪造证书攻击而诞生的。&lt;br&gt;\nHPKP（Public Key Pinning Extension for HTTP）在 HSTS 上更进一步，HPKP 直接在返回头中存储服务器的公钥指纹信息，一旦发现指纹和实际接受到的公钥有差异，浏览器就可以认为正在被攻击。&lt;br&gt;\n和 HSTS 类似，HPKP 也依赖于服务器的头部返回，不能解决第一次访问的问题，浏览器本身也会内置一些 HPKP 列表。&lt;/p&gt;\n&lt;h2 id=\&#34;part3-tcp-协议\&#34;&gt;Part.3 - TCP 协议&lt;/h2&gt;\n&lt;h3 id=\&#34;1-tcp-的特征\&#34;&gt;1. TCP 的特征&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;TCP 提供一种面向连接的、可靠的字节流服务。&lt;/li&gt;\n&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信，广播和多播不能用于 TCP。&lt;/li&gt;\n&lt;li&gt;TCP 使用校验、确认和重传机制来保证可靠传输。&lt;/li&gt;\n&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认和保证数据的顺序不变和非重复。&lt;/li&gt;\n&lt;li&gt;TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;em&gt;注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能做到的是：如果有可能就把数据递送给对方，否则就通知用户（使用放弃重传并中断连接这一方式实现）。因此准确说 TCP 也不是 100% 可靠的协议，他所能提供的是数据的可靠递送或故障的可靠通知。&lt;/em&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;2-三次握手与四次挥手\&#34;&gt;2. 三次握手与四次挥手&lt;/h3&gt;\n&lt;h4 id=\&#34;三次握手\&#34;&gt;三次握手&lt;/h4&gt;\n&lt;p&gt;所谓三次握手，是指建立一个 &lt;code&gt;TCP&lt;/code&gt; 连接，客户端和服务端需要传送三个包。&lt;br&gt;\n三次握手的目的是连接服务器指定端口，建立 &lt;code&gt;TCP&lt;/code&gt; 连接，并同步连接双方的序列号和确认号，交换 &lt;code&gt;TCP&lt;/code&gt; 窗口大小信息，在 &lt;code&gt;socket&lt;/code&gt; 编程中，客户端执行 &lt;code&gt;connect()&lt;/code&gt; 触发三次握手。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;第一次握手：（SYN = 1，seq = x）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;客户端发送一个 &lt;code&gt;TCP&lt;/code&gt; 的 &lt;code&gt;SYN&lt;/code&gt; 标志位置 1 的包，指明客户端需要连接的端口和初始序号 X, 保存在包头的序列号(Sequence Number)字段里。&lt;/li&gt;\n&lt;li&gt;发送完毕后，客户端进入 &lt;code&gt;SYN_SEND&lt;/code&gt; 状态。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第二次握手：（SYN = 1，ACK = 1，seq = y，ACKnum = x + 1）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;服务端发回确认包（ACK）应答，即 &lt;code&gt;SYN&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 均为 1，服务端选择自己的 &lt;code&gt;ISN&lt;/code&gt; 序号，放到 &lt;code&gt;seq&lt;/code&gt; 域里，同时将确认序号(Acknowledgement Number)设置为客户的 &lt;code&gt;ISN&lt;/code&gt; 加1，即 &lt;code&gt;X+1&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;发送完毕后，服务端进入 &lt;code&gt;SYN_RCVD&lt;/code&gt; 状态。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第三次握手：（ACK = 1，ACKnum = y + 1）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;客户端再次发送确认包（ACK），&lt;code&gt;SYN&lt;/code&gt; 标志位为 0，&lt;code&gt;ACK&lt;/code&gt; 标志位为 1，并且把服务端发送的 &lt;code&gt;ACK&lt;/code&gt; 的序号字段 + 1。&lt;/li&gt;\n&lt;li&gt;发送完毕后，客户端进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，当服务器端接收到这个包时，也进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，&lt;code&gt;TCP&lt;/code&gt; 握手结束。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;三次握手示意图：&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2019.12.24.15771959898620.15771898418684.jpg\&#34; alt=\&#34;-w810\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;四次挥手\&#34;&gt;四次挥手&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt; 的拆除需要发送四个包，因此称为四次挥手，也叫改进的三次握手。客户端和服务端均可主动发起挥手动作，在 &lt;code&gt;socket&lt;/code&gt; 编程中，任意一端执行 &lt;code&gt;close()&lt;/code&gt; 即可产生挥手操作。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;第一次挥手：（FIN = 1，seq = x）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;假设客户端想要关闭连接，客户端发送一个 &lt;code&gt;FIN&lt;/code&gt; 标志位为 1 的包，表示自己没有数据可发送了，但仍可以接收数据。&lt;/li&gt;\n&lt;li&gt;发送完毕后，客户端进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第二次挥手：（ACK = 1，ACKnum = x + 1）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;服务端确认客户端的 &lt;code&gt;FIN&lt;/code&gt; 包，并发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。&lt;/li&gt;\n&lt;li&gt;发送完毕后，服务端进入 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; 状态，客户端接收到这个确认包后，进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 状态，等待服务端关闭连接。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第三次挥手：（FIN = 1，seq = y）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;服务端准备好关闭连接时，向客户端发送结束连接请求，&lt;code&gt;FIN&lt;/code&gt; 置为 1。&lt;/li&gt;\n&lt;li&gt;发送完毕后，服务端进入 &lt;code&gt;LAST_ACK&lt;/code&gt; 状态，等待来自客户端的最后一个 &lt;code&gt;ACK&lt;/code&gt;。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第四次挥手：（ACK = 1，ACKnum = y + 1）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;客户端接收到来自服务端的关闭请求，发送一个确认包，并进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态。等待可能出现的要求重传的 &lt;code&gt;ACK&lt;/code&gt; 包.&lt;/li&gt;\n&lt;li&gt;服务端接收到这个确认包之后，关闭连接，进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态。&lt;/li&gt;\n&lt;li&gt;客户端等待了某个固定时间（两个最大段声明周期）之后，没有收到服务器端的 &lt;code&gt;ACK&lt;/code&gt;，以为服务端已经正常关闭连接，于是自己也关闭连接，进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;四次挥手示意图：&lt;br&gt;\n&lt;img src=\&#34;http://blog.image.jkxuewei.com/mweb/2019.12.24.15771959898660.15771930493721.jpg\&#34; alt=\&#34;-w705\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;3-syn-攻击\&#34;&gt;3. SYN 攻击&lt;/h3&gt;\n&lt;h4 id=\&#34;什么是-syn-攻击\&#34;&gt;什么是 &lt;code&gt;SYN&lt;/code&gt; 攻击？&lt;/h4&gt;\n&lt;p&gt;在三次握手过程中的第二次握手时，服务器发送 &lt;code&gt;SYN_ACK&lt;/code&gt; 之后，收到客户端的 &lt;code&gt;ACK&lt;/code&gt; 之前的 &lt;code&gt;TCP&lt;/code&gt; 连接称为半连接。此时服务器处于 &lt;code&gt;SYN_RCVD&lt;/code&gt; 状态，当收到 &lt;code&gt;ACK&lt;/code&gt; 后，服务器才能转入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;br&gt;\n&lt;code&gt;SYN&lt;/code&gt; 攻击指的是，&amp;quot;攻击客户端&amp;quot; 在短时间内伪造大量不存在的 IP 地址，向服务端不断地发送 &lt;code&gt;SYN&lt;/code&gt; 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 &lt;code&gt;SYN&lt;/code&gt; 包将长时间占用未连接队列，正常的 &lt;code&gt;SYN&lt;/code&gt; 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。&lt;br&gt;\n&lt;strong&gt;&lt;code&gt;SYN&lt;/code&gt; 攻击是一种典型的 &lt;code&gt;Dos/DDos&lt;/code&gt; 攻击&lt;/strong&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;如何检测-syn-攻击\&#34;&gt;如何检测 &lt;code&gt;SYN&lt;/code&gt; 攻击？&lt;/h4&gt;\n&lt;p&gt;当服务器出现大量的半连接状态时，特别是源 IP 地址是随机的，基本可以断定这是一次 &lt;code&gt;SYN&lt;/code&gt; 攻击。在 &lt;code&gt;Linux/Unix&lt;/code&gt; 上可以使用系统自带的 &lt;code&gt;netstats&lt;/code&gt; 命令来检测 &lt;code&gt;SYN&lt;/code&gt; 攻击。&lt;/p&gt;\n&lt;h4 id=\&#34;如何防御-syn-攻击\&#34;&gt;如何防御 &lt;code&gt;SYN&lt;/code&gt; 攻击?&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;SYN&lt;/code&gt; 攻击不能完全被阻止，除非将 &lt;code&gt;TCP&lt;/code&gt; 协议重新设计。可以尽可能减轻 &lt;code&gt;SYN&lt;/code&gt; 攻击的危害：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;缩短超时（SYN Timeout）时间&lt;/li&gt;\n&lt;li&gt;增加最大半连接数&lt;/li&gt;\n&lt;li&gt;过滤网关防护&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;SYN cookie&lt;/code&gt; 技术&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;4-tcp-keepalive\&#34;&gt;4. TCP KeepAlive&lt;/h3&gt;\n&lt;p&gt;TCP 的连接，实际上是一种纯软件层面的概念，在物理层并没有“连接”这种概念。如果出现一些意外导致某端出现异常而另一端无法感知，一直维护着这个连接，长时间会导致非常多的半连接状态的 TCP 连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制来避免。&lt;/p&gt;\n&lt;p&gt;TCP KeepAlive 的基本原理：隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。&lt;/p&gt;\n&lt;p&gt;TCP KeepAlive 的局限：首先 TCP KeepAlive 检测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能再内核层级检测连接的存活与否，而连接的存活不一定代表服务可用，例如当一个服务器 CPU 占用 100% 已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。&lt;/p&gt;\n&lt;h2 id=\&#34;part4-udp-协议\&#34;&gt;Part.4 - UDP 协议&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt; 是一个简单的传输层协议，和 &lt;code&gt;TCP&lt;/code&gt; 相比，&lt;code&gt;UDP&lt;/code&gt; 有如下几个显著的特性：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 缺乏可靠性。&lt;code&gt;UDP&lt;/code&gt; 本身不提供确认序列号、超时重传等机制。&lt;code&gt;UDP&lt;/code&gt; 数据报可能在网络中被复制，被重新排序。即 &lt;code&gt;UDP&lt;/code&gt; 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 数据报是有长度的。每个 &lt;code&gt;UDP&lt;/code&gt; 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 &lt;code&gt;TCP&lt;/code&gt; 是一个字节流协议，没有任何协议上的记录边界。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 是无连接的。&lt;code&gt;UDP&lt;/code&gt; 客户端和服务器之间不存在长期的关系，&lt;code&gt;UDP&lt;/code&gt; 发送数据报之前也不需要经过握手创建连接的过程&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;UDP&lt;/code&gt; 支持多播和广播。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;part5-ip-协议\&#34;&gt;Part.5 - IP 协议&lt;/h2&gt;\n&lt;p&gt;IP 协议位于 TCP/IP 协议的第三层 - 网络层。与传输层协议相比，网络层的责任是提供点到点的服务，而传输层（TCP/UDP）则提供端到端的服务。&lt;/p&gt;\n&lt;h3 id=\&#34;1-网络-osi-的七层协议\&#34;&gt;1. 网络 OSI 的七层协议&lt;/h3&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;-&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;-&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;7&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;应用层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;6&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;表示层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;5&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;会话层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;4&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;传输层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;3&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;网络层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;2&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;数据链路层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;物理层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h3 id=\&#34;2-ip-地址的分类\&#34;&gt;2. IP 地址的分类&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;A 类地址&lt;/li&gt;\n&lt;li&gt;B 类地址&lt;/li&gt;\n&lt;li&gt;C 类地址&lt;/li&gt;\n&lt;li&gt;D 类地址&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;3-广播与多播\&#34;&gt;3. 广播与多播&lt;/h3&gt;\n&lt;p&gt;广播与多播仅用于 UDP（TCP 是面向连接的）&lt;/p&gt;\n&lt;h4 id=\&#34;广播\&#34;&gt;广播&lt;/h4&gt;\n&lt;p&gt;一共有四种广播地址：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;受限的广播：受限的广播地址为 &lt;code&gt;255.255.255.255&lt;/code&gt;，&lt;/li&gt;\n&lt;li&gt;指向网络的广播：主机号为全 1 的地址&lt;/li&gt;\n&lt;li&gt;指向子网的广播&lt;/li&gt;\n&lt;li&gt;指向所有子网的广播&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;多播\&#34;&gt;多播&lt;/h4&gt;\n&lt;p&gt;又称组播，使用 D 类地址，D类地址分配的 28bit 均用作多播组号而不再表示其他&lt;/p&gt;\n&lt;h4 id=\&#34;bgp\&#34;&gt;BGP&lt;/h4&gt;\n&lt;p&gt;边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议&lt;/p&gt;\n&lt;h2 id=\&#34;part6-socket-编程\&#34;&gt;Part.6 - Socket 编程&lt;/h2&gt;\n&lt;h3 id=\&#34;1-socket-基本概念\&#34;&gt;1. Socket 基本概念&lt;/h3&gt;\n&lt;p&gt;Socket 是对 TCP/IP 协议族的一种封装，是应用层与 TCP/IP 协议族通信的中间软件抽象层。从设计模式的角度看，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。&lt;br&gt;\nSocket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（IP 地址、协议、端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其他进程进行交互。&lt;br&gt;\nSocket 起源于 Unix，Unix/Linux 基本哲学之一就是：一切皆文件，都可以用“打开（open）-&amp;gt; 读写（write/read）-&amp;gt; 关闭（close）”模式来进行操作，因此 Socket 也被处理为一种特殊的文件。&lt;/p&gt;\n&lt;h3 id=\&#34;2-写一个简单的-webserver\&#34;&gt;2. 写一个简单的 WebServer&lt;/h3&gt;\n&lt;p&gt;一个简单的 Server 的流程包括：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;建立连接，接受一个客户端连接。&lt;/li&gt;\n&lt;li&gt;接受请求，从网络中读取一条 HTTP 请求报文。&lt;/li&gt;\n&lt;li&gt;处理请求，访问资源。&lt;/li&gt;\n&lt;li&gt;构建响应，创建带有 header 的 HTTP 响应报文。&lt;/li&gt;\n&lt;li&gt;发送响应，传给客户端。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;大体的程序与调用的函数逻辑：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;socket()&lt;/code&gt; 创建套接字&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;bind()&lt;/code&gt; 分配套接字地址&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;listen()&lt;/code&gt; 等待连接请求&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;accept()&lt;/code&gt; 允许连接请求&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;read()/write()&lt;/code&gt; 数据交换&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;close()&lt;/code&gt; 关闭连接&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;更多干货文章\&#34;&gt;更多干货文章&lt;/h3&gt;\n&lt;h5 id=\&#34;博客wwwqiuxueweicom\&#34;&gt;博客：&lt;a href=\&#34;http://www.qiuxuewei.com\&#34;&gt;www.qiuxuewei.com&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;微信公众号开发者成长之路\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;\&#34;&gt;&lt;img src=\&#34;http://blog.image.jkxuewei.com/sou_wechat.png\&#34; alt=\&#34;公众号二维码\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;一个没有鸡汤只有干货的公众号&lt;/strong&gt;&lt;/p&gt;\n&lt;hr&gt;\n&#34;,&#34;fileName&#34;:&#34;wang-luo-shi-yi&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;网络拾遗\&#34;&gt;网络拾遗&lt;/h1&gt;\n&lt;h2 id=\&#34;part1-http-协议\&#34;&gt;Part.1 - HTTP 协议&lt;/h2&gt;\n&lt;h3 id=\&#34;1-http-特性\&#34;&gt;1. HTTP 特性&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80。&lt;/li&gt;\n&lt;li&gt;HTTP 是无连接无状态的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;2-http-报文\&#34;&gt;2. HTTP 报文&lt;/h3&gt;\n&lt;p&gt;HTTP 协议是以 ASCII 码进行传输的，建立在 TCP/IP 协议上的应用层规范。规范把 HTTP 分为三个部分：状态行、请求头、请求主体。HTTP 定义了与服务器交互的不同方法，常用的有如下四种：&lt;code&gt;GET&lt;/code&gt; 、&lt;code&gt;POST&lt;/code&gt; 、&lt;code&gt;DELETE&lt;/code&gt; 、&lt;code&gt;PUT&lt;/code&gt;。&lt;br&gt;\nURL 全称是资源描述符，一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 &lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;、&lt;code&gt;GET&lt;/code&gt; 就对应着对这个资源的 增、删、改、查 四个操作。其他请求方式还有：&lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;OPTIONS&lt;/code&gt; 、 &lt;code&gt;TRACE&lt;/code&gt; 、 &lt;code&gt;PATCH&lt;/code&gt; 。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;网络拾遗&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;网络&#34;,&#34;slug&#34;:&#34;3PTRhtuva&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://qxuewei.github.io/tag/3PTRhtuva/&#34;}],&#34;date&#34;:&#34;2019-12-24 12:23:24&#34;,&#34;dateFormat&#34;:&#34;2019-12-24&#34;,&#34;feature&#34;:&#34;http://blog.image.jkxuewei.com/mweb/2019.12.26.15773454163538.taylor-vick-M5tzZtFCOfs-unsplash.jpg&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/wang-luo-shi-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;27 min read&#34;,&#34;time&#34;:1561000,&#34;words&#34;:7214,&#34;minutes&#34;:27},&#34;description&#34;:&#34;网络拾遗\nPart.1 - HTTP 协议\n1. HTTP 特性\n\nHTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80。\nHTTP 是无连接无状态的。\n\n2. HTTP 报文\nHTTP 协议是以 ASCII ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%BB%9C%E6%8B%BE%E9%81%97\&#34;&gt;网络拾遗&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#part1-http-%E5%8D%8F%E8%AE%AE\&#34;&gt;Part.1 - HTTP 协议&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-http-%E7%89%B9%E6%80%A7\&#34;&gt;1. HTTP 特性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-http-%E6%8A%A5%E6%96%87\&#34;&gt;2. HTTP 报文&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-post-%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F\&#34;&gt;3. POST 提交数据的方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87\&#34;&gt;4. 响应报文&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E6%9D%A1%E4%BB%B6-get\&#34;&gt;5. 条件 GET&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5\&#34;&gt;6. 持久连接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-transform-encoding\&#34;&gt;7. Transform-Encoding&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-http-pipelining-http-%E7%AE%A1%E7%BA%BF%E5%8C%96\&#34;&gt;8. HTTP Pipelining (HTTP 管线化)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9-%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA\&#34;&gt;9. 会话跟踪&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%9A%E8%AF%9D\&#34;&gt;会话&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA\&#34;&gt;会话跟踪&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA\&#34;&gt;为何需要会话跟踪&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF\&#34;&gt;会话跟踪常用技术&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#10%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB\&#34;&gt;10.跨站攻击&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#csrf-cross-site-request-forgery-%E4%BC%AA%E9%80%A0%E8%AF%B7%E6%B1%82%E5%86%92%E5%85%85%E7%94%A8%E6%88%B7%E5%9C%A8%E7%AB%99%E5%86%85%E7%9A%84%E6%AD%A3%E5%B8%B8%E6%93%8D%E4%BD%9C\&#34;&gt;CSRF （Cross-Site request forgery）- 伪造请求，冒充用户在站内的正常操作。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#xss-cross-site-scripting%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-%E6%98%AF%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E7%A7%8D\&#34;&gt;XSS (Cross Site Scripting，跨站脚本攻击) - 是注入攻击的一种&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part2-http-over-ssltls\&#34;&gt;Part.2 - HTTP over SSL/TLS&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-https-%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B\&#34;&gt;1. HTTPS 基本过程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#tls-%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B\&#34;&gt;TLS 基本过程：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-tls-%E8%AF%81%E4%B9%A6%E6%9C%BA%E5%88%B6\&#34;&gt;2. TLS 证书机制&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\&#34;&gt;3. 中间人攻击&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ssl-%E5%89%A5%E7%A6%BB-%E9%97%AE%E9%A2%98\&#34;&gt;SSL 剥离 问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#hsts\&#34;&gt;HSTS&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%AA%E9%80%A0%E8%AF%81%E4%B9%A6%E6%94%BB%E5%87%BB\&#34;&gt;伪造证书攻击&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#hpkp\&#34;&gt;HPKP&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part3-tcp-%E5%8D%8F%E8%AE%AE\&#34;&gt;Part.3 - TCP 协议&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-tcp-%E7%9A%84%E7%89%B9%E5%BE%81\&#34;&gt;1. TCP 的特征&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;2. 三次握手与四次挥手&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\&#34;&gt;三次握手&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;四次挥手&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-syn-%E6%94%BB%E5%87%BB\&#34;&gt;3. SYN 攻击&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF-syn-%E6%94%BB%E5%87%BB\&#34;&gt;什么是 &lt;code&gt;SYN&lt;/code&gt; 攻击？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B-syn-%E6%94%BB%E5%87%BB\&#34;&gt;如何检测 &lt;code&gt;SYN&lt;/code&gt; 攻击？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-syn-%E6%94%BB%E5%87%BB\&#34;&gt;如何防御 &lt;code&gt;SYN&lt;/code&gt; 攻击?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-tcp-keepalive\&#34;&gt;4. TCP KeepAlive&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part4-udp-%E5%8D%8F%E8%AE%AE\&#34;&gt;Part.4 - UDP 协议&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part5-ip-%E5%8D%8F%E8%AE%AE\&#34;&gt;Part.5 - IP 协议&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E7%BD%91%E7%BB%9C-osi-%E7%9A%84%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE\&#34;&gt;1. 网络 OSI 的七层协议&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-ip-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB\&#34;&gt;2. IP 地址的分类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%B9%BF%E6%92%AD%E4%B8%8E%E5%A4%9A%E6%92%AD\&#34;&gt;3. 广播与多播&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B9%BF%E6%92%AD\&#34;&gt;广播&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E6%92%AD\&#34;&gt;多播&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bgp\&#34;&gt;BGP&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#part6-socket-%E7%BC%96%E7%A8%8B\&#34;&gt;Part.6 - Socket 编程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-socket-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\&#34;&gt;1. Socket 基本概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-webserver\&#34;&gt;2. 写一个简单的 WebServer&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E5%A4%9A%E5%B9%B2%E8%B4%A7%E6%96%87%E7%AB%A0\&#34;&gt;更多干货文章&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E5%AE%A2wwwqiuxueweicom\&#34;&gt;博客：www.qiuxuewei.com&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%80%85%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF\&#34;&gt;微信公众号：&lt;strong&gt;@开发者成长之路&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!公众号二维码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;关于我\&#34;&gt;关于我 👇🏻&lt;/h2&gt;\n&lt;p&gt;👨🏻‍💻全职独立开发者👨🏻‍💻&lt;br&gt;\n作品：学伟扫描、加一&lt;br&gt;\n前BAT高级iOS研发工程师~&lt;br&gt;\n旅行、篮球、阅读、电影、摄影爱好者~&lt;br&gt;\n在公众号「极客学伟」记录创业日常~&lt;/p&gt;\n&lt;h5 id=\&#34;微信公众号极客学伟\&#34;&gt;🤗 微信公众号：极客学伟&lt;/h5&gt;\n&lt;h5 id=\&#34;️-e-mail-jkxueweigmailcom-换成\&#34;&gt;✉️ E-mail： &amp;lt;jkxuewei#gmail.com&amp;gt; (&#39;#&#39;换成&#39;@&#39;)&lt;/h5&gt;\n&lt;h5 id=\&#34;微博极客学伟\&#34;&gt;📜 微博：&lt;a href=\&#34;https://weibo.com/qxuewei\&#34;&gt;@极客学伟&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;githubgithub主页\&#34;&gt;🤖 GitHub：&lt;a href=\&#34;https://github.com/qxuewei\&#34;&gt;GitHub主页&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;csdn-极客学伟的技术分享社区\&#34;&gt;👨🏻‍🏫 CSDN: &lt;a href=\&#34;https://xuewei.blog.csdn.net/\&#34;&gt;极客学伟的技术分享社区&lt;/a&gt;&lt;/h5&gt;\n&lt;h5 id=\&#34;独立开发作品学伟扫描\&#34;&gt;🌽 独立开发作品：学伟扫描...&lt;/h5&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-12-21 21:37:03&#34;,&#34;dateFormat&#34;:&#34;2019-12-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://qxuewei.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:22000,&#34;words&#34;:104,&#34;minutes&#34;:1},&#34;description&#34;:&#34;关于我 👇🏻\n👨🏻‍💻全职独立开发者👨🏻‍💻\n作品：学伟扫描、加一\n前BAT高级iOS研发工程师~\n旅行、篮球、阅读、电影、摄影爱好者~\n在公众号「极客学伟」记录创业日常~\n🤗 微信公众号：极客学伟\n✉️ E-mail： ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%88%91\&#34;&gt;关于我 👇🏻&lt;/a&gt;&lt;br&gt;\n*&lt;br&gt;\n*&lt;br&gt;\n* &lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9E%81%E5%AE%A2%E5%AD%A6%E4%BC%9F\&#34;&gt;🤗 微信公众号：极客学伟&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#%EF%B8%8F-e-mail-jkxueweigmailcom-%E6%8D%A2%E6%88%90\&#34;&gt;✉️ E-mail： &amp;lt;jkxuewei#gmail.com&amp;gt; (&#39;#&#39;换成&#39;@&#39;)&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#%E5%BE%AE%E5%8D%9A%E6%9E%81%E5%AE%A2%E5%AD%A6%E4%BC%9F\&#34;&gt;📜 微博：@极客学伟&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#githubgithub%E4%B8%BB%E9%A1%B5\&#34;&gt;🤖 GitHub：GitHub主页&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#csdn-%E6%9E%81%E5%AE%A2%E5%AD%A6%E4%BC%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA\&#34;&gt;👨🏻‍🏫 CSDN: 极客学伟的技术分享社区&lt;/a&gt;&lt;br&gt;\n* &lt;a href=\&#34;#%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%BD%9C%E5%93%81%E5%AD%A6%E4%BC%9F%E6%89%AB%E6%8F%8F\&#34;&gt;🌽 独立开发作品：学伟扫描...&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>


</html>